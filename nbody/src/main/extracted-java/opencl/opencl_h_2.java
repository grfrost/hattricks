// Generated by jextract

package opencl;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class opencl_h_2 extends opencl_h_3 {

    opencl_h_2() {
        // Should not be called directly
    }
    private static final int S_IFSOCK = (int)49152L;
    /**
     * {@snippet lang=c :
     * #define S_IFSOCK 49152
     * }
     */
    public static int S_IFSOCK() {
        return S_IFSOCK;
    }
    private static final int S_IFWHT = (int)57344L;
    /**
     * {@snippet lang=c :
     * #define S_IFWHT 57344
     * }
     */
    public static int S_IFWHT() {
        return S_IFWHT;
    }
    private static final int S_IRWXU = (int)448L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXU 448
     * }
     */
    public static int S_IRWXU() {
        return S_IRWXU;
    }
    private static final int S_IRUSR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define S_IRUSR 256
     * }
     */
    public static int S_IRUSR() {
        return S_IRUSR;
    }
    private static final int S_IWUSR = (int)128L;
    /**
     * {@snippet lang=c :
     * #define S_IWUSR 128
     * }
     */
    public static int S_IWUSR() {
        return S_IWUSR;
    }
    private static final int S_IXUSR = (int)64L;
    /**
     * {@snippet lang=c :
     * #define S_IXUSR 64
     * }
     */
    public static int S_IXUSR() {
        return S_IXUSR;
    }
    private static final int S_IRWXG = (int)56L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXG 56
     * }
     */
    public static int S_IRWXG() {
        return S_IRWXG;
    }
    private static final int S_IRGRP = (int)32L;
    /**
     * {@snippet lang=c :
     * #define S_IRGRP 32
     * }
     */
    public static int S_IRGRP() {
        return S_IRGRP;
    }
    private static final int S_IWGRP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define S_IWGRP 16
     * }
     */
    public static int S_IWGRP() {
        return S_IWGRP;
    }
    private static final int S_IXGRP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define S_IXGRP 8
     * }
     */
    public static int S_IXGRP() {
        return S_IXGRP;
    }
    private static final int S_IRWXO = (int)7L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXO 7
     * }
     */
    public static int S_IRWXO() {
        return S_IRWXO;
    }
    private static final int S_IROTH = (int)4L;
    /**
     * {@snippet lang=c :
     * #define S_IROTH 4
     * }
     */
    public static int S_IROTH() {
        return S_IROTH;
    }
    private static final int S_IWOTH = (int)2L;
    /**
     * {@snippet lang=c :
     * #define S_IWOTH 2
     * }
     */
    public static int S_IWOTH() {
        return S_IWOTH;
    }
    private static final int S_IXOTH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define S_IXOTH 1
     * }
     */
    public static int S_IXOTH() {
        return S_IXOTH;
    }
    private static final int S_ISUID = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define S_ISUID 2048
     * }
     */
    public static int S_ISUID() {
        return S_ISUID;
    }
    private static final int S_ISGID = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define S_ISGID 1024
     * }
     */
    public static int S_ISGID() {
        return S_ISGID;
    }
    private static final int S_ISVTX = (int)512L;
    /**
     * {@snippet lang=c :
     * #define S_ISVTX 512
     * }
     */
    public static int S_ISVTX() {
        return S_ISVTX;
    }
    private static final int F_ALLOCATECONTIG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define F_ALLOCATECONTIG 2
     * }
     */
    public static int F_ALLOCATECONTIG() {
        return F_ALLOCATECONTIG;
    }
    private static final int F_ALLOCATEALL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define F_ALLOCATEALL 4
     * }
     */
    public static int F_ALLOCATEALL() {
        return F_ALLOCATEALL;
    }
    private static final int F_ALLOCATEPERSIST = (int)8L;
    /**
     * {@snippet lang=c :
     * #define F_ALLOCATEPERSIST 8
     * }
     */
    public static int F_ALLOCATEPERSIST() {
        return F_ALLOCATEPERSIST;
    }
    private static final int F_PEOFPOSMODE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define F_PEOFPOSMODE 3
     * }
     */
    public static int F_PEOFPOSMODE() {
        return F_PEOFPOSMODE;
    }
    private static final int F_VOLPOSMODE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define F_VOLPOSMODE 4
     * }
     */
    public static int F_VOLPOSMODE() {
        return F_VOLPOSMODE;
    }
    private static final int USER_FSIGNATURES_CDHASH_LEN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define USER_FSIGNATURES_CDHASH_LEN 20
     * }
     */
    public static int USER_FSIGNATURES_CDHASH_LEN() {
        return USER_FSIGNATURES_CDHASH_LEN;
    }
    private static final int GETSIGSINFO_PLATFORM_BINARY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GETSIGSINFO_PLATFORM_BINARY 1
     * }
     */
    public static int GETSIGSINFO_PLATFORM_BINARY() {
        return GETSIGSINFO_PLATFORM_BINARY;
    }
    private static final int LOCK_SH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LOCK_SH 1
     * }
     */
    public static int LOCK_SH() {
        return LOCK_SH;
    }
    private static final int LOCK_EX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LOCK_EX 2
     * }
     */
    public static int LOCK_EX() {
        return LOCK_EX;
    }
    private static final int LOCK_NB = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LOCK_NB 4
     * }
     */
    public static int LOCK_NB() {
        return LOCK_NB;
    }
    private static final int LOCK_UN = (int)8L;
    /**
     * {@snippet lang=c :
     * #define LOCK_UN 8
     * }
     */
    public static int LOCK_UN() {
        return LOCK_UN;
    }
    private static final int ATTRIBUTION_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define ATTRIBUTION_NAME_MAX 255
     * }
     */
    public static int ATTRIBUTION_NAME_MAX() {
        return ATTRIBUTION_NAME_MAX;
    }
    private static final int F_CREATE_TAG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define F_CREATE_TAG 1
     * }
     */
    public static int F_CREATE_TAG() {
        return F_CREATE_TAG;
    }
    private static final int F_DELETE_TAG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define F_DELETE_TAG 2
     * }
     */
    public static int F_DELETE_TAG() {
        return F_DELETE_TAG;
    }
    private static final int F_QUERY_TAG = (int)4L;
    /**
     * {@snippet lang=c :
     * #define F_QUERY_TAG 4
     * }
     */
    public static int F_QUERY_TAG() {
        return F_QUERY_TAG;
    }
    private static final int O_ALERT = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define O_ALERT 536870912
     * }
     */
    public static int O_ALERT() {
        return O_ALERT;
    }
    private static final int DISPATCH_API_VERSION = (int)20181008L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_API_VERSION 20181008
     * }
     */
    public static int DISPATCH_API_VERSION() {
        return DISPATCH_API_VERSION;
    }
    private static final int OS_OBJECT_HAVE_OBJC_SUPPORT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OS_OBJECT_HAVE_OBJC_SUPPORT 0
     * }
     */
    public static int OS_OBJECT_HAVE_OBJC_SUPPORT() {
        return OS_OBJECT_HAVE_OBJC_SUPPORT;
    }
    private static final int OS_OBJECT_USE_OBJC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OS_OBJECT_USE_OBJC 0
     * }
     */
    public static int OS_OBJECT_USE_OBJC() {
        return OS_OBJECT_USE_OBJC;
    }
    private static final int OS_OBJECT_SWIFT3 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OS_OBJECT_SWIFT3 0
     * }
     */
    public static int OS_OBJECT_SWIFT3() {
        return OS_OBJECT_SWIFT3;
    }
    private static final int OS_OBJECT_USE_OBJC_RETAIN_RELEASE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define OS_OBJECT_USE_OBJC_RETAIN_RELEASE 0
     * }
     */
    public static int OS_OBJECT_USE_OBJC_RETAIN_RELEASE() {
        return OS_OBJECT_USE_OBJC_RETAIN_RELEASE;
    }
    private static final int __DARWIN_NSIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NSIG 32
     * }
     */
    public static int __DARWIN_NSIG() {
        return __DARWIN_NSIG;
    }
    private static final int _ARM_SIGNAL_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_SIGNAL_ 1
     * }
     */
    public static int _ARM_SIGNAL_() {
        return _ARM_SIGNAL_;
    }
    private static final int SIGHUP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIGHUP 1
     * }
     */
    public static int SIGHUP() {
        return SIGHUP;
    }
    private static final int SIGINT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIGINT 2
     * }
     */
    public static int SIGINT() {
        return SIGINT;
    }
    private static final int SIGQUIT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIGQUIT 3
     * }
     */
    public static int SIGQUIT() {
        return SIGQUIT;
    }
    private static final int SIGILL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SIGILL 4
     * }
     */
    public static int SIGILL() {
        return SIGILL;
    }
    private static final int SIGTRAP = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SIGTRAP 5
     * }
     */
    public static int SIGTRAP() {
        return SIGTRAP;
    }
    private static final int SIGABRT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGABRT 6
     * }
     */
    public static int SIGABRT() {
        return SIGABRT;
    }
    private static final int SIGEMT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SIGEMT 7
     * }
     */
    public static int SIGEMT() {
        return SIGEMT;
    }
    private static final int SIGFPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SIGFPE 8
     * }
     */
    public static int SIGFPE() {
        return SIGFPE;
    }
    private static final int SIGKILL = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SIGKILL 9
     * }
     */
    public static int SIGKILL() {
        return SIGKILL;
    }
    private static final int SIGBUS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define SIGBUS 10
     * }
     */
    public static int SIGBUS() {
        return SIGBUS;
    }
    private static final int SIGSEGV = (int)11L;
    /**
     * {@snippet lang=c :
     * #define SIGSEGV 11
     * }
     */
    public static int SIGSEGV() {
        return SIGSEGV;
    }
    private static final int SIGSYS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define SIGSYS 12
     * }
     */
    public static int SIGSYS() {
        return SIGSYS;
    }
    private static final int SIGPIPE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define SIGPIPE 13
     * }
     */
    public static int SIGPIPE() {
        return SIGPIPE;
    }
    private static final int SIGALRM = (int)14L;
    /**
     * {@snippet lang=c :
     * #define SIGALRM 14
     * }
     */
    public static int SIGALRM() {
        return SIGALRM;
    }
    private static final int SIGTERM = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SIGTERM 15
     * }
     */
    public static int SIGTERM() {
        return SIGTERM;
    }
    private static final int SIGURG = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SIGURG 16
     * }
     */
    public static int SIGURG() {
        return SIGURG;
    }
    private static final int SIGSTOP = (int)17L;
    /**
     * {@snippet lang=c :
     * #define SIGSTOP 17
     * }
     */
    public static int SIGSTOP() {
        return SIGSTOP;
    }
    private static final int SIGTSTP = (int)18L;
    /**
     * {@snippet lang=c :
     * #define SIGTSTP 18
     * }
     */
    public static int SIGTSTP() {
        return SIGTSTP;
    }
    private static final int SIGCONT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define SIGCONT 19
     * }
     */
    public static int SIGCONT() {
        return SIGCONT;
    }
    private static final int SIGCHLD = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SIGCHLD 20
     * }
     */
    public static int SIGCHLD() {
        return SIGCHLD;
    }
    private static final int SIGTTIN = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SIGTTIN 21
     * }
     */
    public static int SIGTTIN() {
        return SIGTTIN;
    }
    private static final int SIGTTOU = (int)22L;
    /**
     * {@snippet lang=c :
     * #define SIGTTOU 22
     * }
     */
    public static int SIGTTOU() {
        return SIGTTOU;
    }
    private static final int SIGIO = (int)23L;
    /**
     * {@snippet lang=c :
     * #define SIGIO 23
     * }
     */
    public static int SIGIO() {
        return SIGIO;
    }
    private static final int SIGXCPU = (int)24L;
    /**
     * {@snippet lang=c :
     * #define SIGXCPU 24
     * }
     */
    public static int SIGXCPU() {
        return SIGXCPU;
    }
    private static final int SIGXFSZ = (int)25L;
    /**
     * {@snippet lang=c :
     * #define SIGXFSZ 25
     * }
     */
    public static int SIGXFSZ() {
        return SIGXFSZ;
    }
    private static final int SIGVTALRM = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SIGVTALRM 26
     * }
     */
    public static int SIGVTALRM() {
        return SIGVTALRM;
    }
    private static final int SIGPROF = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SIGPROF 27
     * }
     */
    public static int SIGPROF() {
        return SIGPROF;
    }
    private static final int SIGWINCH = (int)28L;
    /**
     * {@snippet lang=c :
     * #define SIGWINCH 28
     * }
     */
    public static int SIGWINCH() {
        return SIGWINCH;
    }
    private static final int SIGINFO = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SIGINFO 29
     * }
     */
    public static int SIGINFO() {
        return SIGINFO;
    }
    private static final int SIGUSR1 = (int)30L;
    /**
     * {@snippet lang=c :
     * #define SIGUSR1 30
     * }
     */
    public static int SIGUSR1() {
        return SIGUSR1;
    }
    private static final int SIGUSR2 = (int)31L;
    /**
     * {@snippet lang=c :
     * #define SIGUSR2 31
     * }
     */
    public static int SIGUSR2() {
        return SIGUSR2;
    }
    private static final int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_OPAQUE_ARM_THREAD_STATE64 0
     * }
     */
    public static int __DARWIN_OPAQUE_ARM_THREAD_STATE64() {
        return __DARWIN_OPAQUE_ARM_THREAD_STATE64;
    }
    private static final int SIGEV_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_NONE 0
     * }
     */
    public static int SIGEV_NONE() {
        return SIGEV_NONE;
    }
    private static final int SIGEV_SIGNAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_SIGNAL 1
     * }
     */
    public static int SIGEV_SIGNAL() {
        return SIGEV_SIGNAL;
    }
    private static final int SIGEV_THREAD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIGEV_THREAD 3
     * }
     */
    public static int SIGEV_THREAD() {
        return SIGEV_THREAD;
    }
    private static final int ILL_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ILL_NOOP 0
     * }
     */
    public static int ILL_NOOP() {
        return ILL_NOOP;
    }
    private static final int ILL_ILLOPC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLOPC 1
     * }
     */
    public static int ILL_ILLOPC() {
        return ILL_ILLOPC;
    }
    private static final int ILL_ILLTRP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLTRP 2
     * }
     */
    public static int ILL_ILLTRP() {
        return ILL_ILLTRP;
    }
    private static final int ILL_PRVOPC = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ILL_PRVOPC 3
     * }
     */
    public static int ILL_PRVOPC() {
        return ILL_PRVOPC;
    }
    private static final int ILL_ILLOPN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLOPN 4
     * }
     */
    public static int ILL_ILLOPN() {
        return ILL_ILLOPN;
    }
    private static final int ILL_ILLADR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define ILL_ILLADR 5
     * }
     */
    public static int ILL_ILLADR() {
        return ILL_ILLADR;
    }
    private static final int ILL_PRVREG = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ILL_PRVREG 6
     * }
     */
    public static int ILL_PRVREG() {
        return ILL_PRVREG;
    }
    private static final int ILL_COPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define ILL_COPROC 7
     * }
     */
    public static int ILL_COPROC() {
        return ILL_COPROC;
    }
    private static final int ILL_BADSTK = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ILL_BADSTK 8
     * }
     */
    public static int ILL_BADSTK() {
        return ILL_BADSTK;
    }
    private static final int FPE_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FPE_NOOP 0
     * }
     */
    public static int FPE_NOOP() {
        return FPE_NOOP;
    }
    private static final int FPE_FLTDIV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTDIV 1
     * }
     */
    public static int FPE_FLTDIV() {
        return FPE_FLTDIV;
    }
    private static final int FPE_FLTOVF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTOVF 2
     * }
     */
    public static int FPE_FLTOVF() {
        return FPE_FLTOVF;
    }
    private static final int FPE_FLTUND = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTUND 3
     * }
     */
    public static int FPE_FLTUND() {
        return FPE_FLTUND;
    }
    private static final int FPE_FLTRES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTRES 4
     * }
     */
    public static int FPE_FLTRES() {
        return FPE_FLTRES;
    }
    private static final int FPE_FLTINV = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTINV 5
     * }
     */
    public static int FPE_FLTINV() {
        return FPE_FLTINV;
    }
    private static final int FPE_FLTSUB = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FPE_FLTSUB 6
     * }
     */
    public static int FPE_FLTSUB() {
        return FPE_FLTSUB;
    }
    private static final int FPE_INTDIV = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FPE_INTDIV 7
     * }
     */
    public static int FPE_INTDIV() {
        return FPE_INTDIV;
    }
    private static final int FPE_INTOVF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FPE_INTOVF 8
     * }
     */
    public static int FPE_INTOVF() {
        return FPE_INTOVF;
    }
    private static final int SEGV_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEGV_NOOP 0
     * }
     */
    public static int SEGV_NOOP() {
        return SEGV_NOOP;
    }
    private static final int SEGV_MAPERR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEGV_MAPERR 1
     * }
     */
    public static int SEGV_MAPERR() {
        return SEGV_MAPERR;
    }
    private static final int SEGV_ACCERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEGV_ACCERR 2
     * }
     */
    public static int SEGV_ACCERR() {
        return SEGV_ACCERR;
    }
    private static final int BUS_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define BUS_NOOP 0
     * }
     */
    public static int BUS_NOOP() {
        return BUS_NOOP;
    }
    private static final int BUS_ADRALN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define BUS_ADRALN 1
     * }
     */
    public static int BUS_ADRALN() {
        return BUS_ADRALN;
    }
    private static final int BUS_ADRERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define BUS_ADRERR 2
     * }
     */
    public static int BUS_ADRERR() {
        return BUS_ADRERR;
    }
    private static final int BUS_OBJERR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define BUS_OBJERR 3
     * }
     */
    public static int BUS_OBJERR() {
        return BUS_OBJERR;
    }
    private static final int TRAP_BRKPT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TRAP_BRKPT 1
     * }
     */
    public static int TRAP_BRKPT() {
        return TRAP_BRKPT;
    }
    private static final int TRAP_TRACE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TRAP_TRACE 2
     * }
     */
    public static int TRAP_TRACE() {
        return TRAP_TRACE;
    }
    private static final int CLD_NOOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLD_NOOP 0
     * }
     */
    public static int CLD_NOOP() {
        return CLD_NOOP;
    }
    private static final int CLD_EXITED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLD_EXITED 1
     * }
     */
    public static int CLD_EXITED() {
        return CLD_EXITED;
    }
    private static final int CLD_KILLED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CLD_KILLED 2
     * }
     */
    public static int CLD_KILLED() {
        return CLD_KILLED;
    }
    private static final int CLD_DUMPED = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLD_DUMPED 3
     * }
     */
    public static int CLD_DUMPED() {
        return CLD_DUMPED;
    }
    private static final int CLD_TRAPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLD_TRAPPED 4
     * }
     */
    public static int CLD_TRAPPED() {
        return CLD_TRAPPED;
    }
    private static final int CLD_STOPPED = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLD_STOPPED 5
     * }
     */
    public static int CLD_STOPPED() {
        return CLD_STOPPED;
    }
    private static final int CLD_CONTINUED = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLD_CONTINUED 6
     * }
     */
    public static int CLD_CONTINUED() {
        return CLD_CONTINUED;
    }
    private static final int POLL_IN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define POLL_IN 1
     * }
     */
    public static int POLL_IN() {
        return POLL_IN;
    }
    private static final int POLL_OUT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define POLL_OUT 2
     * }
     */
    public static int POLL_OUT() {
        return POLL_OUT;
    }
    private static final int POLL_MSG = (int)3L;
    /**
     * {@snippet lang=c :
     * #define POLL_MSG 3
     * }
     */
    public static int POLL_MSG() {
        return POLL_MSG;
    }
    private static final int POLL_ERR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define POLL_ERR 4
     * }
     */
    public static int POLL_ERR() {
        return POLL_ERR;
    }
    private static final int POLL_PRI = (int)5L;
    /**
     * {@snippet lang=c :
     * #define POLL_PRI 5
     * }
     */
    public static int POLL_PRI() {
        return POLL_PRI;
    }
    private static final int POLL_HUP = (int)6L;
    /**
     * {@snippet lang=c :
     * #define POLL_HUP 6
     * }
     */
    public static int POLL_HUP() {
        return POLL_HUP;
    }
    private static final int SA_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SA_ONSTACK 1
     * }
     */
    public static int SA_ONSTACK() {
        return SA_ONSTACK;
    }
    private static final int SA_RESTART = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SA_RESTART 2
     * }
     */
    public static int SA_RESTART() {
        return SA_RESTART;
    }
    private static final int SA_RESETHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SA_RESETHAND 4
     * }
     */
    public static int SA_RESETHAND() {
        return SA_RESETHAND;
    }
    private static final int SA_NOCLDSTOP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SA_NOCLDSTOP 8
     * }
     */
    public static int SA_NOCLDSTOP() {
        return SA_NOCLDSTOP;
    }
    private static final int SA_NODEFER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SA_NODEFER 16
     * }
     */
    public static int SA_NODEFER() {
        return SA_NODEFER;
    }
    private static final int SA_NOCLDWAIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SA_NOCLDWAIT 32
     * }
     */
    public static int SA_NOCLDWAIT() {
        return SA_NOCLDWAIT;
    }
    private static final int SA_SIGINFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SA_SIGINFO 64
     * }
     */
    public static int SA_SIGINFO() {
        return SA_SIGINFO;
    }
    private static final int SA_USERTRAMP = (int)256L;
    /**
     * {@snippet lang=c :
     * #define SA_USERTRAMP 256
     * }
     */
    public static int SA_USERTRAMP() {
        return SA_USERTRAMP;
    }
    private static final int SA_64REGSET = (int)512L;
    /**
     * {@snippet lang=c :
     * #define SA_64REGSET 512
     * }
     */
    public static int SA_64REGSET() {
        return SA_64REGSET;
    }
    private static final int SIG_BLOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SIG_BLOCK 1
     * }
     */
    public static int SIG_BLOCK() {
        return SIG_BLOCK;
    }
    private static final int SIG_UNBLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SIG_UNBLOCK 2
     * }
     */
    public static int SIG_UNBLOCK() {
        return SIG_UNBLOCK;
    }
    private static final int SIG_SETMASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SIG_SETMASK 3
     * }
     */
    public static int SIG_SETMASK() {
        return SIG_SETMASK;
    }
    private static final int SI_USER = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define SI_USER 65537
     * }
     */
    public static int SI_USER() {
        return SI_USER;
    }
    private static final int SI_QUEUE = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define SI_QUEUE 65538
     * }
     */
    public static int SI_QUEUE() {
        return SI_QUEUE;
    }
    private static final int SI_TIMER = (int)65539L;
    /**
     * {@snippet lang=c :
     * #define SI_TIMER 65539
     * }
     */
    public static int SI_TIMER() {
        return SI_TIMER;
    }
    private static final int SI_ASYNCIO = (int)65540L;
    /**
     * {@snippet lang=c :
     * #define SI_ASYNCIO 65540
     * }
     */
    public static int SI_ASYNCIO() {
        return SI_ASYNCIO;
    }
    private static final int SI_MESGQ = (int)65541L;
    /**
     * {@snippet lang=c :
     * #define SI_MESGQ 65541
     * }
     */
    public static int SI_MESGQ() {
        return SI_MESGQ;
    }
    private static final int SS_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SS_ONSTACK 1
     * }
     */
    public static int SS_ONSTACK() {
        return SS_ONSTACK;
    }
    private static final int SS_DISABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SS_DISABLE 4
     * }
     */
    public static int SS_DISABLE() {
        return SS_DISABLE;
    }
    private static final int MINSIGSTKSZ = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MINSIGSTKSZ 32768
     * }
     */
    public static int MINSIGSTKSZ() {
        return MINSIGSTKSZ;
    }
    private static final int SIGSTKSZ = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define SIGSTKSZ 131072
     * }
     */
    public static int SIGSTKSZ() {
        return SIGSTKSZ;
    }
    private static final int PRIO_PROCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PRIO_PROCESS 0
     * }
     */
    public static int PRIO_PROCESS() {
        return PRIO_PROCESS;
    }
    private static final int PRIO_PGRP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PRIO_PGRP 1
     * }
     */
    public static int PRIO_PGRP() {
        return PRIO_PGRP;
    }
    private static final int PRIO_USER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PRIO_USER 2
     * }
     */
    public static int PRIO_USER() {
        return PRIO_USER;
    }
    private static final int PRIO_DARWIN_THREAD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_THREAD 3
     * }
     */
    public static int PRIO_DARWIN_THREAD() {
        return PRIO_DARWIN_THREAD;
    }
    private static final int PRIO_DARWIN_PROCESS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_PROCESS 4
     * }
     */
    public static int PRIO_DARWIN_PROCESS() {
        return PRIO_DARWIN_PROCESS;
    }
    private static final int PRIO_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PRIO_MAX 20
     * }
     */
    public static int PRIO_MAX() {
        return PRIO_MAX;
    }
    private static final int PRIO_DARWIN_BG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_BG 4096
     * }
     */
    public static int PRIO_DARWIN_BG() {
        return PRIO_DARWIN_BG;
    }
    private static final int PRIO_DARWIN_NONUI = (int)4097L;
    /**
     * {@snippet lang=c :
     * #define PRIO_DARWIN_NONUI 4097
     * }
     */
    public static int PRIO_DARWIN_NONUI() {
        return PRIO_DARWIN_NONUI;
    }
    private static final int RUSAGE_SELF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_SELF 0
     * }
     */
    public static int RUSAGE_SELF() {
        return RUSAGE_SELF;
    }
    private static final int RUSAGE_INFO_V0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V0 0
     * }
     */
    public static int RUSAGE_INFO_V0() {
        return RUSAGE_INFO_V0;
    }
    private static final int RUSAGE_INFO_V1 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V1 1
     * }
     */
    public static int RUSAGE_INFO_V1() {
        return RUSAGE_INFO_V1;
    }
    private static final int RUSAGE_INFO_V2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V2 2
     * }
     */
    public static int RUSAGE_INFO_V2() {
        return RUSAGE_INFO_V2;
    }
    private static final int RUSAGE_INFO_V3 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V3 3
     * }
     */
    public static int RUSAGE_INFO_V3() {
        return RUSAGE_INFO_V3;
    }
    private static final int RUSAGE_INFO_V4 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V4 4
     * }
     */
    public static int RUSAGE_INFO_V4() {
        return RUSAGE_INFO_V4;
    }
    private static final int RUSAGE_INFO_V5 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V5 5
     * }
     */
    public static int RUSAGE_INFO_V5() {
        return RUSAGE_INFO_V5;
    }
    private static final int RUSAGE_INFO_V6 = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_V6 6
     * }
     */
    public static int RUSAGE_INFO_V6() {
        return RUSAGE_INFO_V6;
    }
    private static final int RU_PROC_RUNS_RESLIDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RU_PROC_RUNS_RESLIDE 1
     * }
     */
    public static int RU_PROC_RUNS_RESLIDE() {
        return RU_PROC_RUNS_RESLIDE;
    }
    private static final int RLIMIT_CPU = (int)0L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CPU 0
     * }
     */
    public static int RLIMIT_CPU() {
        return RLIMIT_CPU;
    }
    private static final int RLIMIT_FSIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_FSIZE 1
     * }
     */
    public static int RLIMIT_FSIZE() {
        return RLIMIT_FSIZE;
    }
    private static final int RLIMIT_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_DATA 2
     * }
     */
    public static int RLIMIT_DATA() {
        return RLIMIT_DATA;
    }
    private static final int RLIMIT_STACK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_STACK 3
     * }
     */
    public static int RLIMIT_STACK() {
        return RLIMIT_STACK;
    }
    private static final int RLIMIT_CORE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CORE 4
     * }
     */
    public static int RLIMIT_CORE() {
        return RLIMIT_CORE;
    }
    private static final int RLIMIT_AS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_AS 5
     * }
     */
    public static int RLIMIT_AS() {
        return RLIMIT_AS;
    }
    private static final int RLIMIT_MEMLOCK = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_MEMLOCK 6
     * }
     */
    public static int RLIMIT_MEMLOCK() {
        return RLIMIT_MEMLOCK;
    }
    private static final int RLIMIT_NPROC = (int)7L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_NPROC 7
     * }
     */
    public static int RLIMIT_NPROC() {
        return RLIMIT_NPROC;
    }
    private static final int RLIMIT_NOFILE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_NOFILE 8
     * }
     */
    public static int RLIMIT_NOFILE() {
        return RLIMIT_NOFILE;
    }
    private static final int RLIM_NLIMITS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define RLIM_NLIMITS 9
     * }
     */
    public static int RLIM_NLIMITS() {
        return RLIM_NLIMITS;
    }
    private static final int _RLIMIT_POSIX_FLAG = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _RLIMIT_POSIX_FLAG 4096
     * }
     */
    public static int _RLIMIT_POSIX_FLAG() {
        return _RLIMIT_POSIX_FLAG;
    }
    private static final int RLIMIT_WAKEUPS_MONITOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_WAKEUPS_MONITOR 1
     * }
     */
    public static int RLIMIT_WAKEUPS_MONITOR() {
        return RLIMIT_WAKEUPS_MONITOR;
    }
    private static final int RLIMIT_CPU_USAGE_MONITOR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_CPU_USAGE_MONITOR 2
     * }
     */
    public static int RLIMIT_CPU_USAGE_MONITOR() {
        return RLIMIT_CPU_USAGE_MONITOR;
    }
    private static final int RLIMIT_THREAD_CPULIMITS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_THREAD_CPULIMITS 3
     * }
     */
    public static int RLIMIT_THREAD_CPULIMITS() {
        return RLIMIT_THREAD_CPULIMITS;
    }
    private static final int RLIMIT_FOOTPRINT_INTERVAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_FOOTPRINT_INTERVAL 4
     * }
     */
    public static int RLIMIT_FOOTPRINT_INTERVAL() {
        return RLIMIT_FOOTPRINT_INTERVAL;
    }
    private static final int WAKEMON_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_ENABLE 1
     * }
     */
    public static int WAKEMON_ENABLE() {
        return WAKEMON_ENABLE;
    }
    private static final int WAKEMON_DISABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_DISABLE 2
     * }
     */
    public static int WAKEMON_DISABLE() {
        return WAKEMON_DISABLE;
    }
    private static final int WAKEMON_GET_PARAMS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_GET_PARAMS 4
     * }
     */
    public static int WAKEMON_GET_PARAMS() {
        return WAKEMON_GET_PARAMS;
    }
    private static final int WAKEMON_SET_DEFAULTS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_SET_DEFAULTS 8
     * }
     */
    public static int WAKEMON_SET_DEFAULTS() {
        return WAKEMON_SET_DEFAULTS;
    }
    private static final int WAKEMON_MAKE_FATAL = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WAKEMON_MAKE_FATAL 16
     * }
     */
    public static int WAKEMON_MAKE_FATAL() {
        return WAKEMON_MAKE_FATAL;
    }
    private static final int CPUMON_MAKE_FATAL = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define CPUMON_MAKE_FATAL 4096
     * }
     */
    public static int CPUMON_MAKE_FATAL() {
        return CPUMON_MAKE_FATAL;
    }
    private static final int FOOTPRINT_INTERVAL_RESET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FOOTPRINT_INTERVAL_RESET 1
     * }
     */
    public static int FOOTPRINT_INTERVAL_RESET() {
        return FOOTPRINT_INTERVAL_RESET;
    }
    private static final int IOPOL_TYPE_DISK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_DISK 0
     * }
     */
    public static int IOPOL_TYPE_DISK() {
        return IOPOL_TYPE_DISK;
    }
    private static final int IOPOL_TYPE_VFS_ATIME_UPDATES = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_ATIME_UPDATES 2
     * }
     */
    public static int IOPOL_TYPE_VFS_ATIME_UPDATES() {
        return IOPOL_TYPE_VFS_ATIME_UPDATES;
    }
    private static final int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES 3
     * }
     */
    public static int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES() {
        return IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES;
    }
    private static final int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME 4
     * }
     */
    public static int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME() {
        return IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME;
    }
    private static final int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_TRIGGER_RESOLVE 5
     * }
     */
    public static int IOPOL_TYPE_VFS_TRIGGER_RESOLVE() {
        return IOPOL_TYPE_VFS_TRIGGER_RESOLVE;
    }
    private static final int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION 6
     * }
     */
    public static int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION() {
        return IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION;
    }
    private static final int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_IGNORE_PERMISSIONS 7
     * }
     */
    public static int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS() {
        return IOPOL_TYPE_VFS_IGNORE_PERMISSIONS;
    }
    private static final int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE 8
     * }
     */
    public static int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE() {
        return IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE;
    }
    private static final int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = (int)9L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES 9
     * }
     */
    public static int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES() {
        return IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES;
    }
    private static final int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY 10
     * }
     */
    public static int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY() {
        return IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY;
    }
    private static final int IOPOL_SCOPE_PROCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_PROCESS 0
     * }
     */
    public static int IOPOL_SCOPE_PROCESS() {
        return IOPOL_SCOPE_PROCESS;
    }
    private static final int IOPOL_SCOPE_THREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_THREAD 1
     * }
     */
    public static int IOPOL_SCOPE_THREAD() {
        return IOPOL_SCOPE_THREAD;
    }
    private static final int IOPOL_SCOPE_DARWIN_BG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_SCOPE_DARWIN_BG 2
     * }
     */
    public static int IOPOL_SCOPE_DARWIN_BG() {
        return IOPOL_SCOPE_DARWIN_BG;
    }
    private static final int IOPOL_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_DEFAULT 0
     * }
     */
    public static int IOPOL_DEFAULT() {
        return IOPOL_DEFAULT;
    }
    private static final int IOPOL_IMPORTANT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_IMPORTANT 1
     * }
     */
    public static int IOPOL_IMPORTANT() {
        return IOPOL_IMPORTANT;
    }
    private static final int IOPOL_PASSIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_PASSIVE 2
     * }
     */
    public static int IOPOL_PASSIVE() {
        return IOPOL_PASSIVE;
    }
    private static final int IOPOL_THROTTLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_THROTTLE 3
     * }
     */
    public static int IOPOL_THROTTLE() {
        return IOPOL_THROTTLE;
    }
    private static final int IOPOL_UTILITY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_UTILITY 4
     * }
     */
    public static int IOPOL_UTILITY() {
        return IOPOL_UTILITY;
    }
    private static final int IOPOL_STANDARD = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_STANDARD 5
     * }
     */
    public static int IOPOL_STANDARD() {
        return IOPOL_STANDARD;
    }
    private static final int IOPOL_ATIME_UPDATES_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_ATIME_UPDATES_DEFAULT 0
     * }
     */
    public static int IOPOL_ATIME_UPDATES_DEFAULT() {
        return IOPOL_ATIME_UPDATES_DEFAULT;
    }
    private static final int IOPOL_ATIME_UPDATES_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_ATIME_UPDATES_OFF 1
     * }
     */
    public static int IOPOL_ATIME_UPDATES_OFF() {
        return IOPOL_ATIME_UPDATES_OFF;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT 0
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_OFF 1
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_OFF() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_OFF;
    }
    private static final int IOPOL_MATERIALIZE_DATALESS_FILES_ON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_MATERIALIZE_DATALESS_FILES_ON 2
     * }
     */
    public static int IOPOL_MATERIALIZE_DATALESS_FILES_ON() {
        return IOPOL_MATERIALIZE_DATALESS_FILES_ON;
    }
    private static final int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT() {
        return IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT;
    }
    private static final int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME 1
     * }
     */
    public static int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME() {
        return IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME;
    }
    private static final int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT() {
        return IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT;
    }
    private static final int IOPOL_VFS_TRIGGER_RESOLVE_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_TRIGGER_RESOLVE_OFF 1
     * }
     */
    public static int IOPOL_VFS_TRIGGER_RESOLVE_OFF() {
        return IOPOL_VFS_TRIGGER_RESOLVE_OFF;
    }
    private static final int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_CONTENT_PROTECTION_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT() {
        return IOPOL_VFS_CONTENT_PROTECTION_DEFAULT;
    }
    private static final int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_CONTENT_PROTECTION_IGNORE 1
     * }
     */
    public static int IOPOL_VFS_CONTENT_PROTECTION_IGNORE() {
        return IOPOL_VFS_CONTENT_PROTECTION_IGNORE;
    }
    private static final int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_IGNORE_PERMISSIONS_OFF 0
     * }
     */
    public static int IOPOL_VFS_IGNORE_PERMISSIONS_OFF() {
        return IOPOL_VFS_IGNORE_PERMISSIONS_OFF;
    }
    private static final int IOPOL_VFS_IGNORE_PERMISSIONS_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_IGNORE_PERMISSIONS_ON 1
     * }
     */
    public static int IOPOL_VFS_IGNORE_PERMISSIONS_ON() {
        return IOPOL_VFS_IGNORE_PERMISSIONS_ON;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_OFF 0
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_OFF;
    }
    private static final int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_SKIP_MTIME_UPDATE_ON 1
     * }
     */
    public static int IOPOL_VFS_SKIP_MTIME_UPDATE_ON() {
        return IOPOL_VFS_SKIP_MTIME_UPDATE_ON;
    }
    private static final int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF 0
     * }
     */
    public static int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF() {
        return IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF;
    }
    private static final int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON 1
     * }
     */
    public static int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON() {
        return IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON;
    }
    private static final int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT() {
        return IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT;
    }
    private static final int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON 1
     * }
     */
    public static int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON() {
        return IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON;
    }
    private static final int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT 0
     * }
     */
    public static int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT() {
        return IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT;
    }
    private static final int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON 1
     * }
     */
    public static int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON() {
        return IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define WCOREFLAG 128
     * }
     */
    public static int WCOREFLAG() {
        return WCOREFLAG;
    }
    private static final int _WSTOPPED = (int)127L;
    /**
     * {@snippet lang=c :
     * #define _WSTOPPED 127
     * }
     */
    public static int _WSTOPPED() {
        return _WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WSTOPPED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 8
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WCONTINUED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 16
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 32
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int WAIT_MYPGRP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WAIT_MYPGRP 0
     * }
     */
    public static int WAIT_MYPGRP() {
        return WAIT_MYPGRP;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TRUE 1
     * }
     */
    public static int TRUE() {
        return TRUE;
    }
    private static final int FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FALSE 0
     * }
     */
    public static int FALSE() {
        return FALSE;
    }
    private static final int MACH_PORT_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_NULL 0
     * }
     */
    public static int MACH_PORT_NULL() {
        return MACH_PORT_NULL;
    }
    private static final int MACH_PORT_TYPE_SPREQUEST = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SPREQUEST 1073741824
     * }
     */
    public static int MACH_PORT_TYPE_SPREQUEST() {
        return MACH_PORT_TYPE_SPREQUEST;
    }
    private static final int MACH_PORT_TYPE_SPREQUEST_DELAYED = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TYPE_SPREQUEST_DELAYED 536870912
     * }
     */
    public static int MACH_PORT_TYPE_SPREQUEST_DELAYED() {
        return MACH_PORT_TYPE_SPREQUEST_DELAYED;
    }
    private static final int MACH_PORT_SRIGHTS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_SRIGHTS_NONE 0
     * }
     */
    public static int MACH_PORT_SRIGHTS_NONE() {
        return MACH_PORT_SRIGHTS_NONE;
    }
    private static final int MACH_PORT_SRIGHTS_PRESENT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_SRIGHTS_PRESENT 1
     * }
     */
    public static int MACH_PORT_SRIGHTS_PRESENT() {
        return MACH_PORT_SRIGHTS_PRESENT;
    }
    private static final int MACH_PORT_STATUS_FLAG_TEMPOWNER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_TEMPOWNER 1
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_TEMPOWNER() {
        return MACH_PORT_STATUS_FLAG_TEMPOWNER;
    }
    private static final int MACH_PORT_STATUS_FLAG_GUARDED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_GUARDED 2
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_GUARDED() {
        return MACH_PORT_STATUS_FLAG_GUARDED;
    }
    private static final int MACH_PORT_STATUS_FLAG_STRICT_GUARD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_STRICT_GUARD 4
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_STRICT_GUARD() {
        return MACH_PORT_STATUS_FLAG_STRICT_GUARD;
    }
    private static final int MACH_PORT_STATUS_FLAG_IMP_DONATION = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_IMP_DONATION 8
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_IMP_DONATION() {
        return MACH_PORT_STATUS_FLAG_IMP_DONATION;
    }
    private static final int MACH_PORT_STATUS_FLAG_REVIVE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_REVIVE 16
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_REVIVE() {
        return MACH_PORT_STATUS_FLAG_REVIVE;
    }
    private static final int MACH_PORT_STATUS_FLAG_TASKPTR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_TASKPTR 32
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_TASKPTR() {
        return MACH_PORT_STATUS_FLAG_TASKPTR;
    }
    private static final int MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE 64
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE() {
        return MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE;
    }
    private static final int MACH_PORT_STATUS_FLAG_NO_GRANT = (int)128L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_STATUS_FLAG_NO_GRANT 128
     * }
     */
    public static int MACH_PORT_STATUS_FLAG_NO_GRANT() {
        return MACH_PORT_STATUS_FLAG_NO_GRANT;
    }
    private static final int MACH_PORT_LIMITS_INFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_LIMITS_INFO 1
     * }
     */
    public static int MACH_PORT_LIMITS_INFO() {
        return MACH_PORT_LIMITS_INFO;
    }
    private static final int MACH_PORT_RECEIVE_STATUS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_RECEIVE_STATUS 2
     * }
     */
    public static int MACH_PORT_RECEIVE_STATUS() {
        return MACH_PORT_RECEIVE_STATUS;
    }
    private static final int MACH_PORT_DNREQUESTS_SIZE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_DNREQUESTS_SIZE 3
     * }
     */
    public static int MACH_PORT_DNREQUESTS_SIZE() {
        return MACH_PORT_DNREQUESTS_SIZE;
    }
    private static final int MACH_PORT_TEMPOWNER = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_TEMPOWNER 4
     * }
     */
    public static int MACH_PORT_TEMPOWNER() {
        return MACH_PORT_TEMPOWNER;
    }
    private static final int MACH_PORT_IMPORTANCE_RECEIVER = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_IMPORTANCE_RECEIVER 5
     * }
     */
    public static int MACH_PORT_IMPORTANCE_RECEIVER() {
        return MACH_PORT_IMPORTANCE_RECEIVER;
    }
    private static final int MACH_PORT_DENAP_RECEIVER = (int)6L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_DENAP_RECEIVER 6
     * }
     */
    public static int MACH_PORT_DENAP_RECEIVER() {
        return MACH_PORT_DENAP_RECEIVER;
    }
    private static final int MACH_PORT_INFO_EXT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_INFO_EXT 7
     * }
     */
    public static int MACH_PORT_INFO_EXT() {
        return MACH_PORT_INFO_EXT;
    }
    private static final int MACH_PORT_GUARD_INFO = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_GUARD_INFO 8
     * }
     */
    public static int MACH_PORT_GUARD_INFO() {
        return MACH_PORT_GUARD_INFO;
    }
    private static final int MACH_PORT_SERVICE_THROTTLED = (int)9L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_SERVICE_THROTTLED 9
     * }
     */
    public static int MACH_PORT_SERVICE_THROTTLED() {
        return MACH_PORT_SERVICE_THROTTLED;
    }
    private static final int MACH_PORT_DNREQUESTS_SIZE_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_DNREQUESTS_SIZE_COUNT 1
     * }
     */
    public static int MACH_PORT_DNREQUESTS_SIZE_COUNT() {
        return MACH_PORT_DNREQUESTS_SIZE_COUNT;
    }
    private static final int MACH_PORT_SERVICE_THROTTLED_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_PORT_SERVICE_THROTTLED_COUNT 1
     * }
     */
    public static int MACH_PORT_SERVICE_THROTTLED_COUNT() {
        return MACH_PORT_SERVICE_THROTTLED_COUNT;
    }
    private static final int MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN 255
     * }
     */
    public static int MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN() {
        return MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN;
    }
    private static final int MPO_CONTEXT_AS_GUARD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MPO_CONTEXT_AS_GUARD 1
     * }
     */
    public static int MPO_CONTEXT_AS_GUARD() {
        return MPO_CONTEXT_AS_GUARD;
    }
    private static final int MPO_QLIMIT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MPO_QLIMIT 2
     * }
     */
    public static int MPO_QLIMIT() {
        return MPO_QLIMIT;
    }
    private static final int MPO_TEMPOWNER = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MPO_TEMPOWNER 4
     * }
     */
    public static int MPO_TEMPOWNER() {
        return MPO_TEMPOWNER;
    }
    private static final int MPO_IMPORTANCE_RECEIVER = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MPO_IMPORTANCE_RECEIVER 8
     * }
     */
    public static int MPO_IMPORTANCE_RECEIVER() {
        return MPO_IMPORTANCE_RECEIVER;
    }
    private static final int MPO_INSERT_SEND_RIGHT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MPO_INSERT_SEND_RIGHT 16
     * }
     */
    public static int MPO_INSERT_SEND_RIGHT() {
        return MPO_INSERT_SEND_RIGHT;
    }
    private static final int MPO_STRICT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define MPO_STRICT 32
     * }
     */
    public static int MPO_STRICT() {
        return MPO_STRICT;
    }
    private static final int MPO_DENAP_RECEIVER = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MPO_DENAP_RECEIVER 64
     * }
     */
    public static int MPO_DENAP_RECEIVER() {
        return MPO_DENAP_RECEIVER;
    }
    private static final int MPO_IMMOVABLE_RECEIVE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define MPO_IMMOVABLE_RECEIVE 128
     * }
     */
    public static int MPO_IMMOVABLE_RECEIVE() {
        return MPO_IMMOVABLE_RECEIVE;
    }
    private static final int MPO_FILTER_MSG = (int)256L;
    /**
     * {@snippet lang=c :
     * #define MPO_FILTER_MSG 256
     * }
     */
    public static int MPO_FILTER_MSG() {
        return MPO_FILTER_MSG;
    }
    private static final int MPO_TG_BLOCK_TRACKING = (int)512L;
    /**
     * {@snippet lang=c :
     * #define MPO_TG_BLOCK_TRACKING 512
     * }
     */
    public static int MPO_TG_BLOCK_TRACKING() {
        return MPO_TG_BLOCK_TRACKING;
    }
    private static final int MPO_SERVICE_PORT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MPO_SERVICE_PORT 1024
     * }
     */
    public static int MPO_SERVICE_PORT() {
        return MPO_SERVICE_PORT;
    }
    private static final int MPO_CONNECTION_PORT = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define MPO_CONNECTION_PORT 2048
     * }
     */
    public static int MPO_CONNECTION_PORT() {
        return MPO_CONNECTION_PORT;
    }
    private static final int MPO_REPLY_PORT = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define MPO_REPLY_PORT 4096
     * }
     */
    public static int MPO_REPLY_PORT() {
        return MPO_REPLY_PORT;
    }
    private static final int MPO_ENFORCE_REPLY_PORT_SEMANTICS = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define MPO_ENFORCE_REPLY_PORT_SEMANTICS 8192
     * }
     */
    public static int MPO_ENFORCE_REPLY_PORT_SEMANTICS() {
        return MPO_ENFORCE_REPLY_PORT_SEMANTICS;
    }
    private static final int MPO_PROVISIONAL_REPLY_PORT = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define MPO_PROVISIONAL_REPLY_PORT 16384
     * }
     */
    public static int MPO_PROVISIONAL_REPLY_PORT() {
        return MPO_PROVISIONAL_REPLY_PORT;
    }
    private static final int MPO_PROVISIONAL_ID_PROT_OPTOUT = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MPO_PROVISIONAL_ID_PROT_OPTOUT 32768
     * }
     */
    public static int MPO_PROVISIONAL_ID_PROT_OPTOUT() {
        return MPO_PROVISIONAL_ID_PROT_OPTOUT;
    }
    private static final int GUARD_TYPE_MACH_PORT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GUARD_TYPE_MACH_PORT 1
     * }
     */
    public static int GUARD_TYPE_MACH_PORT() {
        return GUARD_TYPE_MACH_PORT;
    }
    private static final int MPG_STRICT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MPG_STRICT 1
     * }
     */
    public static int MPG_STRICT() {
        return MPG_STRICT;
    }
    private static final int MPG_IMMOVABLE_RECEIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MPG_IMMOVABLE_RECEIVE 2
     * }
     */
    public static int MPG_IMMOVABLE_RECEIVE() {
        return MPG_IMMOVABLE_RECEIVE;
    }
    private static final int __OS_WORKGROUP_ATTR_SIZE__ = (int)60L;
    /**
     * {@snippet lang=c :
     * #define __OS_WORKGROUP_ATTR_SIZE__ 60
     * }
     */
    public static int __OS_WORKGROUP_ATTR_SIZE__() {
        return __OS_WORKGROUP_ATTR_SIZE__;
    }
    private static final int __OS_WORKGROUP_INTERVAL_DATA_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __OS_WORKGROUP_INTERVAL_DATA_SIZE__ 56
     * }
     */
    public static int __OS_WORKGROUP_INTERVAL_DATA_SIZE__() {
        return __OS_WORKGROUP_INTERVAL_DATA_SIZE__;
    }
    private static final int __OS_WORKGROUP_JOIN_TOKEN_SIZE__ = (int)36L;
    /**
     * {@snippet lang=c :
     * #define __OS_WORKGROUP_JOIN_TOKEN_SIZE__ 36
     * }
     */
    public static int __OS_WORKGROUP_JOIN_TOKEN_SIZE__() {
        return __OS_WORKGROUP_JOIN_TOKEN_SIZE__;
    }
    private static final int _OS_WORKGROUP_ATTR_SIG_DEFAULT_INIT = (int)799564724L;
    /**
     * {@snippet lang=c :
     * #define _OS_WORKGROUP_ATTR_SIG_DEFAULT_INIT 799564724
     * }
     */
    public static int _OS_WORKGROUP_ATTR_SIG_DEFAULT_INIT() {
        return _OS_WORKGROUP_ATTR_SIG_DEFAULT_INIT;
    }
    private static final int _OS_WORKGROUP_ATTR_SIG_EMPTY_INIT = (int)799564740L;
    /**
     * {@snippet lang=c :
     * #define _OS_WORKGROUP_ATTR_SIG_EMPTY_INIT 799564740
     * }
     */
    public static int _OS_WORKGROUP_ATTR_SIG_EMPTY_INIT() {
        return _OS_WORKGROUP_ATTR_SIG_EMPTY_INIT;
    }
    private static final int _OS_WORKGROUP_INTERVAL_DATA_SIG_INIT = (int)1386695757L;
    /**
     * {@snippet lang=c :
     * #define _OS_WORKGROUP_INTERVAL_DATA_SIG_INIT 1386695757
     * }
     */
    public static int _OS_WORKGROUP_INTERVAL_DATA_SIG_INIT() {
        return _OS_WORKGROUP_INTERVAL_DATA_SIG_INIT;
    }
    private static final int DISPATCH_SWIFT3_OVERLAY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_SWIFT3_OVERLAY 0
     * }
     */
    public static int DISPATCH_SWIFT3_OVERLAY() {
        return DISPATCH_SWIFT3_OVERLAY;
    }
    private static final int SYSTEM_CLOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SYSTEM_CLOCK 0
     * }
     */
    public static int SYSTEM_CLOCK() {
        return SYSTEM_CLOCK;
    }
    private static final int CALENDAR_CLOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CALENDAR_CLOCK 1
     * }
     */
    public static int CALENDAR_CLOCK() {
        return CALENDAR_CLOCK;
    }
    private static final int REALTIME_CLOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define REALTIME_CLOCK 0
     * }
     */
    public static int REALTIME_CLOCK() {
        return REALTIME_CLOCK;
    }
    private static final int CLOCK_GET_TIME_RES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_GET_TIME_RES 1
     * }
     */
    public static int CLOCK_GET_TIME_RES() {
        return CLOCK_GET_TIME_RES;
    }
    private static final int CLOCK_ALARM_CURRES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_ALARM_CURRES 3
     * }
     */
    public static int CLOCK_ALARM_CURRES() {
        return CLOCK_ALARM_CURRES;
    }
    private static final int CLOCK_ALARM_MINRES = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_ALARM_MINRES 4
     * }
     */
    public static int CLOCK_ALARM_MINRES() {
        return CLOCK_ALARM_MINRES;
    }
    private static final int CLOCK_ALARM_MAXRES = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_ALARM_MAXRES 5
     * }
     */
    public static int CLOCK_ALARM_MAXRES() {
        return CLOCK_ALARM_MAXRES;
    }
    private static final int ALRMTYPE = (int)255L;
    /**
     * {@snippet lang=c :
     * #define ALRMTYPE 255
     * }
     */
    public static int ALRMTYPE() {
        return ALRMTYPE;
    }
    private static final int TIME_ABSOLUTE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define TIME_ABSOLUTE 0
     * }
     */
    public static int TIME_ABSOLUTE() {
        return TIME_ABSOLUTE;
    }
    private static final int TIME_RELATIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_RELATIVE 1
     * }
     */
    public static int TIME_RELATIVE() {
        return TIME_RELATIVE;
    }
    private static final int DISPATCH_APPLY_AUTO_AVAILABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_APPLY_AUTO_AVAILABLE 0
     * }
     */
    public static int DISPATCH_APPLY_AUTO_AVAILABLE() {
        return DISPATCH_APPLY_AUTO_AVAILABLE;
    }
    private static final int DISPATCH_QUEUE_PRIORITY_HIGH = (int)2L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_QUEUE_PRIORITY_HIGH 2
     * }
     */
    public static int DISPATCH_QUEUE_PRIORITY_HIGH() {
        return DISPATCH_QUEUE_PRIORITY_HIGH;
    }
    private static final int DISPATCH_QUEUE_PRIORITY_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_QUEUE_PRIORITY_DEFAULT 0
     * }
     */
    public static int DISPATCH_QUEUE_PRIORITY_DEFAULT() {
        return DISPATCH_QUEUE_PRIORITY_DEFAULT;
    }
    private static final int __DARWIN_CLK_TCK = (int)100L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_CLK_TCK 100
     * }
     */
    public static int __DARWIN_CLK_TCK() {
        return __DARWIN_CLK_TCK;
    }
    private static final int MB_LEN_MAX = (int)6L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 6
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final int LONG_BIT = (int)64L;
    /**
     * {@snippet lang=c :
     * #define LONG_BIT 64
     * }
     */
    public static int LONG_BIT() {
        return LONG_BIT;
    }
    private static final int WORD_BIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define WORD_BIT 32
     * }
     */
    public static int WORD_BIT() {
        return WORD_BIT;
    }
    private static final int KERN_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define KERN_SUCCESS 0
     * }
     */
    public static int KERN_SUCCESS() {
        return KERN_SUCCESS;
    }
    private static final int KERN_INVALID_ADDRESS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_ADDRESS 1
     * }
     */
    public static int KERN_INVALID_ADDRESS() {
        return KERN_INVALID_ADDRESS;
    }
    private static final int KERN_PROTECTION_FAILURE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define KERN_PROTECTION_FAILURE 2
     * }
     */
    public static int KERN_PROTECTION_FAILURE() {
        return KERN_PROTECTION_FAILURE;
    }
    private static final int KERN_NO_SPACE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define KERN_NO_SPACE 3
     * }
     */
    public static int KERN_NO_SPACE() {
        return KERN_NO_SPACE;
    }
    private static final int KERN_INVALID_ARGUMENT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_ARGUMENT 4
     * }
     */
    public static int KERN_INVALID_ARGUMENT() {
        return KERN_INVALID_ARGUMENT;
    }
    private static final int KERN_FAILURE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define KERN_FAILURE 5
     * }
     */
    public static int KERN_FAILURE() {
        return KERN_FAILURE;
    }
    private static final int KERN_RESOURCE_SHORTAGE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define KERN_RESOURCE_SHORTAGE 6
     * }
     */
    public static int KERN_RESOURCE_SHORTAGE() {
        return KERN_RESOURCE_SHORTAGE;
    }
    private static final int KERN_NOT_RECEIVER = (int)7L;
    /**
     * {@snippet lang=c :
     * #define KERN_NOT_RECEIVER 7
     * }
     */
    public static int KERN_NOT_RECEIVER() {
        return KERN_NOT_RECEIVER;
    }
    private static final int KERN_NO_ACCESS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define KERN_NO_ACCESS 8
     * }
     */
    public static int KERN_NO_ACCESS() {
        return KERN_NO_ACCESS;
    }
    private static final int KERN_MEMORY_FAILURE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define KERN_MEMORY_FAILURE 9
     * }
     */
    public static int KERN_MEMORY_FAILURE() {
        return KERN_MEMORY_FAILURE;
    }
    private static final int KERN_MEMORY_ERROR = (int)10L;
    /**
     * {@snippet lang=c :
     * #define KERN_MEMORY_ERROR 10
     * }
     */
    public static int KERN_MEMORY_ERROR() {
        return KERN_MEMORY_ERROR;
    }
    private static final int KERN_ALREADY_IN_SET = (int)11L;
    /**
     * {@snippet lang=c :
     * #define KERN_ALREADY_IN_SET 11
     * }
     */
    public static int KERN_ALREADY_IN_SET() {
        return KERN_ALREADY_IN_SET;
    }
    private static final int KERN_NOT_IN_SET = (int)12L;
    /**
     * {@snippet lang=c :
     * #define KERN_NOT_IN_SET 12
     * }
     */
    public static int KERN_NOT_IN_SET() {
        return KERN_NOT_IN_SET;
    }
    private static final int KERN_NAME_EXISTS = (int)13L;
    /**
     * {@snippet lang=c :
     * #define KERN_NAME_EXISTS 13
     * }
     */
    public static int KERN_NAME_EXISTS() {
        return KERN_NAME_EXISTS;
    }
    private static final int KERN_ABORTED = (int)14L;
    /**
     * {@snippet lang=c :
     * #define KERN_ABORTED 14
     * }
     */
    public static int KERN_ABORTED() {
        return KERN_ABORTED;
    }
    private static final int KERN_INVALID_NAME = (int)15L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_NAME 15
     * }
     */
    public static int KERN_INVALID_NAME() {
        return KERN_INVALID_NAME;
    }
    private static final int KERN_INVALID_TASK = (int)16L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_TASK 16
     * }
     */
    public static int KERN_INVALID_TASK() {
        return KERN_INVALID_TASK;
    }
    private static final int KERN_INVALID_RIGHT = (int)17L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_RIGHT 17
     * }
     */
    public static int KERN_INVALID_RIGHT() {
        return KERN_INVALID_RIGHT;
    }
    private static final int KERN_INVALID_VALUE = (int)18L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_VALUE 18
     * }
     */
    public static int KERN_INVALID_VALUE() {
        return KERN_INVALID_VALUE;
    }
    private static final int KERN_UREFS_OVERFLOW = (int)19L;
    /**
     * {@snippet lang=c :
     * #define KERN_UREFS_OVERFLOW 19
     * }
     */
    public static int KERN_UREFS_OVERFLOW() {
        return KERN_UREFS_OVERFLOW;
    }
    private static final int KERN_INVALID_CAPABILITY = (int)20L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_CAPABILITY 20
     * }
     */
    public static int KERN_INVALID_CAPABILITY() {
        return KERN_INVALID_CAPABILITY;
    }
    private static final int KERN_RIGHT_EXISTS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define KERN_RIGHT_EXISTS 21
     * }
     */
    public static int KERN_RIGHT_EXISTS() {
        return KERN_RIGHT_EXISTS;
    }
    private static final int KERN_INVALID_HOST = (int)22L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_HOST 22
     * }
     */
    public static int KERN_INVALID_HOST() {
        return KERN_INVALID_HOST;
    }
    private static final int KERN_MEMORY_PRESENT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define KERN_MEMORY_PRESENT 23
     * }
     */
    public static int KERN_MEMORY_PRESENT() {
        return KERN_MEMORY_PRESENT;
    }
    private static final int KERN_MEMORY_DATA_MOVED = (int)24L;
    /**
     * {@snippet lang=c :
     * #define KERN_MEMORY_DATA_MOVED 24
     * }
     */
    public static int KERN_MEMORY_DATA_MOVED() {
        return KERN_MEMORY_DATA_MOVED;
    }
    private static final int KERN_MEMORY_RESTART_COPY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define KERN_MEMORY_RESTART_COPY 25
     * }
     */
    public static int KERN_MEMORY_RESTART_COPY() {
        return KERN_MEMORY_RESTART_COPY;
    }
    private static final int KERN_INVALID_PROCESSOR_SET = (int)26L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_PROCESSOR_SET 26
     * }
     */
    public static int KERN_INVALID_PROCESSOR_SET() {
        return KERN_INVALID_PROCESSOR_SET;
    }
    private static final int KERN_POLICY_LIMIT = (int)27L;
    /**
     * {@snippet lang=c :
     * #define KERN_POLICY_LIMIT 27
     * }
     */
    public static int KERN_POLICY_LIMIT() {
        return KERN_POLICY_LIMIT;
    }
    private static final int KERN_INVALID_POLICY = (int)28L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_POLICY 28
     * }
     */
    public static int KERN_INVALID_POLICY() {
        return KERN_INVALID_POLICY;
    }
    private static final int KERN_INVALID_OBJECT = (int)29L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_OBJECT 29
     * }
     */
    public static int KERN_INVALID_OBJECT() {
        return KERN_INVALID_OBJECT;
    }
    private static final int KERN_ALREADY_WAITING = (int)30L;
    /**
     * {@snippet lang=c :
     * #define KERN_ALREADY_WAITING 30
     * }
     */
    public static int KERN_ALREADY_WAITING() {
        return KERN_ALREADY_WAITING;
    }
    private static final int KERN_DEFAULT_SET = (int)31L;
    /**
     * {@snippet lang=c :
     * #define KERN_DEFAULT_SET 31
     * }
     */
    public static int KERN_DEFAULT_SET() {
        return KERN_DEFAULT_SET;
    }
    private static final int KERN_EXCEPTION_PROTECTED = (int)32L;
    /**
     * {@snippet lang=c :
     * #define KERN_EXCEPTION_PROTECTED 32
     * }
     */
    public static int KERN_EXCEPTION_PROTECTED() {
        return KERN_EXCEPTION_PROTECTED;
    }
    private static final int KERN_INVALID_LEDGER = (int)33L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_LEDGER 33
     * }
     */
    public static int KERN_INVALID_LEDGER() {
        return KERN_INVALID_LEDGER;
    }
    private static final int KERN_INVALID_MEMORY_CONTROL = (int)34L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_MEMORY_CONTROL 34
     * }
     */
    public static int KERN_INVALID_MEMORY_CONTROL() {
        return KERN_INVALID_MEMORY_CONTROL;
    }
    private static final int KERN_INVALID_SECURITY = (int)35L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_SECURITY 35
     * }
     */
    public static int KERN_INVALID_SECURITY() {
        return KERN_INVALID_SECURITY;
    }
    private static final int KERN_NOT_DEPRESSED = (int)36L;
    /**
     * {@snippet lang=c :
     * #define KERN_NOT_DEPRESSED 36
     * }
     */
    public static int KERN_NOT_DEPRESSED() {
        return KERN_NOT_DEPRESSED;
    }
    private static final int KERN_TERMINATED = (int)37L;
    /**
     * {@snippet lang=c :
     * #define KERN_TERMINATED 37
     * }
     */
    public static int KERN_TERMINATED() {
        return KERN_TERMINATED;
    }
    private static final int KERN_LOCK_SET_DESTROYED = (int)38L;
    /**
     * {@snippet lang=c :
     * #define KERN_LOCK_SET_DESTROYED 38
     * }
     */
    public static int KERN_LOCK_SET_DESTROYED() {
        return KERN_LOCK_SET_DESTROYED;
    }
    private static final int KERN_LOCK_UNSTABLE = (int)39L;
    /**
     * {@snippet lang=c :
     * #define KERN_LOCK_UNSTABLE 39
     * }
     */
    public static int KERN_LOCK_UNSTABLE() {
        return KERN_LOCK_UNSTABLE;
    }
    private static final int KERN_LOCK_OWNED = (int)40L;
    /**
     * {@snippet lang=c :
     * #define KERN_LOCK_OWNED 40
     * }
     */
    public static int KERN_LOCK_OWNED() {
        return KERN_LOCK_OWNED;
    }
    private static final int KERN_LOCK_OWNED_SELF = (int)41L;
    /**
     * {@snippet lang=c :
     * #define KERN_LOCK_OWNED_SELF 41
     * }
     */
    public static int KERN_LOCK_OWNED_SELF() {
        return KERN_LOCK_OWNED_SELF;
    }
    private static final int KERN_SEMAPHORE_DESTROYED = (int)42L;
    /**
     * {@snippet lang=c :
     * #define KERN_SEMAPHORE_DESTROYED 42
     * }
     */
    public static int KERN_SEMAPHORE_DESTROYED() {
        return KERN_SEMAPHORE_DESTROYED;
    }
    private static final int KERN_RPC_SERVER_TERMINATED = (int)43L;
    /**
     * {@snippet lang=c :
     * #define KERN_RPC_SERVER_TERMINATED 43
     * }
     */
    public static int KERN_RPC_SERVER_TERMINATED() {
        return KERN_RPC_SERVER_TERMINATED;
    }
    private static final int KERN_RPC_TERMINATE_ORPHAN = (int)44L;
    /**
     * {@snippet lang=c :
     * #define KERN_RPC_TERMINATE_ORPHAN 44
     * }
     */
    public static int KERN_RPC_TERMINATE_ORPHAN() {
        return KERN_RPC_TERMINATE_ORPHAN;
    }
    private static final int KERN_RPC_CONTINUE_ORPHAN = (int)45L;
    /**
     * {@snippet lang=c :
     * #define KERN_RPC_CONTINUE_ORPHAN 45
     * }
     */
    public static int KERN_RPC_CONTINUE_ORPHAN() {
        return KERN_RPC_CONTINUE_ORPHAN;
    }
    private static final int KERN_NOT_SUPPORTED = (int)46L;
    /**
     * {@snippet lang=c :
     * #define KERN_NOT_SUPPORTED 46
     * }
     */
    public static int KERN_NOT_SUPPORTED() {
        return KERN_NOT_SUPPORTED;
    }
    private static final int KERN_NODE_DOWN = (int)47L;
    /**
     * {@snippet lang=c :
     * #define KERN_NODE_DOWN 47
     * }
     */
    public static int KERN_NODE_DOWN() {
        return KERN_NODE_DOWN;
    }
    private static final int KERN_NOT_WAITING = (int)48L;
    /**
     * {@snippet lang=c :
     * #define KERN_NOT_WAITING 48
     * }
     */
    public static int KERN_NOT_WAITING() {
        return KERN_NOT_WAITING;
    }
    private static final int KERN_OPERATION_TIMED_OUT = (int)49L;
    /**
     * {@snippet lang=c :
     * #define KERN_OPERATION_TIMED_OUT 49
     * }
     */
    public static int KERN_OPERATION_TIMED_OUT() {
        return KERN_OPERATION_TIMED_OUT;
    }
    private static final int KERN_CODESIGN_ERROR = (int)50L;
    /**
     * {@snippet lang=c :
     * #define KERN_CODESIGN_ERROR 50
     * }
     */
    public static int KERN_CODESIGN_ERROR() {
        return KERN_CODESIGN_ERROR;
    }
    private static final int KERN_POLICY_STATIC = (int)51L;
    /**
     * {@snippet lang=c :
     * #define KERN_POLICY_STATIC 51
     * }
     */
    public static int KERN_POLICY_STATIC() {
        return KERN_POLICY_STATIC;
    }
    private static final int KERN_INSUFFICIENT_BUFFER_SIZE = (int)52L;
    /**
     * {@snippet lang=c :
     * #define KERN_INSUFFICIENT_BUFFER_SIZE 52
     * }
     */
    public static int KERN_INSUFFICIENT_BUFFER_SIZE() {
        return KERN_INSUFFICIENT_BUFFER_SIZE;
    }
    private static final int KERN_DENIED = (int)53L;
    /**
     * {@snippet lang=c :
     * #define KERN_DENIED 53
     * }
     */
    public static int KERN_DENIED() {
        return KERN_DENIED;
    }
    private static final int KERN_MISSING_KC = (int)54L;
    /**
     * {@snippet lang=c :
     * #define KERN_MISSING_KC 54
     * }
     */
    public static int KERN_MISSING_KC() {
        return KERN_MISSING_KC;
    }
    private static final int KERN_INVALID_KC = (int)55L;
    /**
     * {@snippet lang=c :
     * #define KERN_INVALID_KC 55
     * }
     */
    public static int KERN_INVALID_KC() {
        return KERN_INVALID_KC;
    }
    private static final int KERN_NOT_FOUND = (int)56L;
    /**
     * {@snippet lang=c :
     * #define KERN_NOT_FOUND 56
     * }
     */
    public static int KERN_NOT_FOUND() {
        return KERN_NOT_FOUND;
    }
    private static final int KERN_RETURN_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define KERN_RETURN_MAX 256
     * }
     */
    public static int KERN_RETURN_MAX() {
        return KERN_RETURN_MAX;
    }
    private static final int MACH_MSGH_BITS_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_ZERO 0
     * }
     */
    public static int MACH_MSGH_BITS_ZERO() {
        return MACH_MSGH_BITS_ZERO;
    }
    private static final int MACH_MSGH_BITS_REMOTE_MASK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_REMOTE_MASK 31
     * }
     */
    public static int MACH_MSGH_BITS_REMOTE_MASK() {
        return MACH_MSGH_BITS_REMOTE_MASK;
    }
    private static final int MACH_MSGH_BITS_LOCAL_MASK = (int)7936L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_LOCAL_MASK 7936
     * }
     */
    public static int MACH_MSGH_BITS_LOCAL_MASK() {
        return MACH_MSGH_BITS_LOCAL_MASK;
    }
    private static final int MACH_MSGH_BITS_VOUCHER_MASK = (int)2031616L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_BITS_VOUCHER_MASK 2031616
     * }
     */
    public static int MACH_MSGH_BITS_VOUCHER_MASK() {
        return MACH_MSGH_BITS_VOUCHER_MASK;
    }
    private static final int MACH_MSG_TYPE_MOVE_RECEIVE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_MOVE_RECEIVE 16
     * }
     */
    public static int MACH_MSG_TYPE_MOVE_RECEIVE() {
        return MACH_MSG_TYPE_MOVE_RECEIVE;
    }
    private static final int MACH_MSG_TYPE_MOVE_SEND = (int)17L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_MOVE_SEND 17
     * }
     */
    public static int MACH_MSG_TYPE_MOVE_SEND() {
        return MACH_MSG_TYPE_MOVE_SEND;
    }
    private static final int MACH_MSG_TYPE_MOVE_SEND_ONCE = (int)18L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_MOVE_SEND_ONCE 18
     * }
     */
    public static int MACH_MSG_TYPE_MOVE_SEND_ONCE() {
        return MACH_MSG_TYPE_MOVE_SEND_ONCE;
    }
    private static final int MACH_MSG_TYPE_COPY_SEND = (int)19L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_COPY_SEND 19
     * }
     */
    public static int MACH_MSG_TYPE_COPY_SEND() {
        return MACH_MSG_TYPE_COPY_SEND;
    }
    private static final int MACH_MSG_TYPE_MAKE_SEND = (int)20L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_MAKE_SEND 20
     * }
     */
    public static int MACH_MSG_TYPE_MAKE_SEND() {
        return MACH_MSG_TYPE_MAKE_SEND;
    }
    private static final int MACH_MSG_TYPE_MAKE_SEND_ONCE = (int)21L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_MAKE_SEND_ONCE 21
     * }
     */
    public static int MACH_MSG_TYPE_MAKE_SEND_ONCE() {
        return MACH_MSG_TYPE_MAKE_SEND_ONCE;
    }
    private static final int MACH_MSG_TYPE_COPY_RECEIVE = (int)22L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_COPY_RECEIVE 22
     * }
     */
    public static int MACH_MSG_TYPE_COPY_RECEIVE() {
        return MACH_MSG_TYPE_COPY_RECEIVE;
    }
    private static final int MACH_MSG_TYPE_DISPOSE_RECEIVE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_DISPOSE_RECEIVE 24
     * }
     */
    public static int MACH_MSG_TYPE_DISPOSE_RECEIVE() {
        return MACH_MSG_TYPE_DISPOSE_RECEIVE;
    }
    private static final int MACH_MSG_TYPE_DISPOSE_SEND = (int)25L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_DISPOSE_SEND 25
     * }
     */
    public static int MACH_MSG_TYPE_DISPOSE_SEND() {
        return MACH_MSG_TYPE_DISPOSE_SEND;
    }
    private static final int MACH_MSG_TYPE_DISPOSE_SEND_ONCE = (int)26L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_DISPOSE_SEND_ONCE 26
     * }
     */
    public static int MACH_MSG_TYPE_DISPOSE_SEND_ONCE() {
        return MACH_MSG_TYPE_DISPOSE_SEND_ONCE;
    }
    private static final int MACH_MSG_PHYSICAL_COPY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_PHYSICAL_COPY 0
     * }
     */
    public static int MACH_MSG_PHYSICAL_COPY() {
        return MACH_MSG_PHYSICAL_COPY;
    }
    private static final int MACH_MSG_VIRTUAL_COPY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_VIRTUAL_COPY 1
     * }
     */
    public static int MACH_MSG_VIRTUAL_COPY() {
        return MACH_MSG_VIRTUAL_COPY;
    }
    private static final int MACH_MSG_ALLOCATE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_ALLOCATE 2
     * }
     */
    public static int MACH_MSG_ALLOCATE() {
        return MACH_MSG_ALLOCATE;
    }
    private static final int MACH_MSG_OVERWRITE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_OVERWRITE 3
     * }
     */
    public static int MACH_MSG_OVERWRITE() {
        return MACH_MSG_OVERWRITE;
    }
    private static final int MACH_MSG_GUARD_FLAGS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_GUARD_FLAGS_NONE 0
     * }
     */
    public static int MACH_MSG_GUARD_FLAGS_NONE() {
        return MACH_MSG_GUARD_FLAGS_NONE;
    }
    private static final int MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE 1
     * }
     */
    public static int MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE() {
        return MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE;
    }
    private static final int MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND 2
     * }
     */
    public static int MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND() {
        return MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND;
    }
    private static final int MACH_MSG_GUARD_FLAGS_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_GUARD_FLAGS_MASK 3
     * }
     */
    public static int MACH_MSG_GUARD_FLAGS_MASK() {
        return MACH_MSG_GUARD_FLAGS_MASK;
    }
    private static final int MACH_MSG_PORT_DESCRIPTOR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_PORT_DESCRIPTOR 0
     * }
     */
    public static int MACH_MSG_PORT_DESCRIPTOR() {
        return MACH_MSG_PORT_DESCRIPTOR;
    }
    private static final int MACH_MSG_OOL_DESCRIPTOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_OOL_DESCRIPTOR 1
     * }
     */
    public static int MACH_MSG_OOL_DESCRIPTOR() {
        return MACH_MSG_OOL_DESCRIPTOR;
    }
    private static final int MACH_MSG_OOL_PORTS_DESCRIPTOR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_OOL_PORTS_DESCRIPTOR 2
     * }
     */
    public static int MACH_MSG_OOL_PORTS_DESCRIPTOR() {
        return MACH_MSG_OOL_PORTS_DESCRIPTOR;
    }
    private static final int MACH_MSG_OOL_VOLATILE_DESCRIPTOR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_OOL_VOLATILE_DESCRIPTOR 3
     * }
     */
    public static int MACH_MSG_OOL_VOLATILE_DESCRIPTOR() {
        return MACH_MSG_OOL_VOLATILE_DESCRIPTOR;
    }
    private static final int MACH_MSG_GUARDED_PORT_DESCRIPTOR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_GUARDED_PORT_DESCRIPTOR 4
     * }
     */
    public static int MACH_MSG_GUARDED_PORT_DESCRIPTOR() {
        return MACH_MSG_GUARDED_PORT_DESCRIPTOR;
    }
    private static final int MACH_MSG_TRAILER_FORMAT_0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TRAILER_FORMAT_0 0
     * }
     */
    public static int MACH_MSG_TRAILER_FORMAT_0() {
        return MACH_MSG_TRAILER_FORMAT_0;
    }
    private static final int MACH_MSGH_KIND_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_KIND_NORMAL 0
     * }
     */
    public static int MACH_MSGH_KIND_NORMAL() {
        return MACH_MSGH_KIND_NORMAL;
    }
    private static final int MACH_MSGH_KIND_NOTIFICATION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSGH_KIND_NOTIFICATION 1
     * }
     */
    public static int MACH_MSGH_KIND_NOTIFICATION() {
        return MACH_MSGH_KIND_NOTIFICATION;
    }
    private static final int MACH_MSG_TYPE_PORT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_PORT_NONE 0
     * }
     */
    public static int MACH_MSG_TYPE_PORT_NONE() {
        return MACH_MSG_TYPE_PORT_NONE;
    }
    private static final int MACH_MSG_TYPE_PORT_NAME = (int)15L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_PORT_NAME 15
     * }
     */
    public static int MACH_MSG_TYPE_PORT_NAME() {
        return MACH_MSG_TYPE_PORT_NAME;
    }
    private static final int MACH_MSG_TYPE_LAST = (int)22L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_TYPE_LAST 22
     * }
     */
    public static int MACH_MSG_TYPE_LAST() {
        return MACH_MSG_TYPE_LAST;
    }
    private static final int MACH_MSG_OPTION_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_OPTION_NONE 0
     * }
     */
    public static int MACH_MSG_OPTION_NONE() {
        return MACH_MSG_OPTION_NONE;
    }
    private static final int MACH_SEND_MSG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_MSG 1
     * }
     */
    public static int MACH_SEND_MSG() {
        return MACH_SEND_MSG;
    }
    private static final int MACH_RCV_MSG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_MSG 2
     * }
     */
    public static int MACH_RCV_MSG() {
        return MACH_RCV_MSG;
    }
    private static final int MACH_RCV_LARGE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_LARGE 4
     * }
     */
    public static int MACH_RCV_LARGE() {
        return MACH_RCV_LARGE;
    }
    private static final int MACH_RCV_LARGE_IDENTITY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_LARGE_IDENTITY 8
     * }
     */
    public static int MACH_RCV_LARGE_IDENTITY() {
        return MACH_RCV_LARGE_IDENTITY;
    }
    private static final int MACH_SEND_TIMEOUT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_TIMEOUT 16
     * }
     */
    public static int MACH_SEND_TIMEOUT() {
        return MACH_SEND_TIMEOUT;
    }
    private static final int MACH_SEND_OVERRIDE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_OVERRIDE 32
     * }
     */
    public static int MACH_SEND_OVERRIDE() {
        return MACH_SEND_OVERRIDE;
    }
    private static final int MACH_SEND_INTERRUPT = (int)64L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INTERRUPT 64
     * }
     */
    public static int MACH_SEND_INTERRUPT() {
        return MACH_SEND_INTERRUPT;
    }
    private static final int MACH_SEND_NOTIFY = (int)128L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_NOTIFY 128
     * }
     */
    public static int MACH_SEND_NOTIFY() {
        return MACH_SEND_NOTIFY;
    }
    private static final int MACH_SEND_ALWAYS = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_ALWAYS 65536
     * }
     */
    public static int MACH_SEND_ALWAYS() {
        return MACH_SEND_ALWAYS;
    }
    private static final int MACH_SEND_FILTER_NONFATAL = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_FILTER_NONFATAL 65536
     * }
     */
    public static int MACH_SEND_FILTER_NONFATAL() {
        return MACH_SEND_FILTER_NONFATAL;
    }
    private static final int MACH_SEND_TRAILER = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_TRAILER 131072
     * }
     */
    public static int MACH_SEND_TRAILER() {
        return MACH_SEND_TRAILER;
    }
    private static final int MACH_SEND_NOIMPORTANCE = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_NOIMPORTANCE 262144
     * }
     */
    public static int MACH_SEND_NOIMPORTANCE() {
        return MACH_SEND_NOIMPORTANCE;
    }
    private static final int MACH_SEND_IMPORTANCE = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_IMPORTANCE 524288
     * }
     */
    public static int MACH_SEND_IMPORTANCE() {
        return MACH_SEND_IMPORTANCE;
    }
    private static final int MACH_SEND_SYNC_OVERRIDE = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_SYNC_OVERRIDE 1048576
     * }
     */
    public static int MACH_SEND_SYNC_OVERRIDE() {
        return MACH_SEND_SYNC_OVERRIDE;
    }
    private static final int MACH_SEND_PROPAGATE_QOS = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_PROPAGATE_QOS 2097152
     * }
     */
    public static int MACH_SEND_PROPAGATE_QOS() {
        return MACH_SEND_PROPAGATE_QOS;
    }
    private static final int MACH_SEND_KERNEL = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_KERNEL 4194304
     * }
     */
    public static int MACH_SEND_KERNEL() {
        return MACH_SEND_KERNEL;
    }
    private static final int MACH_SEND_SYNC_BOOTSTRAP_CHECKIN = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_SYNC_BOOTSTRAP_CHECKIN 8388608
     * }
     */
    public static int MACH_SEND_SYNC_BOOTSTRAP_CHECKIN() {
        return MACH_SEND_SYNC_BOOTSTRAP_CHECKIN;
    }
    private static final int MACH_RCV_TIMEOUT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TIMEOUT 256
     * }
     */
    public static int MACH_RCV_TIMEOUT() {
        return MACH_RCV_TIMEOUT;
    }
    private static final int MACH_RCV_NOTIFY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_NOTIFY 0
     * }
     */
    public static int MACH_RCV_NOTIFY() {
        return MACH_RCV_NOTIFY;
    }
    private static final int MACH_RCV_INTERRUPT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INTERRUPT 1024
     * }
     */
    public static int MACH_RCV_INTERRUPT() {
        return MACH_RCV_INTERRUPT;
    }
    private static final int MACH_RCV_VOUCHER = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_VOUCHER 2048
     * }
     */
    public static int MACH_RCV_VOUCHER() {
        return MACH_RCV_VOUCHER;
    }
    private static final int MACH_RCV_OVERWRITE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_OVERWRITE 0
     * }
     */
    public static int MACH_RCV_OVERWRITE() {
        return MACH_RCV_OVERWRITE;
    }
    private static final int MACH_RCV_GUARDED_DESC = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_GUARDED_DESC 4096
     * }
     */
    public static int MACH_RCV_GUARDED_DESC() {
        return MACH_RCV_GUARDED_DESC;
    }
    private static final int MACH_RCV_SYNC_WAIT = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_SYNC_WAIT 16384
     * }
     */
    public static int MACH_RCV_SYNC_WAIT() {
        return MACH_RCV_SYNC_WAIT;
    }
    private static final int MACH_RCV_SYNC_PEEK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_SYNC_PEEK 32768
     * }
     */
    public static int MACH_RCV_SYNC_PEEK() {
        return MACH_RCV_SYNC_PEEK;
    }
    private static final int MACH_MSG_STRICT_REPLY = (int)512L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_STRICT_REPLY 512
     * }
     */
    public static int MACH_MSG_STRICT_REPLY() {
        return MACH_MSG_STRICT_REPLY;
    }
    private static final int MACH_RCV_TRAILER_NULL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_NULL 0
     * }
     */
    public static int MACH_RCV_TRAILER_NULL() {
        return MACH_RCV_TRAILER_NULL;
    }
    private static final int MACH_RCV_TRAILER_SEQNO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_SEQNO 1
     * }
     */
    public static int MACH_RCV_TRAILER_SEQNO() {
        return MACH_RCV_TRAILER_SEQNO;
    }
    private static final int MACH_RCV_TRAILER_SENDER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_SENDER 2
     * }
     */
    public static int MACH_RCV_TRAILER_SENDER() {
        return MACH_RCV_TRAILER_SENDER;
    }
    private static final int MACH_RCV_TRAILER_AUDIT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_AUDIT 3
     * }
     */
    public static int MACH_RCV_TRAILER_AUDIT() {
        return MACH_RCV_TRAILER_AUDIT;
    }
    private static final int MACH_RCV_TRAILER_CTX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_CTX 4
     * }
     */
    public static int MACH_RCV_TRAILER_CTX() {
        return MACH_RCV_TRAILER_CTX;
    }
    private static final int MACH_RCV_TRAILER_AV = (int)7L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_AV 7
     * }
     */
    public static int MACH_RCV_TRAILER_AV() {
        return MACH_RCV_TRAILER_AV;
    }
    private static final int MACH_RCV_TRAILER_LABELS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TRAILER_LABELS 8
     * }
     */
    public static int MACH_RCV_TRAILER_LABELS() {
        return MACH_RCV_TRAILER_LABELS;
    }
    private static final int MACH_MSG_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_SUCCESS 0
     * }
     */
    public static int MACH_MSG_SUCCESS() {
        return MACH_MSG_SUCCESS;
    }
    private static final int MACH_MSG_MASK = (int)15872L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_MASK 15872
     * }
     */
    public static int MACH_MSG_MASK() {
        return MACH_MSG_MASK;
    }
    private static final int MACH_MSG_IPC_SPACE = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_IPC_SPACE 8192
     * }
     */
    public static int MACH_MSG_IPC_SPACE() {
        return MACH_MSG_IPC_SPACE;
    }
    private static final int MACH_MSG_VM_SPACE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_VM_SPACE 4096
     * }
     */
    public static int MACH_MSG_VM_SPACE() {
        return MACH_MSG_VM_SPACE;
    }
    private static final int MACH_MSG_IPC_KERNEL = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_IPC_KERNEL 2048
     * }
     */
    public static int MACH_MSG_IPC_KERNEL() {
        return MACH_MSG_IPC_KERNEL;
    }
    private static final int MACH_MSG_VM_KERNEL = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MACH_MSG_VM_KERNEL 1024
     * }
     */
    public static int MACH_MSG_VM_KERNEL() {
        return MACH_MSG_VM_KERNEL;
    }
    private static final int MACH_SEND_IN_PROGRESS = (int)268435457L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_IN_PROGRESS 268435457
     * }
     */
    public static int MACH_SEND_IN_PROGRESS() {
        return MACH_SEND_IN_PROGRESS;
    }
    private static final int MACH_SEND_INVALID_DATA = (int)268435458L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_DATA 268435458
     * }
     */
    public static int MACH_SEND_INVALID_DATA() {
        return MACH_SEND_INVALID_DATA;
    }
    private static final int MACH_SEND_INVALID_DEST = (int)268435459L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_DEST 268435459
     * }
     */
    public static int MACH_SEND_INVALID_DEST() {
        return MACH_SEND_INVALID_DEST;
    }
    private static final int MACH_SEND_TIMED_OUT = (int)268435460L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_TIMED_OUT 268435460
     * }
     */
    public static int MACH_SEND_TIMED_OUT() {
        return MACH_SEND_TIMED_OUT;
    }
    private static final int MACH_SEND_INVALID_VOUCHER = (int)268435461L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_VOUCHER 268435461
     * }
     */
    public static int MACH_SEND_INVALID_VOUCHER() {
        return MACH_SEND_INVALID_VOUCHER;
    }
    private static final int MACH_SEND_INTERRUPTED = (int)268435463L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INTERRUPTED 268435463
     * }
     */
    public static int MACH_SEND_INTERRUPTED() {
        return MACH_SEND_INTERRUPTED;
    }
    private static final int MACH_SEND_MSG_TOO_SMALL = (int)268435464L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_MSG_TOO_SMALL 268435464
     * }
     */
    public static int MACH_SEND_MSG_TOO_SMALL() {
        return MACH_SEND_MSG_TOO_SMALL;
    }
    private static final int MACH_SEND_INVALID_REPLY = (int)268435465L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_REPLY 268435465
     * }
     */
    public static int MACH_SEND_INVALID_REPLY() {
        return MACH_SEND_INVALID_REPLY;
    }
    private static final int MACH_SEND_INVALID_RIGHT = (int)268435466L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_RIGHT 268435466
     * }
     */
    public static int MACH_SEND_INVALID_RIGHT() {
        return MACH_SEND_INVALID_RIGHT;
    }
    private static final int MACH_SEND_INVALID_NOTIFY = (int)268435467L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_NOTIFY 268435467
     * }
     */
    public static int MACH_SEND_INVALID_NOTIFY() {
        return MACH_SEND_INVALID_NOTIFY;
    }
    private static final int MACH_SEND_INVALID_MEMORY = (int)268435468L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_MEMORY 268435468
     * }
     */
    public static int MACH_SEND_INVALID_MEMORY() {
        return MACH_SEND_INVALID_MEMORY;
    }
    private static final int MACH_SEND_NO_BUFFER = (int)268435469L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_NO_BUFFER 268435469
     * }
     */
    public static int MACH_SEND_NO_BUFFER() {
        return MACH_SEND_NO_BUFFER;
    }
    private static final int MACH_SEND_TOO_LARGE = (int)268435470L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_TOO_LARGE 268435470
     * }
     */
    public static int MACH_SEND_TOO_LARGE() {
        return MACH_SEND_TOO_LARGE;
    }
    private static final int MACH_SEND_INVALID_TYPE = (int)268435471L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_TYPE 268435471
     * }
     */
    public static int MACH_SEND_INVALID_TYPE() {
        return MACH_SEND_INVALID_TYPE;
    }
    private static final int MACH_SEND_INVALID_HEADER = (int)268435472L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_HEADER 268435472
     * }
     */
    public static int MACH_SEND_INVALID_HEADER() {
        return MACH_SEND_INVALID_HEADER;
    }
    private static final int MACH_SEND_INVALID_TRAILER = (int)268435473L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_TRAILER 268435473
     * }
     */
    public static int MACH_SEND_INVALID_TRAILER() {
        return MACH_SEND_INVALID_TRAILER;
    }
    private static final int MACH_SEND_INVALID_CONTEXT = (int)268435474L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_CONTEXT 268435474
     * }
     */
    public static int MACH_SEND_INVALID_CONTEXT() {
        return MACH_SEND_INVALID_CONTEXT;
    }
    private static final int MACH_SEND_INVALID_OPTIONS = (int)268435475L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_OPTIONS 268435475
     * }
     */
    public static int MACH_SEND_INVALID_OPTIONS() {
        return MACH_SEND_INVALID_OPTIONS;
    }
    private static final int MACH_SEND_INVALID_RT_OOL_SIZE = (int)268435477L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_INVALID_RT_OOL_SIZE 268435477
     * }
     */
    public static int MACH_SEND_INVALID_RT_OOL_SIZE() {
        return MACH_SEND_INVALID_RT_OOL_SIZE;
    }
    private static final int MACH_SEND_NO_GRANT_DEST = (int)268435478L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_NO_GRANT_DEST 268435478
     * }
     */
    public static int MACH_SEND_NO_GRANT_DEST() {
        return MACH_SEND_NO_GRANT_DEST;
    }
    private static final int MACH_SEND_MSG_FILTERED = (int)268435479L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_MSG_FILTERED 268435479
     * }
     */
    public static int MACH_SEND_MSG_FILTERED() {
        return MACH_SEND_MSG_FILTERED;
    }
    private static final int MACH_SEND_AUX_TOO_SMALL = (int)268435480L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_AUX_TOO_SMALL 268435480
     * }
     */
    public static int MACH_SEND_AUX_TOO_SMALL() {
        return MACH_SEND_AUX_TOO_SMALL;
    }
    private static final int MACH_SEND_AUX_TOO_LARGE = (int)268435481L;
    /**
     * {@snippet lang=c :
     * #define MACH_SEND_AUX_TOO_LARGE 268435481
     * }
     */
    public static int MACH_SEND_AUX_TOO_LARGE() {
        return MACH_SEND_AUX_TOO_LARGE;
    }
    private static final int MACH_RCV_IN_PROGRESS = (int)268451841L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_IN_PROGRESS 268451841
     * }
     */
    public static int MACH_RCV_IN_PROGRESS() {
        return MACH_RCV_IN_PROGRESS;
    }
    private static final int MACH_RCV_INVALID_NAME = (int)268451842L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_NAME 268451842
     * }
     */
    public static int MACH_RCV_INVALID_NAME() {
        return MACH_RCV_INVALID_NAME;
    }
    private static final int MACH_RCV_TIMED_OUT = (int)268451843L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TIMED_OUT 268451843
     * }
     */
    public static int MACH_RCV_TIMED_OUT() {
        return MACH_RCV_TIMED_OUT;
    }
    private static final int MACH_RCV_TOO_LARGE = (int)268451844L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_TOO_LARGE 268451844
     * }
     */
    public static int MACH_RCV_TOO_LARGE() {
        return MACH_RCV_TOO_LARGE;
    }
    private static final int MACH_RCV_INTERRUPTED = (int)268451845L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INTERRUPTED 268451845
     * }
     */
    public static int MACH_RCV_INTERRUPTED() {
        return MACH_RCV_INTERRUPTED;
    }
    private static final int MACH_RCV_PORT_CHANGED = (int)268451846L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_PORT_CHANGED 268451846
     * }
     */
    public static int MACH_RCV_PORT_CHANGED() {
        return MACH_RCV_PORT_CHANGED;
    }
    private static final int MACH_RCV_INVALID_NOTIFY = (int)268451847L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_NOTIFY 268451847
     * }
     */
    public static int MACH_RCV_INVALID_NOTIFY() {
        return MACH_RCV_INVALID_NOTIFY;
    }
    private static final int MACH_RCV_INVALID_DATA = (int)268451848L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_DATA 268451848
     * }
     */
    public static int MACH_RCV_INVALID_DATA() {
        return MACH_RCV_INVALID_DATA;
    }
    private static final int MACH_RCV_PORT_DIED = (int)268451849L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_PORT_DIED 268451849
     * }
     */
    public static int MACH_RCV_PORT_DIED() {
        return MACH_RCV_PORT_DIED;
    }
    private static final int MACH_RCV_IN_SET = (int)268451850L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_IN_SET 268451850
     * }
     */
    public static int MACH_RCV_IN_SET() {
        return MACH_RCV_IN_SET;
    }
    private static final int MACH_RCV_HEADER_ERROR = (int)268451851L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_HEADER_ERROR 268451851
     * }
     */
    public static int MACH_RCV_HEADER_ERROR() {
        return MACH_RCV_HEADER_ERROR;
    }
    private static final int MACH_RCV_BODY_ERROR = (int)268451852L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_BODY_ERROR 268451852
     * }
     */
    public static int MACH_RCV_BODY_ERROR() {
        return MACH_RCV_BODY_ERROR;
    }
    private static final int MACH_RCV_INVALID_TYPE = (int)268451853L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_TYPE 268451853
     * }
     */
    public static int MACH_RCV_INVALID_TYPE() {
        return MACH_RCV_INVALID_TYPE;
    }
    private static final int MACH_RCV_SCATTER_SMALL = (int)268451854L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_SCATTER_SMALL 268451854
     * }
     */
    public static int MACH_RCV_SCATTER_SMALL() {
        return MACH_RCV_SCATTER_SMALL;
    }
    private static final int MACH_RCV_INVALID_TRAILER = (int)268451855L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_TRAILER 268451855
     * }
     */
    public static int MACH_RCV_INVALID_TRAILER() {
        return MACH_RCV_INVALID_TRAILER;
    }
    private static final int MACH_RCV_IN_PROGRESS_TIMED = (int)268451857L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_IN_PROGRESS_TIMED 268451857
     * }
     */
    public static int MACH_RCV_IN_PROGRESS_TIMED() {
        return MACH_RCV_IN_PROGRESS_TIMED;
    }
    private static final int MACH_RCV_INVALID_REPLY = (int)268451858L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_REPLY 268451858
     * }
     */
    public static int MACH_RCV_INVALID_REPLY() {
        return MACH_RCV_INVALID_REPLY;
    }
    private static final int MACH_RCV_INVALID_ARGUMENTS = (int)268451859L;
    /**
     * {@snippet lang=c :
     * #define MACH_RCV_INVALID_ARGUMENTS 268451859
     * }
     */
    public static int MACH_RCV_INVALID_ARGUMENTS() {
        return MACH_RCV_INVALID_ARGUMENTS;
    }
    private static final int DISPATCH_MACH_SEND_DEAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_MACH_SEND_DEAD 1
     * }
     */
    public static int DISPATCH_MACH_SEND_DEAD() {
        return DISPATCH_MACH_SEND_DEAD;
    }
    private static final int DISPATCH_MEMORYPRESSURE_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_MEMORYPRESSURE_NORMAL 1
     * }
     */
    public static int DISPATCH_MEMORYPRESSURE_NORMAL() {
        return DISPATCH_MEMORYPRESSURE_NORMAL;
    }
    private static final int DISPATCH_MEMORYPRESSURE_WARN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_MEMORYPRESSURE_WARN 2
     * }
     */
    public static int DISPATCH_MEMORYPRESSURE_WARN() {
        return DISPATCH_MEMORYPRESSURE_WARN;
    }
    private static final int DISPATCH_MEMORYPRESSURE_CRITICAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_MEMORYPRESSURE_CRITICAL 4
     * }
     */
    public static int DISPATCH_MEMORYPRESSURE_CRITICAL() {
        return DISPATCH_MEMORYPRESSURE_CRITICAL;
    }
    private static final int DISPATCH_PROC_FORK = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_PROC_FORK 1073741824
     * }
     */
    public static int DISPATCH_PROC_FORK() {
        return DISPATCH_PROC_FORK;
    }
    private static final int DISPATCH_PROC_EXEC = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_PROC_EXEC 536870912
     * }
     */
    public static int DISPATCH_PROC_EXEC() {
        return DISPATCH_PROC_EXEC;
    }
    private static final int DISPATCH_PROC_SIGNAL = (int)134217728L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_PROC_SIGNAL 134217728
     * }
     */
    public static int DISPATCH_PROC_SIGNAL() {
        return DISPATCH_PROC_SIGNAL;
    }
    private static final int DISPATCH_VNODE_DELETE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_VNODE_DELETE 1
     * }
     */
    public static int DISPATCH_VNODE_DELETE() {
        return DISPATCH_VNODE_DELETE;
    }
    private static final int DISPATCH_VNODE_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_VNODE_WRITE 2
     * }
     */
    public static int DISPATCH_VNODE_WRITE() {
        return DISPATCH_VNODE_WRITE;
    }
    private static final int DISPATCH_VNODE_EXTEND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_VNODE_EXTEND 4
     * }
     */
    public static int DISPATCH_VNODE_EXTEND() {
        return DISPATCH_VNODE_EXTEND;
    }
    private static final int DISPATCH_VNODE_ATTRIB = (int)8L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_VNODE_ATTRIB 8
     * }
     */
    public static int DISPATCH_VNODE_ATTRIB() {
        return DISPATCH_VNODE_ATTRIB;
    }
    private static final int DISPATCH_VNODE_LINK = (int)16L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_VNODE_LINK 16
     * }
     */
    public static int DISPATCH_VNODE_LINK() {
        return DISPATCH_VNODE_LINK;
    }
    private static final int DISPATCH_VNODE_RENAME = (int)32L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_VNODE_RENAME 32
     * }
     */
    public static int DISPATCH_VNODE_RENAME() {
        return DISPATCH_VNODE_RENAME;
    }
    private static final int DISPATCH_VNODE_REVOKE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_VNODE_REVOKE 64
     * }
     */
    public static int DISPATCH_VNODE_REVOKE() {
        return DISPATCH_VNODE_REVOKE;
    }
    private static final int DISPATCH_VNODE_FUNLOCK = (int)256L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_VNODE_FUNLOCK 256
     * }
     */
    public static int DISPATCH_VNODE_FUNLOCK() {
        return DISPATCH_VNODE_FUNLOCK;
    }
    private static final int DISPATCH_TIMER_STRICT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_TIMER_STRICT 1
     * }
     */
    public static int DISPATCH_TIMER_STRICT() {
        return DISPATCH_TIMER_STRICT;
    }
    private static final int DISPATCH_ONCE_INLINE_FASTPATH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_ONCE_INLINE_FASTPATH 1
     * }
     */
    public static int DISPATCH_ONCE_INLINE_FASTPATH() {
        return DISPATCH_ONCE_INLINE_FASTPATH;
    }
    private static final int DISPATCH_IO_STREAM = (int)0L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_IO_STREAM 0
     * }
     */
    public static int DISPATCH_IO_STREAM() {
        return DISPATCH_IO_STREAM;
    }
    private static final int DISPATCH_IO_RANDOM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_IO_RANDOM 1
     * }
     */
    public static int DISPATCH_IO_RANDOM() {
        return DISPATCH_IO_RANDOM;
    }
    private static final int DISPATCH_IO_STOP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_IO_STOP 1
     * }
     */
    public static int DISPATCH_IO_STOP() {
        return DISPATCH_IO_STOP;
    }
    private static final int DISPATCH_IO_STRICT_INTERVAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DISPATCH_IO_STRICT_INTERVAL 1
     * }
     */
    public static int DISPATCH_IO_STRICT_INTERVAL() {
        return DISPATCH_IO_STRICT_INTERVAL;
    }
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t cl_char
     * }
     */
    public static final OfByte cl_char = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint8_t cl_uchar
     * }
     */
    public static final OfByte cl_uchar = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t cl_short
     * }
     */
    public static final OfShort cl_short = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t cl_ushort
     * }
     */
    public static final OfShort cl_ushort = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t cl_int
     * }
     */
    public static final OfInt cl_int = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t cl_uint
     * }
     */
    public static final OfInt cl_uint = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t cl_long
     * }
     */
    public static final OfLong cl_long = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t cl_ulong
     * }
     */
    public static final OfLong cl_ulong = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint16_t cl_half
     * }
     */
    public static final OfShort cl_half = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef float cl_float
     * }
     */
    public static final OfFloat cl_float = opencl_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double cl_double
     * }
     */
    public static final OfDouble cl_double = opencl_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long rsize_t
     * }
     */
    public static final OfLong rsize_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int cl_GLuint
     * }
     */
    public static final OfInt cl_GLuint = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int cl_GLint
     * }
     */
    public static final OfInt cl_GLint = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int cl_GLenum
     * }
     */
    public static final OfInt cl_GLenum = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_platform_id *cl_platform_id
     * }
     */
    public static final AddressLayout cl_platform_id = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_device_id *cl_device_id
     * }
     */
    public static final AddressLayout cl_device_id = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_context *cl_context
     * }
     */
    public static final AddressLayout cl_context = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_command_queue *cl_command_queue
     * }
     */
    public static final AddressLayout cl_command_queue = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_mem *cl_mem
     * }
     */
    public static final AddressLayout cl_mem = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_program *cl_program
     * }
     */
    public static final AddressLayout cl_program = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_kernel *cl_kernel
     * }
     */
    public static final AddressLayout cl_kernel = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_event *cl_event
     * }
     */
    public static final AddressLayout cl_event = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_sampler *cl_sampler
     * }
     */
    public static final AddressLayout cl_sampler = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_bool
     * }
     */
    public static final OfInt cl_bool = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_ulong cl_bitfield
     * }
     */
    public static final OfLong cl_bitfield = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_type
     * }
     */
    public static final OfLong cl_device_type = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_platform_info
     * }
     */
    public static final OfInt cl_platform_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_device_info
     * }
     */
    public static final OfInt cl_device_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_fp_config
     * }
     */
    public static final OfLong cl_device_fp_config = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_device_mem_cache_type
     * }
     */
    public static final OfInt cl_device_mem_cache_type = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_device_local_mem_type
     * }
     */
    public static final OfInt cl_device_local_mem_type = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_exec_capabilities
     * }
     */
    public static final OfLong cl_device_exec_capabilities = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_command_queue_properties
     * }
     */
    public static final OfLong cl_command_queue_properties = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t cl_device_partition_property
     * }
     */
    public static final OfLong cl_device_partition_property = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_affinity_domain
     * }
     */
    public static final OfLong cl_device_affinity_domain = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t cl_context_properties
     * }
     */
    public static final OfLong cl_context_properties = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_context_info
     * }
     */
    public static final OfInt cl_context_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_command_queue_info
     * }
     */
    public static final OfInt cl_command_queue_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_channel_order
     * }
     */
    public static final OfInt cl_channel_order = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_channel_type
     * }
     */
    public static final OfInt cl_channel_type = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_mem_flags
     * }
     */
    public static final OfLong cl_mem_flags = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_mem_object_type
     * }
     */
    public static final OfInt cl_mem_object_type = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_mem_info
     * }
     */
    public static final OfInt cl_mem_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_mem_migration_flags
     * }
     */
    public static final OfLong cl_mem_migration_flags = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_image_info
     * }
     */
    public static final OfInt cl_image_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_buffer_create_type
     * }
     */
    public static final OfInt cl_buffer_create_type = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_addressing_mode
     * }
     */
    public static final OfInt cl_addressing_mode = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_filter_mode
     * }
     */
    public static final OfInt cl_filter_mode = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_sampler_info
     * }
     */
    public static final OfInt cl_sampler_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_map_flags
     * }
     */
    public static final OfLong cl_map_flags = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_program_info
     * }
     */
    public static final OfInt cl_program_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_program_build_info
     * }
     */
    public static final OfInt cl_program_build_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_program_binary_type
     * }
     */
    public static final OfInt cl_program_binary_type = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_int cl_build_status
     * }
     */
    public static final OfInt cl_build_status = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_info
     * }
     */
    public static final OfInt cl_kernel_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_arg_info
     * }
     */
    public static final OfInt cl_kernel_arg_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_arg_address_qualifier
     * }
     */
    public static final OfInt cl_kernel_arg_address_qualifier = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_arg_access_qualifier
     * }
     */
    public static final OfInt cl_kernel_arg_access_qualifier = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_kernel_arg_type_qualifier
     * }
     */
    public static final OfLong cl_kernel_arg_type_qualifier = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_work_group_info
     * }
     */
    public static final OfInt cl_kernel_work_group_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_event_info
     * }
     */
    public static final OfInt cl_event_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_command_type
     * }
     */
    public static final OfInt cl_command_type = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_profiling_info
     * }
     */
    public static final OfInt cl_profiling_info = opencl_h.C_INT;

    private static class clGetPlatformIDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetPlatformIDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetPlatformIDs(cl_uint, cl_platform_id *, cl_uint *)
     * }
     */
    public static FunctionDescriptor clGetPlatformIDs$descriptor() {
        return clGetPlatformIDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetPlatformIDs(cl_uint, cl_platform_id *, cl_uint *)
     * }
     */
    public static MethodHandle clGetPlatformIDs$handle() {
        return clGetPlatformIDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetPlatformIDs(cl_uint, cl_platform_id *, cl_uint *)
     * }
     */
    public static MemorySegment clGetPlatformIDs$address() {
        return clGetPlatformIDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetPlatformIDs(cl_uint, cl_platform_id *, cl_uint *)
     * }
     */
    public static int clGetPlatformIDs(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = clGetPlatformIDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetPlatformIDs", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetPlatformInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetPlatformInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetPlatformInfo(cl_platform_id, cl_platform_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetPlatformInfo$descriptor() {
        return clGetPlatformInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetPlatformInfo(cl_platform_id, cl_platform_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetPlatformInfo$handle() {
        return clGetPlatformInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetPlatformInfo(cl_platform_id, cl_platform_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetPlatformInfo$address() {
        return clGetPlatformInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetPlatformInfo(cl_platform_id, cl_platform_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetPlatformInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetPlatformInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetPlatformInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetDeviceIDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetDeviceIDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceIDs(cl_platform_id, cl_device_type, cl_uint, cl_device_id *, cl_uint *)
     * }
     */
    public static FunctionDescriptor clGetDeviceIDs$descriptor() {
        return clGetDeviceIDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceIDs(cl_platform_id, cl_device_type, cl_uint, cl_device_id *, cl_uint *)
     * }
     */
    public static MethodHandle clGetDeviceIDs$handle() {
        return clGetDeviceIDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceIDs(cl_platform_id, cl_device_type, cl_uint, cl_device_id *, cl_uint *)
     * }
     */
    public static MemorySegment clGetDeviceIDs$address() {
        return clGetDeviceIDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetDeviceIDs(cl_platform_id, cl_device_type, cl_uint, cl_device_id *, cl_uint *)
     * }
     */
    public static int clGetDeviceIDs(MemorySegment x0, long x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetDeviceIDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetDeviceIDs", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetDeviceInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetDeviceInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceInfo(cl_device_id, cl_device_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetDeviceInfo$descriptor() {
        return clGetDeviceInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceInfo(cl_device_id, cl_device_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetDeviceInfo$handle() {
        return clGetDeviceInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceInfo(cl_device_id, cl_device_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetDeviceInfo$address() {
        return clGetDeviceInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetDeviceInfo(cl_device_id, cl_device_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetDeviceInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetDeviceInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetDeviceInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateSubDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateSubDevices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCreateSubDevices(cl_device_id, const cl_device_partition_property *, cl_uint, cl_device_id *, cl_uint *)
     * }
     */
    public static FunctionDescriptor clCreateSubDevices$descriptor() {
        return clCreateSubDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCreateSubDevices(cl_device_id, const cl_device_partition_property *, cl_uint, cl_device_id *, cl_uint *)
     * }
     */
    public static MethodHandle clCreateSubDevices$handle() {
        return clCreateSubDevices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clCreateSubDevices(cl_device_id, const cl_device_partition_property *, cl_uint, cl_device_id *, cl_uint *)
     * }
     */
    public static MemorySegment clCreateSubDevices$address() {
        return clCreateSubDevices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clCreateSubDevices(cl_device_id, const cl_device_partition_property *, cl_uint, cl_device_id *, cl_uint *)
     * }
     */
    public static int clCreateSubDevices(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clCreateSubDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateSubDevices", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clRetainDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainDevice(cl_device_id)
     * }
     */
    public static FunctionDescriptor clRetainDevice$descriptor() {
        return clRetainDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainDevice(cl_device_id)
     * }
     */
    public static MethodHandle clRetainDevice$handle() {
        return clRetainDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clRetainDevice(cl_device_id)
     * }
     */
    public static MemorySegment clRetainDevice$address() {
        return clRetainDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clRetainDevice(cl_device_id)
     * }
     */
    public static int clRetainDevice(MemorySegment x0) {
        var mh$ = clRetainDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainDevice", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clReleaseDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseDevice(cl_device_id)
     * }
     */
    public static FunctionDescriptor clReleaseDevice$descriptor() {
        return clReleaseDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseDevice(cl_device_id)
     * }
     */
    public static MethodHandle clReleaseDevice$handle() {
        return clReleaseDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clReleaseDevice(cl_device_id)
     * }
     */
    public static MemorySegment clReleaseDevice$address() {
        return clReleaseDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseDevice(cl_device_id)
     * }
     */
    public static int clReleaseDevice(MemorySegment x0) {
        var mh$ = clReleaseDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseDevice", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_context clCreateContext(const cl_context_properties *, cl_uint, const cl_device_id *, void (*)(const char *, const void *, size_t, void *), void *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateContext$descriptor() {
        return clCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_context clCreateContext(const cl_context_properties *, cl_uint, const cl_device_id *, void (*)(const char *, const void *, size_t, void *), void *, cl_int *)
     * }
     */
    public static MethodHandle clCreateContext$handle() {
        return clCreateContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_context clCreateContext(const cl_context_properties *, cl_uint, const cl_device_id *, void (*)(const char *, const void *, size_t, void *), void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateContext$address() {
        return clCreateContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_context clCreateContext(const cl_context_properties *, cl_uint, const cl_device_id *, void (*)(const char *, const void *, size_t, void *), void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateContext(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateContext", x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateContextFromType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateContextFromType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_context clCreateContextFromType(const cl_context_properties *, cl_device_type, void (*)(const char *, const void *, size_t, void *), void *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateContextFromType$descriptor() {
        return clCreateContextFromType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_context clCreateContextFromType(const cl_context_properties *, cl_device_type, void (*)(const char *, const void *, size_t, void *), void *, cl_int *)
     * }
     */
    public static MethodHandle clCreateContextFromType$handle() {
        return clCreateContextFromType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_context clCreateContextFromType(const cl_context_properties *, cl_device_type, void (*)(const char *, const void *, size_t, void *), void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateContextFromType$address() {
        return clCreateContextFromType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_context clCreateContextFromType(const cl_context_properties *, cl_device_type, void (*)(const char *, const void *, size_t, void *), void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateContextFromType(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clCreateContextFromType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateContextFromType", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clRetainContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainContext(cl_context)
     * }
     */
    public static FunctionDescriptor clRetainContext$descriptor() {
        return clRetainContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainContext(cl_context)
     * }
     */
    public static MethodHandle clRetainContext$handle() {
        return clRetainContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clRetainContext(cl_context)
     * }
     */
    public static MemorySegment clRetainContext$address() {
        return clRetainContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clRetainContext(cl_context)
     * }
     */
    public static int clRetainContext(MemorySegment x0) {
        var mh$ = clRetainContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainContext", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clReleaseContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseContext(cl_context)
     * }
     */
    public static FunctionDescriptor clReleaseContext$descriptor() {
        return clReleaseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseContext(cl_context)
     * }
     */
    public static MethodHandle clReleaseContext$handle() {
        return clReleaseContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clReleaseContext(cl_context)
     * }
     */
    public static MemorySegment clReleaseContext$address() {
        return clReleaseContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseContext(cl_context)
     * }
     */
    public static int clReleaseContext(MemorySegment x0) {
        var mh$ = clReleaseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseContext", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetContextInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetContextInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetContextInfo(cl_context, cl_context_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetContextInfo$descriptor() {
        return clGetContextInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetContextInfo(cl_context, cl_context_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetContextInfo$handle() {
        return clGetContextInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetContextInfo(cl_context, cl_context_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetContextInfo$address() {
        return clGetContextInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetContextInfo(cl_context, cl_context_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetContextInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetContextInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetContextInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateCommandQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateCommandQueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueue(cl_context, cl_device_id, cl_command_queue_properties, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateCommandQueue$descriptor() {
        return clCreateCommandQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueue(cl_context, cl_device_id, cl_command_queue_properties, cl_int *)
     * }
     */
    public static MethodHandle clCreateCommandQueue$handle() {
        return clCreateCommandQueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueue(cl_context, cl_device_id, cl_command_queue_properties, cl_int *)
     * }
     */
    public static MemorySegment clCreateCommandQueue$address() {
        return clCreateCommandQueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueue(cl_context, cl_device_id, cl_command_queue_properties, cl_int *)
     * }
     */
    public static MemorySegment clCreateCommandQueue(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = clCreateCommandQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateCommandQueue", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainCommandQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clRetainCommandQueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainCommandQueue(cl_command_queue)
     * }
     */
    public static FunctionDescriptor clRetainCommandQueue$descriptor() {
        return clRetainCommandQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainCommandQueue(cl_command_queue)
     * }
     */
    public static MethodHandle clRetainCommandQueue$handle() {
        return clRetainCommandQueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clRetainCommandQueue(cl_command_queue)
     * }
     */
    public static MemorySegment clRetainCommandQueue$address() {
        return clRetainCommandQueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clRetainCommandQueue(cl_command_queue)
     * }
     */
    public static int clRetainCommandQueue(MemorySegment x0) {
        var mh$ = clRetainCommandQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainCommandQueue", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseCommandQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clReleaseCommandQueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseCommandQueue(cl_command_queue)
     * }
     */
    public static FunctionDescriptor clReleaseCommandQueue$descriptor() {
        return clReleaseCommandQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseCommandQueue(cl_command_queue)
     * }
     */
    public static MethodHandle clReleaseCommandQueue$handle() {
        return clReleaseCommandQueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clReleaseCommandQueue(cl_command_queue)
     * }
     */
    public static MemorySegment clReleaseCommandQueue$address() {
        return clReleaseCommandQueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseCommandQueue(cl_command_queue)
     * }
     */
    public static int clReleaseCommandQueue(MemorySegment x0) {
        var mh$ = clReleaseCommandQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseCommandQueue", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetCommandQueueInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetCommandQueueInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetCommandQueueInfo(cl_command_queue, cl_command_queue_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetCommandQueueInfo$descriptor() {
        return clGetCommandQueueInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetCommandQueueInfo(cl_command_queue, cl_command_queue_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetCommandQueueInfo$handle() {
        return clGetCommandQueueInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetCommandQueueInfo(cl_command_queue, cl_command_queue_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetCommandQueueInfo$address() {
        return clGetCommandQueueInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetCommandQueueInfo(cl_command_queue, cl_command_queue_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetCommandQueueInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetCommandQueueInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetCommandQueueInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateBuffer(cl_context, cl_mem_flags, size_t, void *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateBuffer$descriptor() {
        return clCreateBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateBuffer(cl_context, cl_mem_flags, size_t, void *, cl_int *)
     * }
     */
    public static MethodHandle clCreateBuffer$handle() {
        return clCreateBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem clCreateBuffer(cl_context, cl_mem_flags, size_t, void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateBuffer$address() {
        return clCreateBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateBuffer(cl_context, cl_mem_flags, size_t, void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateBuffer(MemorySegment x0, long x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clCreateBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateBuffer", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateSubBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateSubBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateSubBuffer(cl_mem, cl_mem_flags, cl_buffer_create_type, const void *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateSubBuffer$descriptor() {
        return clCreateSubBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateSubBuffer(cl_mem, cl_mem_flags, cl_buffer_create_type, const void *, cl_int *)
     * }
     */
    public static MethodHandle clCreateSubBuffer$handle() {
        return clCreateSubBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem clCreateSubBuffer(cl_mem, cl_mem_flags, cl_buffer_create_type, const void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateSubBuffer$address() {
        return clCreateSubBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateSubBuffer(cl_mem, cl_mem_flags, cl_buffer_create_type, const void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateSubBuffer(MemorySegment x0, long x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clCreateSubBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateSubBuffer", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage(cl_context, cl_mem_flags, const cl_image_format *, const cl_image_desc *, void *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateImage$descriptor() {
        return clCreateImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage(cl_context, cl_mem_flags, const cl_image_format *, const cl_image_desc *, void *, cl_int *)
     * }
     */
    public static MethodHandle clCreateImage$handle() {
        return clCreateImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage(cl_context, cl_mem_flags, const cl_image_format *, const cl_image_desc *, void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateImage$address() {
        return clCreateImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateImage(cl_context, cl_mem_flags, const cl_image_format *, const cl_image_desc *, void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateImage(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clCreateImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateImage", x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainMemObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clRetainMemObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainMemObject(cl_mem)
     * }
     */
    public static FunctionDescriptor clRetainMemObject$descriptor() {
        return clRetainMemObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainMemObject(cl_mem)
     * }
     */
    public static MethodHandle clRetainMemObject$handle() {
        return clRetainMemObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clRetainMemObject(cl_mem)
     * }
     */
    public static MemorySegment clRetainMemObject$address() {
        return clRetainMemObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clRetainMemObject(cl_mem)
     * }
     */
    public static int clRetainMemObject(MemorySegment x0) {
        var mh$ = clRetainMemObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainMemObject", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseMemObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clReleaseMemObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseMemObject(cl_mem)
     * }
     */
    public static FunctionDescriptor clReleaseMemObject$descriptor() {
        return clReleaseMemObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseMemObject(cl_mem)
     * }
     */
    public static MethodHandle clReleaseMemObject$handle() {
        return clReleaseMemObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clReleaseMemObject(cl_mem)
     * }
     */
    public static MemorySegment clReleaseMemObject$address() {
        return clReleaseMemObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseMemObject(cl_mem)
     * }
     */
    public static int clReleaseMemObject(MemorySegment x0) {
        var mh$ = clReleaseMemObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseMemObject", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetSupportedImageFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetSupportedImageFormats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetSupportedImageFormats(cl_context, cl_mem_flags, cl_mem_object_type, cl_uint, cl_image_format *, cl_uint *)
     * }
     */
    public static FunctionDescriptor clGetSupportedImageFormats$descriptor() {
        return clGetSupportedImageFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetSupportedImageFormats(cl_context, cl_mem_flags, cl_mem_object_type, cl_uint, cl_image_format *, cl_uint *)
     * }
     */
    public static MethodHandle clGetSupportedImageFormats$handle() {
        return clGetSupportedImageFormats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetSupportedImageFormats(cl_context, cl_mem_flags, cl_mem_object_type, cl_uint, cl_image_format *, cl_uint *)
     * }
     */
    public static MemorySegment clGetSupportedImageFormats$address() {
        return clGetSupportedImageFormats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetSupportedImageFormats(cl_context, cl_mem_flags, cl_mem_object_type, cl_uint, cl_image_format *, cl_uint *)
     * }
     */
    public static int clGetSupportedImageFormats(MemorySegment x0, long x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clGetSupportedImageFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetSupportedImageFormats", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetMemObjectInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetMemObjectInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetMemObjectInfo(cl_mem, cl_mem_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetMemObjectInfo$descriptor() {
        return clGetMemObjectInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetMemObjectInfo(cl_mem, cl_mem_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetMemObjectInfo$handle() {
        return clGetMemObjectInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetMemObjectInfo(cl_mem, cl_mem_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetMemObjectInfo$address() {
        return clGetMemObjectInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetMemObjectInfo(cl_mem, cl_mem_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetMemObjectInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetMemObjectInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetMemObjectInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetImageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetImageInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetImageInfo(cl_mem, cl_image_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetImageInfo$descriptor() {
        return clGetImageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetImageInfo(cl_mem, cl_image_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetImageInfo$handle() {
        return clGetImageInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetImageInfo(cl_mem, cl_image_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetImageInfo$address() {
        return clGetImageInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetImageInfo(cl_mem, cl_image_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetImageInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetImageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetImageInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetMemObjectDestructorCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clSetMemObjectDestructorCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetMemObjectDestructorCallback(cl_mem, void (*)(cl_mem, void *), void *)
     * }
     */
    public static FunctionDescriptor clSetMemObjectDestructorCallback$descriptor() {
        return clSetMemObjectDestructorCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetMemObjectDestructorCallback(cl_mem, void (*)(cl_mem, void *), void *)
     * }
     */
    public static MethodHandle clSetMemObjectDestructorCallback$handle() {
        return clSetMemObjectDestructorCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clSetMemObjectDestructorCallback(cl_mem, void (*)(cl_mem, void *), void *)
     * }
     */
    public static MemorySegment clSetMemObjectDestructorCallback$address() {
        return clSetMemObjectDestructorCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clSetMemObjectDestructorCallback(cl_mem, void (*)(cl_mem, void *), void *)
     * }
     */
    public static int clSetMemObjectDestructorCallback(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = clSetMemObjectDestructorCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetMemObjectDestructorCallback", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateSampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateSampler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_sampler clCreateSampler(cl_context, cl_bool, cl_addressing_mode, cl_filter_mode, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateSampler$descriptor() {
        return clCreateSampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_sampler clCreateSampler(cl_context, cl_bool, cl_addressing_mode, cl_filter_mode, cl_int *)
     * }
     */
    public static MethodHandle clCreateSampler$handle() {
        return clCreateSampler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_sampler clCreateSampler(cl_context, cl_bool, cl_addressing_mode, cl_filter_mode, cl_int *)
     * }
     */
    public static MemorySegment clCreateSampler$address() {
        return clCreateSampler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_sampler clCreateSampler(cl_context, cl_bool, cl_addressing_mode, cl_filter_mode, cl_int *)
     * }
     */
    public static MemorySegment clCreateSampler(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = clCreateSampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateSampler", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainSampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clRetainSampler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainSampler(cl_sampler)
     * }
     */
    public static FunctionDescriptor clRetainSampler$descriptor() {
        return clRetainSampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainSampler(cl_sampler)
     * }
     */
    public static MethodHandle clRetainSampler$handle() {
        return clRetainSampler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clRetainSampler(cl_sampler)
     * }
     */
    public static MemorySegment clRetainSampler$address() {
        return clRetainSampler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clRetainSampler(cl_sampler)
     * }
     */
    public static int clRetainSampler(MemorySegment x0) {
        var mh$ = clRetainSampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainSampler", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseSampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clReleaseSampler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseSampler(cl_sampler)
     * }
     */
    public static FunctionDescriptor clReleaseSampler$descriptor() {
        return clReleaseSampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseSampler(cl_sampler)
     * }
     */
    public static MethodHandle clReleaseSampler$handle() {
        return clReleaseSampler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clReleaseSampler(cl_sampler)
     * }
     */
    public static MemorySegment clReleaseSampler$address() {
        return clReleaseSampler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseSampler(cl_sampler)
     * }
     */
    public static int clReleaseSampler(MemorySegment x0) {
        var mh$ = clReleaseSampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseSampler", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetSamplerInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetSamplerInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetSamplerInfo(cl_sampler, cl_sampler_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetSamplerInfo$descriptor() {
        return clGetSamplerInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetSamplerInfo(cl_sampler, cl_sampler_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetSamplerInfo$handle() {
        return clGetSamplerInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetSamplerInfo(cl_sampler, cl_sampler_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetSamplerInfo$address() {
        return clGetSamplerInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetSamplerInfo(cl_sampler, cl_sampler_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetSamplerInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetSamplerInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetSamplerInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateProgramWithSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateProgramWithSource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithSource(cl_context, cl_uint, const char **, const size_t *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateProgramWithSource$descriptor() {
        return clCreateProgramWithSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithSource(cl_context, cl_uint, const char **, const size_t *, cl_int *)
     * }
     */
    public static MethodHandle clCreateProgramWithSource$handle() {
        return clCreateProgramWithSource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithSource(cl_context, cl_uint, const char **, const size_t *, cl_int *)
     * }
     */
    public static MemorySegment clCreateProgramWithSource$address() {
        return clCreateProgramWithSource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithSource(cl_context, cl_uint, const char **, const size_t *, cl_int *)
     * }
     */
    public static MemorySegment clCreateProgramWithSource(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clCreateProgramWithSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateProgramWithSource", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateProgramWithBinary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateProgramWithBinary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBinary(cl_context, cl_uint, const cl_device_id *, const size_t *, const unsigned char **, cl_int *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateProgramWithBinary$descriptor() {
        return clCreateProgramWithBinary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBinary(cl_context, cl_uint, const cl_device_id *, const size_t *, const unsigned char **, cl_int *, cl_int *)
     * }
     */
    public static MethodHandle clCreateProgramWithBinary$handle() {
        return clCreateProgramWithBinary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBinary(cl_context, cl_uint, const cl_device_id *, const size_t *, const unsigned char **, cl_int *, cl_int *)
     * }
     */
    public static MemorySegment clCreateProgramWithBinary$address() {
        return clCreateProgramWithBinary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBinary(cl_context, cl_uint, const cl_device_id *, const size_t *, const unsigned char **, cl_int *, cl_int *)
     * }
     */
    public static MemorySegment clCreateProgramWithBinary(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = clCreateProgramWithBinary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateProgramWithBinary", x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateProgramWithBuiltInKernels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateProgramWithBuiltInKernels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBuiltInKernels(cl_context, cl_uint, const cl_device_id *, const char *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateProgramWithBuiltInKernels$descriptor() {
        return clCreateProgramWithBuiltInKernels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBuiltInKernels(cl_context, cl_uint, const cl_device_id *, const char *, cl_int *)
     * }
     */
    public static MethodHandle clCreateProgramWithBuiltInKernels$handle() {
        return clCreateProgramWithBuiltInKernels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBuiltInKernels(cl_context, cl_uint, const cl_device_id *, const char *, cl_int *)
     * }
     */
    public static MemorySegment clCreateProgramWithBuiltInKernels$address() {
        return clCreateProgramWithBuiltInKernels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBuiltInKernels(cl_context, cl_uint, const cl_device_id *, const char *, cl_int *)
     * }
     */
    public static MemorySegment clCreateProgramWithBuiltInKernels(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clCreateProgramWithBuiltInKernels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateProgramWithBuiltInKernels", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clRetainProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainProgram(cl_program)
     * }
     */
    public static FunctionDescriptor clRetainProgram$descriptor() {
        return clRetainProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainProgram(cl_program)
     * }
     */
    public static MethodHandle clRetainProgram$handle() {
        return clRetainProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clRetainProgram(cl_program)
     * }
     */
    public static MemorySegment clRetainProgram$address() {
        return clRetainProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clRetainProgram(cl_program)
     * }
     */
    public static int clRetainProgram(MemorySegment x0) {
        var mh$ = clRetainProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainProgram", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clReleaseProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseProgram(cl_program)
     * }
     */
    public static FunctionDescriptor clReleaseProgram$descriptor() {
        return clReleaseProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseProgram(cl_program)
     * }
     */
    public static MethodHandle clReleaseProgram$handle() {
        return clReleaseProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clReleaseProgram(cl_program)
     * }
     */
    public static MemorySegment clReleaseProgram$address() {
        return clReleaseProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseProgram(cl_program)
     * }
     */
    public static int clReleaseProgram(MemorySegment x0) {
        var mh$ = clReleaseProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseProgram", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clBuildProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clBuildProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clBuildProgram(cl_program, cl_uint, const cl_device_id *, const char *, void (*)(cl_program, void *), void *)
     * }
     */
    public static FunctionDescriptor clBuildProgram$descriptor() {
        return clBuildProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clBuildProgram(cl_program, cl_uint, const cl_device_id *, const char *, void (*)(cl_program, void *), void *)
     * }
     */
    public static MethodHandle clBuildProgram$handle() {
        return clBuildProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clBuildProgram(cl_program, cl_uint, const cl_device_id *, const char *, void (*)(cl_program, void *), void *)
     * }
     */
    public static MemorySegment clBuildProgram$address() {
        return clBuildProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clBuildProgram(cl_program, cl_uint, const cl_device_id *, const char *, void (*)(cl_program, void *), void *)
     * }
     */
    public static int clBuildProgram(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clBuildProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clBuildProgram", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCompileProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCompileProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCompileProgram(cl_program, cl_uint, const cl_device_id *, const char *, cl_uint, const cl_program *, const char **, void (*)(cl_program, void *), void *)
     * }
     */
    public static FunctionDescriptor clCompileProgram$descriptor() {
        return clCompileProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCompileProgram(cl_program, cl_uint, const cl_device_id *, const char *, cl_uint, const cl_program *, const char **, void (*)(cl_program, void *), void *)
     * }
     */
    public static MethodHandle clCompileProgram$handle() {
        return clCompileProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clCompileProgram(cl_program, cl_uint, const cl_device_id *, const char *, cl_uint, const cl_program *, const char **, void (*)(cl_program, void *), void *)
     * }
     */
    public static MemorySegment clCompileProgram$address() {
        return clCompileProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clCompileProgram(cl_program, cl_uint, const cl_device_id *, const char *, cl_uint, const cl_program *, const char **, void (*)(cl_program, void *), void *)
     * }
     */
    public static int clCompileProgram(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, int x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = clCompileProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCompileProgram", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clLinkProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clLinkProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_program clLinkProgram(cl_context, cl_uint, const cl_device_id *, const char *, cl_uint, const cl_program *, void (*)(cl_program, void *), void *, cl_int *)
     * }
     */
    public static FunctionDescriptor clLinkProgram$descriptor() {
        return clLinkProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_program clLinkProgram(cl_context, cl_uint, const cl_device_id *, const char *, cl_uint, const cl_program *, void (*)(cl_program, void *), void *, cl_int *)
     * }
     */
    public static MethodHandle clLinkProgram$handle() {
        return clLinkProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_program clLinkProgram(cl_context, cl_uint, const cl_device_id *, const char *, cl_uint, const cl_program *, void (*)(cl_program, void *), void *, cl_int *)
     * }
     */
    public static MemorySegment clLinkProgram$address() {
        return clLinkProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_program clLinkProgram(cl_context, cl_uint, const cl_device_id *, const char *, cl_uint, const cl_program *, void (*)(cl_program, void *), void *, cl_int *)
     * }
     */
    public static MemorySegment clLinkProgram(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, int x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = clLinkProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clLinkProgram", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clUnloadPlatformCompiler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clUnloadPlatformCompiler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clUnloadPlatformCompiler(cl_platform_id)
     * }
     */
    public static FunctionDescriptor clUnloadPlatformCompiler$descriptor() {
        return clUnloadPlatformCompiler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clUnloadPlatformCompiler(cl_platform_id)
     * }
     */
    public static MethodHandle clUnloadPlatformCompiler$handle() {
        return clUnloadPlatformCompiler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clUnloadPlatformCompiler(cl_platform_id)
     * }
     */
    public static MemorySegment clUnloadPlatformCompiler$address() {
        return clUnloadPlatformCompiler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clUnloadPlatformCompiler(cl_platform_id)
     * }
     */
    public static int clUnloadPlatformCompiler(MemorySegment x0) {
        var mh$ = clUnloadPlatformCompiler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clUnloadPlatformCompiler", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetProgramInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetProgramInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetProgramInfo(cl_program, cl_program_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetProgramInfo$descriptor() {
        return clGetProgramInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetProgramInfo(cl_program, cl_program_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetProgramInfo$handle() {
        return clGetProgramInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetProgramInfo(cl_program, cl_program_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetProgramInfo$address() {
        return clGetProgramInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetProgramInfo(cl_program, cl_program_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetProgramInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetProgramInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetProgramInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetProgramBuildInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetProgramBuildInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetProgramBuildInfo(cl_program, cl_device_id, cl_program_build_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetProgramBuildInfo$descriptor() {
        return clGetProgramBuildInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetProgramBuildInfo(cl_program, cl_device_id, cl_program_build_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetProgramBuildInfo$handle() {
        return clGetProgramBuildInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetProgramBuildInfo(cl_program, cl_device_id, cl_program_build_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetProgramBuildInfo$address() {
        return clGetProgramBuildInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetProgramBuildInfo(cl_program, cl_device_id, cl_program_build_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetProgramBuildInfo(MemorySegment x0, MemorySegment x1, int x2, long x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clGetProgramBuildInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetProgramBuildInfo", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateKernel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_kernel clCreateKernel(cl_program, const char *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateKernel$descriptor() {
        return clCreateKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_kernel clCreateKernel(cl_program, const char *, cl_int *)
     * }
     */
    public static MethodHandle clCreateKernel$handle() {
        return clCreateKernel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_kernel clCreateKernel(cl_program, const char *, cl_int *)
     * }
     */
    public static MemorySegment clCreateKernel$address() {
        return clCreateKernel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_kernel clCreateKernel(cl_program, const char *, cl_int *)
     * }
     */
    public static MemorySegment clCreateKernel(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = clCreateKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateKernel", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateKernelsInProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateKernelsInProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCreateKernelsInProgram(cl_program, cl_uint, cl_kernel *, cl_uint *)
     * }
     */
    public static FunctionDescriptor clCreateKernelsInProgram$descriptor() {
        return clCreateKernelsInProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCreateKernelsInProgram(cl_program, cl_uint, cl_kernel *, cl_uint *)
     * }
     */
    public static MethodHandle clCreateKernelsInProgram$handle() {
        return clCreateKernelsInProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clCreateKernelsInProgram(cl_program, cl_uint, cl_kernel *, cl_uint *)
     * }
     */
    public static MemorySegment clCreateKernelsInProgram$address() {
        return clCreateKernelsInProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clCreateKernelsInProgram(cl_program, cl_uint, cl_kernel *, cl_uint *)
     * }
     */
    public static int clCreateKernelsInProgram(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = clCreateKernelsInProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateKernelsInProgram", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clRetainKernel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainKernel(cl_kernel)
     * }
     */
    public static FunctionDescriptor clRetainKernel$descriptor() {
        return clRetainKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainKernel(cl_kernel)
     * }
     */
    public static MethodHandle clRetainKernel$handle() {
        return clRetainKernel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clRetainKernel(cl_kernel)
     * }
     */
    public static MemorySegment clRetainKernel$address() {
        return clRetainKernel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clRetainKernel(cl_kernel)
     * }
     */
    public static int clRetainKernel(MemorySegment x0) {
        var mh$ = clRetainKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainKernel", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clReleaseKernel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseKernel(cl_kernel)
     * }
     */
    public static FunctionDescriptor clReleaseKernel$descriptor() {
        return clReleaseKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseKernel(cl_kernel)
     * }
     */
    public static MethodHandle clReleaseKernel$handle() {
        return clReleaseKernel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clReleaseKernel(cl_kernel)
     * }
     */
    public static MemorySegment clReleaseKernel$address() {
        return clReleaseKernel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseKernel(cl_kernel)
     * }
     */
    public static int clReleaseKernel(MemorySegment x0) {
        var mh$ = clReleaseKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseKernel", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetKernelArg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clSetKernelArg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArg(cl_kernel, cl_uint, size_t, const void *)
     * }
     */
    public static FunctionDescriptor clSetKernelArg$descriptor() {
        return clSetKernelArg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArg(cl_kernel, cl_uint, size_t, const void *)
     * }
     */
    public static MethodHandle clSetKernelArg$handle() {
        return clSetKernelArg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArg(cl_kernel, cl_uint, size_t, const void *)
     * }
     */
    public static MemorySegment clSetKernelArg$address() {
        return clSetKernelArg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clSetKernelArg(cl_kernel, cl_uint, size_t, const void *)
     * }
     */
    public static int clSetKernelArg(MemorySegment x0, int x1, long x2, MemorySegment x3) {
        var mh$ = clSetKernelArg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetKernelArg", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetKernelInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetKernelInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelInfo(cl_kernel, cl_kernel_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetKernelInfo$descriptor() {
        return clGetKernelInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelInfo(cl_kernel, cl_kernel_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetKernelInfo$handle() {
        return clGetKernelInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelInfo(cl_kernel, cl_kernel_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetKernelInfo$address() {
        return clGetKernelInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetKernelInfo(cl_kernel, cl_kernel_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetKernelInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetKernelInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetKernelInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetKernelArgInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetKernelArgInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelArgInfo(cl_kernel, cl_uint, cl_kernel_arg_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetKernelArgInfo$descriptor() {
        return clGetKernelArgInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelArgInfo(cl_kernel, cl_uint, cl_kernel_arg_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetKernelArgInfo$handle() {
        return clGetKernelArgInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelArgInfo(cl_kernel, cl_uint, cl_kernel_arg_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetKernelArgInfo$address() {
        return clGetKernelArgInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetKernelArgInfo(cl_kernel, cl_uint, cl_kernel_arg_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetKernelArgInfo(MemorySegment x0, int x1, int x2, long x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clGetKernelArgInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetKernelArgInfo", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetKernelWorkGroupInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetKernelWorkGroupInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelWorkGroupInfo(cl_kernel, cl_device_id, cl_kernel_work_group_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetKernelWorkGroupInfo$descriptor() {
        return clGetKernelWorkGroupInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelWorkGroupInfo(cl_kernel, cl_device_id, cl_kernel_work_group_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetKernelWorkGroupInfo$handle() {
        return clGetKernelWorkGroupInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelWorkGroupInfo(cl_kernel, cl_device_id, cl_kernel_work_group_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetKernelWorkGroupInfo$address() {
        return clGetKernelWorkGroupInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetKernelWorkGroupInfo(cl_kernel, cl_device_id, cl_kernel_work_group_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetKernelWorkGroupInfo(MemorySegment x0, MemorySegment x1, int x2, long x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clGetKernelWorkGroupInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetKernelWorkGroupInfo", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clWaitForEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clWaitForEvents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clWaitForEvents(cl_uint, const cl_event *)
     * }
     */
    public static FunctionDescriptor clWaitForEvents$descriptor() {
        return clWaitForEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clWaitForEvents(cl_uint, const cl_event *)
     * }
     */
    public static MethodHandle clWaitForEvents$handle() {
        return clWaitForEvents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clWaitForEvents(cl_uint, const cl_event *)
     * }
     */
    public static MemorySegment clWaitForEvents$address() {
        return clWaitForEvents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clWaitForEvents(cl_uint, const cl_event *)
     * }
     */
    public static int clWaitForEvents(int x0, MemorySegment x1) {
        var mh$ = clWaitForEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clWaitForEvents", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetEventInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetEventInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetEventInfo(cl_event, cl_event_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetEventInfo$descriptor() {
        return clGetEventInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetEventInfo(cl_event, cl_event_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetEventInfo$handle() {
        return clGetEventInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetEventInfo(cl_event, cl_event_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetEventInfo$address() {
        return clGetEventInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetEventInfo(cl_event, cl_event_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetEventInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetEventInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetEventInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateUserEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateUserEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_event clCreateUserEvent(cl_context, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateUserEvent$descriptor() {
        return clCreateUserEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_event clCreateUserEvent(cl_context, cl_int *)
     * }
     */
    public static MethodHandle clCreateUserEvent$handle() {
        return clCreateUserEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_event clCreateUserEvent(cl_context, cl_int *)
     * }
     */
    public static MemorySegment clCreateUserEvent$address() {
        return clCreateUserEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_event clCreateUserEvent(cl_context, cl_int *)
     * }
     */
    public static MemorySegment clCreateUserEvent(MemorySegment x0, MemorySegment x1) {
        var mh$ = clCreateUserEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateUserEvent", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clRetainEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainEvent(cl_event)
     * }
     */
    public static FunctionDescriptor clRetainEvent$descriptor() {
        return clRetainEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainEvent(cl_event)
     * }
     */
    public static MethodHandle clRetainEvent$handle() {
        return clRetainEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clRetainEvent(cl_event)
     * }
     */
    public static MemorySegment clRetainEvent$address() {
        return clRetainEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clRetainEvent(cl_event)
     * }
     */
    public static int clRetainEvent(MemorySegment x0) {
        var mh$ = clRetainEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainEvent", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clReleaseEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseEvent(cl_event)
     * }
     */
    public static FunctionDescriptor clReleaseEvent$descriptor() {
        return clReleaseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseEvent(cl_event)
     * }
     */
    public static MethodHandle clReleaseEvent$handle() {
        return clReleaseEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clReleaseEvent(cl_event)
     * }
     */
    public static MemorySegment clReleaseEvent$address() {
        return clReleaseEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseEvent(cl_event)
     * }
     */
    public static int clReleaseEvent(MemorySegment x0) {
        var mh$ = clReleaseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseEvent", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetUserEventStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clSetUserEventStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetUserEventStatus(cl_event, cl_int)
     * }
     */
    public static FunctionDescriptor clSetUserEventStatus$descriptor() {
        return clSetUserEventStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetUserEventStatus(cl_event, cl_int)
     * }
     */
    public static MethodHandle clSetUserEventStatus$handle() {
        return clSetUserEventStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clSetUserEventStatus(cl_event, cl_int)
     * }
     */
    public static MemorySegment clSetUserEventStatus$address() {
        return clSetUserEventStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clSetUserEventStatus(cl_event, cl_int)
     * }
     */
    public static int clSetUserEventStatus(MemorySegment x0, int x1) {
        var mh$ = clSetUserEventStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetUserEventStatus", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetEventCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clSetEventCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetEventCallback(cl_event, cl_int, void (*)(cl_event, cl_int, void *), void *)
     * }
     */
    public static FunctionDescriptor clSetEventCallback$descriptor() {
        return clSetEventCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetEventCallback(cl_event, cl_int, void (*)(cl_event, cl_int, void *), void *)
     * }
     */
    public static MethodHandle clSetEventCallback$handle() {
        return clSetEventCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clSetEventCallback(cl_event, cl_int, void (*)(cl_event, cl_int, void *), void *)
     * }
     */
    public static MemorySegment clSetEventCallback$address() {
        return clSetEventCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clSetEventCallback(cl_event, cl_int, void (*)(cl_event, cl_int, void *), void *)
     * }
     */
    public static int clSetEventCallback(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = clSetEventCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetEventCallback", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetEventProfilingInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetEventProfilingInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetEventProfilingInfo(cl_event, cl_profiling_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetEventProfilingInfo$descriptor() {
        return clGetEventProfilingInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetEventProfilingInfo(cl_event, cl_profiling_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetEventProfilingInfo$handle() {
        return clGetEventProfilingInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetEventProfilingInfo(cl_event, cl_profiling_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetEventProfilingInfo$address() {
        return clGetEventProfilingInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetEventProfilingInfo(cl_event, cl_profiling_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetEventProfilingInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetEventProfilingInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetEventProfilingInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clFlush(cl_command_queue)
     * }
     */
    public static FunctionDescriptor clFlush$descriptor() {
        return clFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clFlush(cl_command_queue)
     * }
     */
    public static MethodHandle clFlush$handle() {
        return clFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clFlush(cl_command_queue)
     * }
     */
    public static MemorySegment clFlush$address() {
        return clFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clFlush(cl_command_queue)
     * }
     */
    public static int clFlush(MemorySegment x0) {
        var mh$ = clFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clFlush", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clFinish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clFinish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clFinish(cl_command_queue)
     * }
     */
    public static FunctionDescriptor clFinish$descriptor() {
        return clFinish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clFinish(cl_command_queue)
     * }
     */
    public static MethodHandle clFinish$handle() {
        return clFinish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clFinish(cl_command_queue)
     * }
     */
    public static MemorySegment clFinish$address() {
        return clFinish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clFinish(cl_command_queue)
     * }
     */
    public static int clFinish(MemorySegment x0) {
        var mh$ = clFinish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clFinish", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueReadBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBuffer(cl_command_queue, cl_mem, cl_bool, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueReadBuffer$descriptor() {
        return clEnqueueReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBuffer(cl_command_queue, cl_mem, cl_bool, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueReadBuffer$handle() {
        return clEnqueueReadBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBuffer(cl_command_queue, cl_mem, cl_bool, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueReadBuffer$address() {
        return clEnqueueReadBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBuffer(cl_command_queue, cl_mem, cl_bool, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueReadBuffer(MemorySegment x0, MemorySegment x1, int x2, long x3, long x4, MemorySegment x5, int x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = clEnqueueReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReadBuffer", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReadBufferRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueReadBufferRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBufferRect(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueReadBufferRect$descriptor() {
        return clEnqueueReadBufferRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBufferRect(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueReadBufferRect$handle() {
        return clEnqueueReadBufferRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBufferRect(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueReadBufferRect$address() {
        return clEnqueueReadBufferRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBufferRect(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueReadBufferRect(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, long x6, long x7, long x8, long x9, MemorySegment x10, int x11, MemorySegment x12, MemorySegment x13) {
        var mh$ = clEnqueueReadBufferRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReadBufferRect", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueWriteBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueWriteBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBuffer(cl_command_queue, cl_mem, cl_bool, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueWriteBuffer$descriptor() {
        return clEnqueueWriteBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBuffer(cl_command_queue, cl_mem, cl_bool, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueWriteBuffer$handle() {
        return clEnqueueWriteBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBuffer(cl_command_queue, cl_mem, cl_bool, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueWriteBuffer$address() {
        return clEnqueueWriteBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBuffer(cl_command_queue, cl_mem, cl_bool, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueWriteBuffer(MemorySegment x0, MemorySegment x1, int x2, long x3, long x4, MemorySegment x5, int x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = clEnqueueWriteBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueWriteBuffer", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueWriteBufferRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueWriteBufferRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBufferRect(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueWriteBufferRect$descriptor() {
        return clEnqueueWriteBufferRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBufferRect(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueWriteBufferRect$handle() {
        return clEnqueueWriteBufferRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBufferRect(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueWriteBufferRect$address() {
        return clEnqueueWriteBufferRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBufferRect(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueWriteBufferRect(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, long x6, long x7, long x8, long x9, MemorySegment x10, int x11, MemorySegment x12, MemorySegment x13) {
        var mh$ = clEnqueueWriteBufferRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueWriteBufferRect", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueFillBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueFillBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillBuffer(cl_command_queue, cl_mem, const void *, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueFillBuffer$descriptor() {
        return clEnqueueFillBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillBuffer(cl_command_queue, cl_mem, const void *, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueFillBuffer$handle() {
        return clEnqueueFillBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillBuffer(cl_command_queue, cl_mem, const void *, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueFillBuffer$address() {
        return clEnqueueFillBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillBuffer(cl_command_queue, cl_mem, const void *, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueFillBuffer(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, long x4, long x5, int x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = clEnqueueFillBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueFillBuffer", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCopyBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueCopyBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBuffer(cl_command_queue, cl_mem, cl_mem, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueCopyBuffer$descriptor() {
        return clEnqueueCopyBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBuffer(cl_command_queue, cl_mem, cl_mem, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueCopyBuffer$handle() {
        return clEnqueueCopyBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBuffer(cl_command_queue, cl_mem, cl_mem, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueCopyBuffer$address() {
        return clEnqueueCopyBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBuffer(cl_command_queue, cl_mem, cl_mem, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueCopyBuffer(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, long x4, long x5, int x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = clEnqueueCopyBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCopyBuffer", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCopyBufferRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueCopyBufferRect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferRect(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueCopyBufferRect$descriptor() {
        return clEnqueueCopyBufferRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferRect(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueCopyBufferRect$handle() {
        return clEnqueueCopyBufferRect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferRect(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueCopyBufferRect$address() {
        return clEnqueueCopyBufferRect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferRect(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, const size_t *, size_t, size_t, size_t, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueCopyBufferRect(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, long x6, long x7, long x8, long x9, int x10, MemorySegment x11, MemorySegment x12) {
        var mh$ = clEnqueueCopyBufferRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCopyBufferRect", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReadImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueReadImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadImage(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueReadImage$descriptor() {
        return clEnqueueReadImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadImage(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueReadImage$handle() {
        return clEnqueueReadImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadImage(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueReadImage$address() {
        return clEnqueueReadImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadImage(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, size_t, size_t, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueReadImage(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, long x5, long x6, MemorySegment x7, int x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = clEnqueueReadImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReadImage", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueWriteImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueWriteImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteImage(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueWriteImage$descriptor() {
        return clEnqueueWriteImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteImage(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueWriteImage$handle() {
        return clEnqueueWriteImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteImage(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueWriteImage$address() {
        return clEnqueueWriteImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteImage(cl_command_queue, cl_mem, cl_bool, const size_t *, const size_t *, size_t, size_t, const void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueWriteImage(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, long x5, long x6, MemorySegment x7, int x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = clEnqueueWriteImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueWriteImage", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueFillImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueFillImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillImage(cl_command_queue, cl_mem, const void *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueFillImage$descriptor() {
        return clEnqueueFillImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillImage(cl_command_queue, cl_mem, const void *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueFillImage$handle() {
        return clEnqueueFillImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillImage(cl_command_queue, cl_mem, const void *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueFillImage$address() {
        return clEnqueueFillImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillImage(cl_command_queue, cl_mem, const void *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueFillImage(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, int x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = clEnqueueFillImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueFillImage", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCopyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueCopyImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImage(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueCopyImage$descriptor() {
        return clEnqueueCopyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImage(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueCopyImage$handle() {
        return clEnqueueCopyImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImage(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueCopyImage$address() {
        return clEnqueueCopyImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImage(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueCopyImage(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = clEnqueueCopyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCopyImage", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCopyImageToBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueCopyImageToBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImageToBuffer(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueCopyImageToBuffer$descriptor() {
        return clEnqueueCopyImageToBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImageToBuffer(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueCopyImageToBuffer$handle() {
        return clEnqueueCopyImageToBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImageToBuffer(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueCopyImageToBuffer$address() {
        return clEnqueueCopyImageToBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImageToBuffer(cl_command_queue, cl_mem, cl_mem, const size_t *, const size_t *, size_t, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueCopyImageToBuffer(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5, int x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = clEnqueueCopyImageToBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCopyImageToBuffer", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCopyBufferToImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueCopyBufferToImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferToImage(cl_command_queue, cl_mem, cl_mem, size_t, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueCopyBufferToImage$descriptor() {
        return clEnqueueCopyBufferToImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferToImage(cl_command_queue, cl_mem, cl_mem, size_t, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueCopyBufferToImage$handle() {
        return clEnqueueCopyBufferToImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferToImage(cl_command_queue, cl_mem, cl_mem, size_t, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueCopyBufferToImage$address() {
        return clEnqueueCopyBufferToImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferToImage(cl_command_queue, cl_mem, cl_mem, size_t, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueCopyBufferToImage(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, MemorySegment x4, MemorySegment x5, int x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = clEnqueueCopyBufferToImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCopyBufferToImage", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMapBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueMapBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clEnqueueMapBuffer(cl_command_queue, cl_mem, cl_bool, cl_map_flags, size_t, size_t, cl_uint, const cl_event *, cl_event *, cl_int *)
     * }
     */
    public static FunctionDescriptor clEnqueueMapBuffer$descriptor() {
        return clEnqueueMapBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clEnqueueMapBuffer(cl_command_queue, cl_mem, cl_bool, cl_map_flags, size_t, size_t, cl_uint, const cl_event *, cl_event *, cl_int *)
     * }
     */
    public static MethodHandle clEnqueueMapBuffer$handle() {
        return clEnqueueMapBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *clEnqueueMapBuffer(cl_command_queue, cl_mem, cl_bool, cl_map_flags, size_t, size_t, cl_uint, const cl_event *, cl_event *, cl_int *)
     * }
     */
    public static MemorySegment clEnqueueMapBuffer$address() {
        return clEnqueueMapBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *clEnqueueMapBuffer(cl_command_queue, cl_mem, cl_bool, cl_map_flags, size_t, size_t, cl_uint, const cl_event *, cl_event *, cl_int *)
     * }
     */
    public static MemorySegment clEnqueueMapBuffer(MemorySegment x0, MemorySegment x1, int x2, long x3, long x4, long x5, int x6, MemorySegment x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = clEnqueueMapBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMapBuffer", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMapImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueMapImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clEnqueueMapImage(cl_command_queue, cl_mem, cl_bool, cl_map_flags, const size_t *, const size_t *, size_t *, size_t *, cl_uint, const cl_event *, cl_event *, cl_int *)
     * }
     */
    public static FunctionDescriptor clEnqueueMapImage$descriptor() {
        return clEnqueueMapImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clEnqueueMapImage(cl_command_queue, cl_mem, cl_bool, cl_map_flags, const size_t *, const size_t *, size_t *, size_t *, cl_uint, const cl_event *, cl_event *, cl_int *)
     * }
     */
    public static MethodHandle clEnqueueMapImage$handle() {
        return clEnqueueMapImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *clEnqueueMapImage(cl_command_queue, cl_mem, cl_bool, cl_map_flags, const size_t *, const size_t *, size_t *, size_t *, cl_uint, const cl_event *, cl_event *, cl_int *)
     * }
     */
    public static MemorySegment clEnqueueMapImage$address() {
        return clEnqueueMapImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *clEnqueueMapImage(cl_command_queue, cl_mem, cl_bool, cl_map_flags, const size_t *, const size_t *, size_t *, size_t *, cl_uint, const cl_event *, cl_event *, cl_int *)
     * }
     */
    public static MemorySegment clEnqueueMapImage(MemorySegment x0, MemorySegment x1, int x2, long x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, int x8, MemorySegment x9, MemorySegment x10, MemorySegment x11) {
        var mh$ = clEnqueueMapImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMapImage", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueUnmapMemObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueUnmapMemObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueUnmapMemObject(cl_command_queue, cl_mem, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueUnmapMemObject$descriptor() {
        return clEnqueueUnmapMemObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueUnmapMemObject(cl_command_queue, cl_mem, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueUnmapMemObject$handle() {
        return clEnqueueUnmapMemObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueUnmapMemObject(cl_command_queue, cl_mem, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueUnmapMemObject$address() {
        return clEnqueueUnmapMemObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueUnmapMemObject(cl_command_queue, cl_mem, void *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueUnmapMemObject(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clEnqueueUnmapMemObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueUnmapMemObject", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMigrateMemObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueMigrateMemObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemObjects(cl_command_queue, cl_uint, const cl_mem *, cl_mem_migration_flags, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueMigrateMemObjects$descriptor() {
        return clEnqueueMigrateMemObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemObjects(cl_command_queue, cl_uint, const cl_mem *, cl_mem_migration_flags, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueMigrateMemObjects$handle() {
        return clEnqueueMigrateMemObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemObjects(cl_command_queue, cl_uint, const cl_mem *, cl_mem_migration_flags, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueMigrateMemObjects$address() {
        return clEnqueueMigrateMemObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemObjects(cl_command_queue, cl_uint, const cl_mem *, cl_mem_migration_flags, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueMigrateMemObjects(MemorySegment x0, int x1, MemorySegment x2, long x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = clEnqueueMigrateMemObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMigrateMemObjects", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueNDRangeKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueNDRangeKernel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueNDRangeKernel(cl_command_queue, cl_kernel, cl_uint, const size_t *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueNDRangeKernel$descriptor() {
        return clEnqueueNDRangeKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueNDRangeKernel(cl_command_queue, cl_kernel, cl_uint, const size_t *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueNDRangeKernel$handle() {
        return clEnqueueNDRangeKernel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueNDRangeKernel(cl_command_queue, cl_kernel, cl_uint, const size_t *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueNDRangeKernel$address() {
        return clEnqueueNDRangeKernel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueNDRangeKernel(cl_command_queue, cl_kernel, cl_uint, const size_t *, const size_t *, const size_t *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueNDRangeKernel(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6, MemorySegment x7, MemorySegment x8) {
        var mh$ = clEnqueueNDRangeKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueNDRangeKernel", x0, x1, x2, x3, x4, x5, x6, x7, x8);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueTask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueTask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueTask(cl_command_queue, cl_kernel, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueTask$descriptor() {
        return clEnqueueTask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueTask(cl_command_queue, cl_kernel, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueTask$handle() {
        return clEnqueueTask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueTask(cl_command_queue, cl_kernel, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueTask$address() {
        return clEnqueueTask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueTask(cl_command_queue, cl_kernel, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueTask(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clEnqueueTask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueTask", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueNativeKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueNativeKernel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueNativeKernel(cl_command_queue, void (*)(void *), void *, size_t, cl_uint, const cl_mem *, const void **, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueNativeKernel$descriptor() {
        return clEnqueueNativeKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueNativeKernel(cl_command_queue, void (*)(void *), void *, size_t, cl_uint, const cl_mem *, const void **, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueNativeKernel$handle() {
        return clEnqueueNativeKernel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueNativeKernel(cl_command_queue, void (*)(void *), void *, size_t, cl_uint, const cl_mem *, const void **, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueNativeKernel$address() {
        return clEnqueueNativeKernel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueNativeKernel(cl_command_queue, void (*)(void *), void *, size_t, cl_uint, const cl_mem *, const void **, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueNativeKernel(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4, MemorySegment x5, MemorySegment x6, int x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = clEnqueueNativeKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueNativeKernel", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMarkerWithWaitList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueMarkerWithWaitList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarkerWithWaitList(cl_command_queue, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueMarkerWithWaitList$descriptor() {
        return clEnqueueMarkerWithWaitList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarkerWithWaitList(cl_command_queue, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueMarkerWithWaitList$handle() {
        return clEnqueueMarkerWithWaitList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarkerWithWaitList(cl_command_queue, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueMarkerWithWaitList$address() {
        return clEnqueueMarkerWithWaitList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarkerWithWaitList(cl_command_queue, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueMarkerWithWaitList(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = clEnqueueMarkerWithWaitList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMarkerWithWaitList", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueBarrierWithWaitList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueBarrierWithWaitList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrierWithWaitList(cl_command_queue, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueBarrierWithWaitList$descriptor() {
        return clEnqueueBarrierWithWaitList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrierWithWaitList(cl_command_queue, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueBarrierWithWaitList$handle() {
        return clEnqueueBarrierWithWaitList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrierWithWaitList(cl_command_queue, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueBarrierWithWaitList$address() {
        return clEnqueueBarrierWithWaitList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrierWithWaitList(cl_command_queue, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueBarrierWithWaitList(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = clEnqueueBarrierWithWaitList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueBarrierWithWaitList", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetExtensionFunctionAddressForPlatform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetExtensionFunctionAddressForPlatform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddressForPlatform(cl_platform_id, const char *)
     * }
     */
    public static FunctionDescriptor clGetExtensionFunctionAddressForPlatform$descriptor() {
        return clGetExtensionFunctionAddressForPlatform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddressForPlatform(cl_platform_id, const char *)
     * }
     */
    public static MethodHandle clGetExtensionFunctionAddressForPlatform$handle() {
        return clGetExtensionFunctionAddressForPlatform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddressForPlatform(cl_platform_id, const char *)
     * }
     */
    public static MemorySegment clGetExtensionFunctionAddressForPlatform$address() {
        return clGetExtensionFunctionAddressForPlatform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddressForPlatform(cl_platform_id, const char *)
     * }
     */
    public static MemorySegment clGetExtensionFunctionAddressForPlatform(MemorySegment x0, MemorySegment x1) {
        var mh$ = clGetExtensionFunctionAddressForPlatform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetExtensionFunctionAddressForPlatform", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage2D(cl_context, cl_mem_flags, const cl_image_format *, size_t, size_t, size_t, void *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateImage2D$descriptor() {
        return clCreateImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage2D(cl_context, cl_mem_flags, const cl_image_format *, size_t, size_t, size_t, void *, cl_int *)
     * }
     */
    public static MethodHandle clCreateImage2D$handle() {
        return clCreateImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage2D(cl_context, cl_mem_flags, const cl_image_format *, size_t, size_t, size_t, void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateImage2D$address() {
        return clCreateImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateImage2D(cl_context, cl_mem_flags, const cl_image_format *, size_t, size_t, size_t, void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateImage2D(MemorySegment x0, long x1, MemorySegment x2, long x3, long x4, long x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = clCreateImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateImage2D", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage3D(cl_context, cl_mem_flags, const cl_image_format *, size_t, size_t, size_t, size_t, size_t, void *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateImage3D$descriptor() {
        return clCreateImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage3D(cl_context, cl_mem_flags, const cl_image_format *, size_t, size_t, size_t, size_t, size_t, void *, cl_int *)
     * }
     */
    public static MethodHandle clCreateImage3D$handle() {
        return clCreateImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage3D(cl_context, cl_mem_flags, const cl_image_format *, size_t, size_t, size_t, size_t, size_t, void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateImage3D$address() {
        return clCreateImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateImage3D(cl_context, cl_mem_flags, const cl_image_format *, size_t, size_t, size_t, size_t, size_t, void *, cl_int *)
     * }
     */
    public static MemorySegment clCreateImage3D(MemorySegment x0, long x1, MemorySegment x2, long x3, long x4, long x5, long x6, long x7, MemorySegment x8, MemorySegment x9) {
        var mh$ = clCreateImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateImage3D", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMarker {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueMarker");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarker(cl_command_queue, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueMarker$descriptor() {
        return clEnqueueMarker.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarker(cl_command_queue, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueMarker$handle() {
        return clEnqueueMarker.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarker(cl_command_queue, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueMarker$address() {
        return clEnqueueMarker.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarker(cl_command_queue, cl_event *)
     * }
     */
    public static int clEnqueueMarker(MemorySegment x0, MemorySegment x1) {
        var mh$ = clEnqueueMarker.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMarker", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueWaitForEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueWaitForEvents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWaitForEvents(cl_command_queue, cl_uint, const cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueWaitForEvents$descriptor() {
        return clEnqueueWaitForEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWaitForEvents(cl_command_queue, cl_uint, const cl_event *)
     * }
     */
    public static MethodHandle clEnqueueWaitForEvents$handle() {
        return clEnqueueWaitForEvents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWaitForEvents(cl_command_queue, cl_uint, const cl_event *)
     * }
     */
    public static MemorySegment clEnqueueWaitForEvents$address() {
        return clEnqueueWaitForEvents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueWaitForEvents(cl_command_queue, cl_uint, const cl_event *)
     * }
     */
    public static int clEnqueueWaitForEvents(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = clEnqueueWaitForEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueWaitForEvents", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrier(cl_command_queue)
     * }
     */
    public static FunctionDescriptor clEnqueueBarrier$descriptor() {
        return clEnqueueBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrier(cl_command_queue)
     * }
     */
    public static MethodHandle clEnqueueBarrier$handle() {
        return clEnqueueBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrier(cl_command_queue)
     * }
     */
    public static MemorySegment clEnqueueBarrier$address() {
        return clEnqueueBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrier(cl_command_queue)
     * }
     */
    public static int clEnqueueBarrier(MemorySegment x0) {
        var mh$ = clEnqueueBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueBarrier", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clUnloadCompiler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clUnloadCompiler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clUnloadCompiler()
     * }
     */
    public static FunctionDescriptor clUnloadCompiler$descriptor() {
        return clUnloadCompiler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clUnloadCompiler()
     * }
     */
    public static MethodHandle clUnloadCompiler$handle() {
        return clUnloadCompiler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clUnloadCompiler()
     * }
     */
    public static MemorySegment clUnloadCompiler$address() {
        return clUnloadCompiler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clUnloadCompiler()
     * }
     */
    public static int clUnloadCompiler() {
        var mh$ = clUnloadCompiler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clUnloadCompiler");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetExtensionFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetExtensionFunctionAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddress(const char *)
     * }
     */
    public static FunctionDescriptor clGetExtensionFunctionAddress$descriptor() {
        return clGetExtensionFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddress(const char *)
     * }
     */
    public static MethodHandle clGetExtensionFunctionAddress$handle() {
        return clGetExtensionFunctionAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddress(const char *)
     * }
     */
    public static MemorySegment clGetExtensionFunctionAddress$address() {
        return clGetExtensionFunctionAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddress(const char *)
     * }
     */
    public static MemorySegment clGetExtensionFunctionAddress(MemorySegment x0) {
        var mh$ = clGetExtensionFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetExtensionFunctionAddress", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_gl_object_type
     * }
     */
    public static final OfInt cl_gl_object_type = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_gl_texture_info
     * }
     */
    public static final OfInt cl_gl_texture_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_gl_platform_info
     * }
     */
    public static final OfInt cl_gl_platform_info = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct __GLsync *cl_GLsync
     * }
     */
    public static final AddressLayout cl_GLsync = opencl_h.C_POINTER;

    private static class clCreateFromGLBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateFromGLBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLBuffer(cl_context, cl_mem_flags, cl_GLuint, int *)
     * }
     */
    public static FunctionDescriptor clCreateFromGLBuffer$descriptor() {
        return clCreateFromGLBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLBuffer(cl_context, cl_mem_flags, cl_GLuint, int *)
     * }
     */
    public static MethodHandle clCreateFromGLBuffer$handle() {
        return clCreateFromGLBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLBuffer(cl_context, cl_mem_flags, cl_GLuint, int *)
     * }
     */
    public static MemorySegment clCreateFromGLBuffer$address() {
        return clCreateFromGLBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLBuffer(cl_context, cl_mem_flags, cl_GLuint, int *)
     * }
     */
    public static MemorySegment clCreateFromGLBuffer(MemorySegment x0, long x1, int x2, MemorySegment x3) {
        var mh$ = clCreateFromGLBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateFromGLBuffer", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateFromGLTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateFromGLTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateFromGLTexture$descriptor() {
        return clCreateFromGLTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static MethodHandle clCreateFromGLTexture$handle() {
        return clCreateFromGLTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static MemorySegment clCreateFromGLTexture$address() {
        return clCreateFromGLTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static MemorySegment clCreateFromGLTexture(MemorySegment x0, long x1, int x2, int x3, int x4, MemorySegment x5) {
        var mh$ = clCreateFromGLTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateFromGLTexture", x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateFromGLRenderbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateFromGLRenderbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLRenderbuffer(cl_context, cl_mem_flags, cl_GLuint, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateFromGLRenderbuffer$descriptor() {
        return clCreateFromGLRenderbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLRenderbuffer(cl_context, cl_mem_flags, cl_GLuint, cl_int *)
     * }
     */
    public static MethodHandle clCreateFromGLRenderbuffer$handle() {
        return clCreateFromGLRenderbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLRenderbuffer(cl_context, cl_mem_flags, cl_GLuint, cl_int *)
     * }
     */
    public static MemorySegment clCreateFromGLRenderbuffer$address() {
        return clCreateFromGLRenderbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLRenderbuffer(cl_context, cl_mem_flags, cl_GLuint, cl_int *)
     * }
     */
    public static MemorySegment clCreateFromGLRenderbuffer(MemorySegment x0, long x1, int x2, MemorySegment x3) {
        var mh$ = clCreateFromGLRenderbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateFromGLRenderbuffer", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetGLObjectInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetGLObjectInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetGLObjectInfo(cl_mem, cl_gl_object_type *, cl_GLuint *)
     * }
     */
    public static FunctionDescriptor clGetGLObjectInfo$descriptor() {
        return clGetGLObjectInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetGLObjectInfo(cl_mem, cl_gl_object_type *, cl_GLuint *)
     * }
     */
    public static MethodHandle clGetGLObjectInfo$handle() {
        return clGetGLObjectInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetGLObjectInfo(cl_mem, cl_gl_object_type *, cl_GLuint *)
     * }
     */
    public static MemorySegment clGetGLObjectInfo$address() {
        return clGetGLObjectInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetGLObjectInfo(cl_mem, cl_gl_object_type *, cl_GLuint *)
     * }
     */
    public static int clGetGLObjectInfo(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = clGetGLObjectInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetGLObjectInfo", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetGLTextureInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetGLTextureInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetGLTextureInfo(cl_mem, cl_gl_texture_info, size_t, void *, size_t *)
     * }
     */
    public static FunctionDescriptor clGetGLTextureInfo$descriptor() {
        return clGetGLTextureInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetGLTextureInfo(cl_mem, cl_gl_texture_info, size_t, void *, size_t *)
     * }
     */
    public static MethodHandle clGetGLTextureInfo$handle() {
        return clGetGLTextureInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clGetGLTextureInfo(cl_mem, cl_gl_texture_info, size_t, void *, size_t *)
     * }
     */
    public static MemorySegment clGetGLTextureInfo$address() {
        return clGetGLTextureInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clGetGLTextureInfo(cl_mem, cl_gl_texture_info, size_t, void *, size_t *)
     * }
     */
    public static int clGetGLTextureInfo(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = clGetGLTextureInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetGLTextureInfo", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueAcquireGLObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueAcquireGLObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireGLObjects(cl_command_queue, cl_uint, const cl_mem *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueAcquireGLObjects$descriptor() {
        return clEnqueueAcquireGLObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireGLObjects(cl_command_queue, cl_uint, const cl_mem *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueAcquireGLObjects$handle() {
        return clEnqueueAcquireGLObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireGLObjects(cl_command_queue, cl_uint, const cl_mem *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueAcquireGLObjects$address() {
        return clEnqueueAcquireGLObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireGLObjects(cl_command_queue, cl_uint, const cl_mem *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueAcquireGLObjects(MemorySegment x0, int x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clEnqueueAcquireGLObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueAcquireGLObjects", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReleaseGLObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clEnqueueReleaseGLObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseGLObjects(cl_command_queue, cl_uint, const cl_mem *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static FunctionDescriptor clEnqueueReleaseGLObjects$descriptor() {
        return clEnqueueReleaseGLObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseGLObjects(cl_command_queue, cl_uint, const cl_mem *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MethodHandle clEnqueueReleaseGLObjects$handle() {
        return clEnqueueReleaseGLObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseGLObjects(cl_command_queue, cl_uint, const cl_mem *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static MemorySegment clEnqueueReleaseGLObjects$address() {
        return clEnqueueReleaseGLObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseGLObjects(cl_command_queue, cl_uint, const cl_mem *, cl_uint, const cl_event *, cl_event *)
     * }
     */
    public static int clEnqueueReleaseGLObjects(MemorySegment x0, int x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clEnqueueReleaseGLObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReleaseGLObjects", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateFromGLTexture2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateFromGLTexture2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture2D(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateFromGLTexture2D$descriptor() {
        return clCreateFromGLTexture2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture2D(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static MethodHandle clCreateFromGLTexture2D$handle() {
        return clCreateFromGLTexture2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture2D(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static MemorySegment clCreateFromGLTexture2D$address() {
        return clCreateFromGLTexture2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture2D(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static MemorySegment clCreateFromGLTexture2D(MemorySegment x0, long x1, int x2, int x3, int x4, MemorySegment x5) {
        var mh$ = clCreateFromGLTexture2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateFromGLTexture2D", x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateFromGLTexture3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateFromGLTexture3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture3D(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateFromGLTexture3D$descriptor() {
        return clCreateFromGLTexture3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture3D(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static MethodHandle clCreateFromGLTexture3D$handle() {
        return clCreateFromGLTexture3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture3D(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static MemorySegment clCreateFromGLTexture3D$address() {
        return clCreateFromGLTexture3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture3D(cl_context, cl_mem_flags, cl_GLenum, cl_GLint, cl_GLuint, cl_int *)
     * }
     */
    public static MemorySegment clCreateFromGLTexture3D(MemorySegment x0, long x1, int x2, int x3, int x4, MemorySegment x5) {
        var mh$ = clCreateFromGLTexture3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateFromGLTexture3D", x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CGLContextObject *CGLContextObj
     * }
     */
    public static final AddressLayout CGLContextObj = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CGLPixelFormatObject *CGLPixelFormatObj
     * }
     */
    public static final AddressLayout CGLPixelFormatObj = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CGLRendererInfoObject *CGLRendererInfoObj
     * }
     */
    public static final AddressLayout CGLRendererInfoObj = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CGLPBufferObject *CGLPBufferObj
     * }
     */
    public static final AddressLayout CGLPBufferObj = opencl_h.C_POINTER;
    private static final int kCGLPFAAllRenderers = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAAllRenderers = 1
     * }
     */
    public static int kCGLPFAAllRenderers() {
        return kCGLPFAAllRenderers;
    }
    private static final int kCGLPFATripleBuffer = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFATripleBuffer = 3
     * }
     */
    public static int kCGLPFATripleBuffer() {
        return kCGLPFATripleBuffer;
    }
    private static final int kCGLPFADoubleBuffer = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFADoubleBuffer = 5
     * }
     */
    public static int kCGLPFADoubleBuffer() {
        return kCGLPFADoubleBuffer;
    }
    private static final int kCGLPFAColorSize = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAColorSize = 8
     * }
     */
    public static int kCGLPFAColorSize() {
        return kCGLPFAColorSize;
    }
    private static final int kCGLPFAAlphaSize = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAAlphaSize = 11
     * }
     */
    public static int kCGLPFAAlphaSize() {
        return kCGLPFAAlphaSize;
    }
    private static final int kCGLPFADepthSize = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFADepthSize = 12
     * }
     */
    public static int kCGLPFADepthSize() {
        return kCGLPFADepthSize;
    }
    private static final int kCGLPFAStencilSize = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAStencilSize = 13
     * }
     */
    public static int kCGLPFAStencilSize() {
        return kCGLPFAStencilSize;
    }
    private static final int kCGLPFAMinimumPolicy = (int)51L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAMinimumPolicy = 51
     * }
     */
    public static int kCGLPFAMinimumPolicy() {
        return kCGLPFAMinimumPolicy;
    }
    private static final int kCGLPFAMaximumPolicy = (int)52L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAMaximumPolicy = 52
     * }
     */
    public static int kCGLPFAMaximumPolicy() {
        return kCGLPFAMaximumPolicy;
    }
    private static final int kCGLPFASampleBuffers = (int)55L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFASampleBuffers = 55
     * }
     */
    public static int kCGLPFASampleBuffers() {
        return kCGLPFASampleBuffers;
    }
    private static final int kCGLPFASamples = (int)56L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFASamples = 56
     * }
     */
    public static int kCGLPFASamples() {
        return kCGLPFASamples;
    }
    private static final int kCGLPFAColorFloat = (int)58L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAColorFloat = 58
     * }
     */
    public static int kCGLPFAColorFloat() {
        return kCGLPFAColorFloat;
    }
    private static final int kCGLPFAMultisample = (int)59L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAMultisample = 59
     * }
     */
    public static int kCGLPFAMultisample() {
        return kCGLPFAMultisample;
    }
    private static final int kCGLPFASupersample = (int)60L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFASupersample = 60
     * }
     */
    public static int kCGLPFASupersample() {
        return kCGLPFASupersample;
    }
    private static final int kCGLPFASampleAlpha = (int)61L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFASampleAlpha = 61
     * }
     */
    public static int kCGLPFASampleAlpha() {
        return kCGLPFASampleAlpha;
    }
    private static final int kCGLPFARendererID = (int)70L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFARendererID = 70
     * }
     */
    public static int kCGLPFARendererID() {
        return kCGLPFARendererID;
    }
    private static final int kCGLPFANoRecovery = (int)72L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFANoRecovery = 72
     * }
     */
    public static int kCGLPFANoRecovery() {
        return kCGLPFANoRecovery;
    }
    private static final int kCGLPFAAccelerated = (int)73L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAAccelerated = 73
     * }
     */
    public static int kCGLPFAAccelerated() {
        return kCGLPFAAccelerated;
    }
    private static final int kCGLPFAClosestPolicy = (int)74L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAClosestPolicy = 74
     * }
     */
    public static int kCGLPFAClosestPolicy() {
        return kCGLPFAClosestPolicy;
    }
    private static final int kCGLPFABackingStore = (int)76L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFABackingStore = 76
     * }
     */
    public static int kCGLPFABackingStore() {
        return kCGLPFABackingStore;
    }
    private static final int kCGLPFABackingVolatile = (int)77L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFABackingVolatile = 77
     * }
     */
    public static int kCGLPFABackingVolatile() {
        return kCGLPFABackingVolatile;
    }
    private static final int kCGLPFADisplayMask = (int)84L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFADisplayMask = 84
     * }
     */
    public static int kCGLPFADisplayMask() {
        return kCGLPFADisplayMask;
    }
    private static final int kCGLPFAAllowOfflineRenderers = (int)96L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAAllowOfflineRenderers = 96
     * }
     */
    public static int kCGLPFAAllowOfflineRenderers() {
        return kCGLPFAAllowOfflineRenderers;
    }
    private static final int kCGLPFAAcceleratedCompute = (int)97L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAAcceleratedCompute = 97
     * }
     */
    public static int kCGLPFAAcceleratedCompute() {
        return kCGLPFAAcceleratedCompute;
    }
    private static final int kCGLPFAOpenGLProfile = (int)99L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAOpenGLProfile = 99
     * }
     */
    public static int kCGLPFAOpenGLProfile() {
        return kCGLPFAOpenGLProfile;
    }
    private static final int kCGLPFASupportsAutomaticGraphicsSwitching = (int)101L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFASupportsAutomaticGraphicsSwitching = 101
     * }
     */
    public static int kCGLPFASupportsAutomaticGraphicsSwitching() {
        return kCGLPFASupportsAutomaticGraphicsSwitching;
    }
    private static final int kCGLPFAVirtualScreenCount = (int)128L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAVirtualScreenCount = 128
     * }
     */
    public static int kCGLPFAVirtualScreenCount() {
        return kCGLPFAVirtualScreenCount;
    }
    private static final int kCGLPFAAuxBuffers = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAAuxBuffers = 7
     * }
     */
    public static int kCGLPFAAuxBuffers() {
        return kCGLPFAAuxBuffers;
    }
    private static final int kCGLPFAAccumSize = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAAccumSize = 14
     * }
     */
    public static int kCGLPFAAccumSize() {
        return kCGLPFAAccumSize;
    }
    private static final int kCGLPFAAuxDepthStencil = (int)57L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAAuxDepthStencil = 57
     * }
     */
    public static int kCGLPFAAuxDepthStencil() {
        return kCGLPFAAuxDepthStencil;
    }
    private static final int kCGLPFAStereo = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAStereo = 6
     * }
     */
    public static int kCGLPFAStereo() {
        return kCGLPFAStereo;
    }
    private static final int kCGLPFAOffScreen = (int)53L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAOffScreen = 53
     * }
     */
    public static int kCGLPFAOffScreen() {
        return kCGLPFAOffScreen;
    }
    private static final int kCGLPFAWindow = (int)80L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAWindow = 80
     * }
     */
    public static int kCGLPFAWindow() {
        return kCGLPFAWindow;
    }
    private static final int kCGLPFACompliant = (int)83L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFACompliant = 83
     * }
     */
    public static int kCGLPFACompliant() {
        return kCGLPFACompliant;
    }
    private static final int kCGLPFAPBuffer = (int)90L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAPBuffer = 90
     * }
     */
    public static int kCGLPFAPBuffer() {
        return kCGLPFAPBuffer;
    }
    private static final int kCGLPFARemotePBuffer = (int)91L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFARemotePBuffer = 91
     * }
     */
    public static int kCGLPFARemotePBuffer() {
        return kCGLPFARemotePBuffer;
    }
    private static final int kCGLPFASingleRenderer = (int)71L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFASingleRenderer = 71
     * }
     */
    public static int kCGLPFASingleRenderer() {
        return kCGLPFASingleRenderer;
    }
    private static final int kCGLPFARobust = (int)75L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFARobust = 75
     * }
     */
    public static int kCGLPFARobust() {
        return kCGLPFARobust;
    }
    private static final int kCGLPFAMPSafe = (int)78L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAMPSafe = 78
     * }
     */
    public static int kCGLPFAMPSafe() {
        return kCGLPFAMPSafe;
    }
    private static final int kCGLPFAMultiScreen = (int)81L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAMultiScreen = 81
     * }
     */
    public static int kCGLPFAMultiScreen() {
        return kCGLPFAMultiScreen;
    }
    private static final int kCGLPFAFullScreen = (int)54L;
    /**
     * {@snippet lang=c :
     * enum _CGLPixelFormatAttribute.kCGLPFAFullScreen = 54
     * }
     */
    public static int kCGLPFAFullScreen() {
        return kCGLPFAFullScreen;
    }
    private static final int kCGLRPOffScreen = (int)53L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPOffScreen = 53
     * }
     */
    public static int kCGLRPOffScreen() {
        return kCGLRPOffScreen;
    }
    private static final int kCGLRPRendererID = (int)70L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPRendererID = 70
     * }
     */
    public static int kCGLRPRendererID() {
        return kCGLRPRendererID;
    }
    private static final int kCGLRPAccelerated = (int)73L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPAccelerated = 73
     * }
     */
    public static int kCGLRPAccelerated() {
        return kCGLRPAccelerated;
    }
    private static final int kCGLRPBackingStore = (int)76L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPBackingStore = 76
     * }
     */
    public static int kCGLRPBackingStore() {
        return kCGLRPBackingStore;
    }
    private static final int kCGLRPWindow = (int)80L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPWindow = 80
     * }
     */
    public static int kCGLRPWindow() {
        return kCGLRPWindow;
    }
    private static final int kCGLRPCompliant = (int)83L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPCompliant = 83
     * }
     */
    public static int kCGLRPCompliant() {
        return kCGLRPCompliant;
    }
    private static final int kCGLRPDisplayMask = (int)84L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPDisplayMask = 84
     * }
     */
    public static int kCGLRPDisplayMask() {
        return kCGLRPDisplayMask;
    }
    private static final int kCGLRPBufferModes = (int)100L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPBufferModes = 100
     * }
     */
    public static int kCGLRPBufferModes() {
        return kCGLRPBufferModes;
    }
    private static final int kCGLRPColorModes = (int)103L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPColorModes = 103
     * }
     */
    public static int kCGLRPColorModes() {
        return kCGLRPColorModes;
    }
    private static final int kCGLRPAccumModes = (int)104L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPAccumModes = 104
     * }
     */
    public static int kCGLRPAccumModes() {
        return kCGLRPAccumModes;
    }
    private static final int kCGLRPDepthModes = (int)105L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPDepthModes = 105
     * }
     */
    public static int kCGLRPDepthModes() {
        return kCGLRPDepthModes;
    }
    private static final int kCGLRPStencilModes = (int)106L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPStencilModes = 106
     * }
     */
    public static int kCGLRPStencilModes() {
        return kCGLRPStencilModes;
    }
    private static final int kCGLRPMaxAuxBuffers = (int)107L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPMaxAuxBuffers = 107
     * }
     */
    public static int kCGLRPMaxAuxBuffers() {
        return kCGLRPMaxAuxBuffers;
    }
    private static final int kCGLRPMaxSampleBuffers = (int)108L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPMaxSampleBuffers = 108
     * }
     */
    public static int kCGLRPMaxSampleBuffers() {
        return kCGLRPMaxSampleBuffers;
    }
    private static final int kCGLRPMaxSamples = (int)109L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPMaxSamples = 109
     * }
     */
    public static int kCGLRPMaxSamples() {
        return kCGLRPMaxSamples;
    }
    private static final int kCGLRPSampleModes = (int)110L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPSampleModes = 110
     * }
     */
    public static int kCGLRPSampleModes() {
        return kCGLRPSampleModes;
    }
    private static final int kCGLRPSampleAlpha = (int)111L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPSampleAlpha = 111
     * }
     */
    public static int kCGLRPSampleAlpha() {
        return kCGLRPSampleAlpha;
    }
    private static final int kCGLRPGPUVertProcCapable = (int)122L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPGPUVertProcCapable = 122
     * }
     */
    public static int kCGLRPGPUVertProcCapable() {
        return kCGLRPGPUVertProcCapable;
    }
    private static final int kCGLRPGPUFragProcCapable = (int)123L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPGPUFragProcCapable = 123
     * }
     */
    public static int kCGLRPGPUFragProcCapable() {
        return kCGLRPGPUFragProcCapable;
    }
    private static final int kCGLRPRendererCount = (int)128L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPRendererCount = 128
     * }
     */
    public static int kCGLRPRendererCount() {
        return kCGLRPRendererCount;
    }
    private static final int kCGLRPOnline = (int)129L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPOnline = 129
     * }
     */
    public static int kCGLRPOnline() {
        return kCGLRPOnline;
    }
    private static final int kCGLRPAcceleratedCompute = (int)130L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPAcceleratedCompute = 130
     * }
     */
    public static int kCGLRPAcceleratedCompute() {
        return kCGLRPAcceleratedCompute;
    }
    private static final int kCGLRPVideoMemoryMegabytes = (int)131L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPVideoMemoryMegabytes = 131
     * }
     */
    public static int kCGLRPVideoMemoryMegabytes() {
        return kCGLRPVideoMemoryMegabytes;
    }
    private static final int kCGLRPTextureMemoryMegabytes = (int)132L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPTextureMemoryMegabytes = 132
     * }
     */
    public static int kCGLRPTextureMemoryMegabytes() {
        return kCGLRPTextureMemoryMegabytes;
    }
    private static final int kCGLRPMajorGLVersion = (int)133L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPMajorGLVersion = 133
     * }
     */
    public static int kCGLRPMajorGLVersion() {
        return kCGLRPMajorGLVersion;
    }
    private static final int kCGLRPRegistryIDLow = (int)140L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPRegistryIDLow = 140
     * }
     */
    public static int kCGLRPRegistryIDLow() {
        return kCGLRPRegistryIDLow;
    }
    private static final int kCGLRPRegistryIDHigh = (int)141L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPRegistryIDHigh = 141
     * }
     */
    public static int kCGLRPRegistryIDHigh() {
        return kCGLRPRegistryIDHigh;
    }
    private static final int kCGLRPRemovable = (int)142L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPRemovable = 142
     * }
     */
    public static int kCGLRPRemovable() {
        return kCGLRPRemovable;
    }
    private static final int kCGLRPRobust = (int)75L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPRobust = 75
     * }
     */
    public static int kCGLRPRobust() {
        return kCGLRPRobust;
    }
    private static final int kCGLRPMPSafe = (int)78L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPMPSafe = 78
     * }
     */
    public static int kCGLRPMPSafe() {
        return kCGLRPMPSafe;
    }
    private static final int kCGLRPMultiScreen = (int)81L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPMultiScreen = 81
     * }
     */
    public static int kCGLRPMultiScreen() {
        return kCGLRPMultiScreen;
    }
    private static final int kCGLRPFullScreen = (int)54L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPFullScreen = 54
     * }
     */
    public static int kCGLRPFullScreen() {
        return kCGLRPFullScreen;
    }
    private static final int kCGLRPVideoMemory = (int)120L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPVideoMemory = 120
     * }
     */
    public static int kCGLRPVideoMemory() {
        return kCGLRPVideoMemory;
    }
    private static final int kCGLRPTextureMemory = (int)121L;
    /**
     * {@snippet lang=c :
     * enum _CGLRendererProperty.kCGLRPTextureMemory = 121
     * }
     */
    public static int kCGLRPTextureMemory() {
        return kCGLRPTextureMemory;
    }
    private static final int kCGLCESwapRectangle = (int)201L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextEnable.kCGLCESwapRectangle = 201
     * }
     */
    public static int kCGLCESwapRectangle() {
        return kCGLCESwapRectangle;
    }
    private static final int kCGLCESwapLimit = (int)203L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextEnable.kCGLCESwapLimit = 203
     * }
     */
    public static int kCGLCESwapLimit() {
        return kCGLCESwapLimit;
    }
    private static final int kCGLCERasterization = (int)221L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextEnable.kCGLCERasterization = 221
     * }
     */
    public static int kCGLCERasterization() {
        return kCGLCERasterization;
    }
    private static final int kCGLCEStateValidation = (int)301L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextEnable.kCGLCEStateValidation = 301
     * }
     */
    public static int kCGLCEStateValidation() {
        return kCGLCEStateValidation;
    }
    private static final int kCGLCESurfaceBackingSize = (int)305L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextEnable.kCGLCESurfaceBackingSize = 305
     * }
     */
    public static int kCGLCESurfaceBackingSize() {
        return kCGLCESurfaceBackingSize;
    }
    private static final int kCGLCEDisplayListOptimization = (int)307L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextEnable.kCGLCEDisplayListOptimization = 307
     * }
     */
    public static int kCGLCEDisplayListOptimization() {
        return kCGLCEDisplayListOptimization;
    }
    private static final int kCGLCEMPEngine = (int)313L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextEnable.kCGLCEMPEngine = 313
     * }
     */
    public static int kCGLCEMPEngine() {
        return kCGLCEMPEngine;
    }
    private static final int kCGLCECrashOnRemovedFunctions = (int)316L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextEnable.kCGLCECrashOnRemovedFunctions = 316
     * }
     */
    public static int kCGLCECrashOnRemovedFunctions() {
        return kCGLCECrashOnRemovedFunctions;
    }
    private static final int kCGLCPGPURestartStatusNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _CGLGPURestartStatus.kCGLCPGPURestartStatusNone = 0
     * }
     */
    public static int kCGLCPGPURestartStatusNone() {
        return kCGLCPGPURestartStatusNone;
    }
    private static final int kCGLCPGPURestartStatusCaused = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _CGLGPURestartStatus.kCGLCPGPURestartStatusCaused = 1
     * }
     */
    public static int kCGLCPGPURestartStatusCaused() {
        return kCGLCPGPURestartStatusCaused;
    }
    private static final int kCGLCPGPURestartStatusBlacklisted = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _CGLGPURestartStatus.kCGLCPGPURestartStatusBlacklisted = 2
     * }
     */
    public static int kCGLCPGPURestartStatusBlacklisted() {
        return kCGLCPGPURestartStatusBlacklisted;
    }
    private static final int kCGLCPGPURestartStatusDenied = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _CGLGPURestartStatus.kCGLCPGPURestartStatusDenied = 2
     * }
     */
    public static int kCGLCPGPURestartStatusDenied() {
        return kCGLCPGPURestartStatusDenied;
    }
    private static final int kCGLCPSwapRectangle = (int)200L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPSwapRectangle = 200
     * }
     */
    public static int kCGLCPSwapRectangle() {
        return kCGLCPSwapRectangle;
    }
    private static final int kCGLCPSwapInterval = (int)222L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPSwapInterval = 222
     * }
     */
    public static int kCGLCPSwapInterval() {
        return kCGLCPSwapInterval;
    }
    private static final int kCGLCPDispatchTableSize = (int)224L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPDispatchTableSize = 224
     * }
     */
    public static int kCGLCPDispatchTableSize() {
        return kCGLCPDispatchTableSize;
    }
    private static final int kCGLCPClientStorage = (int)226L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPClientStorage = 226
     * }
     */
    public static int kCGLCPClientStorage() {
        return kCGLCPClientStorage;
    }
    private static final int kCGLCPSurfaceTexture = (int)228L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPSurfaceTexture = 228
     * }
     */
    public static int kCGLCPSurfaceTexture() {
        return kCGLCPSurfaceTexture;
    }
    private static final int kCGLCPSurfaceOrder = (int)235L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPSurfaceOrder = 235
     * }
     */
    public static int kCGLCPSurfaceOrder() {
        return kCGLCPSurfaceOrder;
    }
    private static final int kCGLCPSurfaceOpacity = (int)236L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPSurfaceOpacity = 236
     * }
     */
    public static int kCGLCPSurfaceOpacity() {
        return kCGLCPSurfaceOpacity;
    }
    private static final int kCGLCPSurfaceBackingSize = (int)304L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPSurfaceBackingSize = 304
     * }
     */
    public static int kCGLCPSurfaceBackingSize() {
        return kCGLCPSurfaceBackingSize;
    }
    private static final int kCGLCPSurfaceSurfaceVolatile = (int)306L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPSurfaceSurfaceVolatile = 306
     * }
     */
    public static int kCGLCPSurfaceSurfaceVolatile() {
        return kCGLCPSurfaceSurfaceVolatile;
    }
    private static final int kCGLCPReclaimResources = (int)308L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPReclaimResources = 308
     * }
     */
    public static int kCGLCPReclaimResources() {
        return kCGLCPReclaimResources;
    }
    private static final int kCGLCPCurrentRendererID = (int)309L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPCurrentRendererID = 309
     * }
     */
    public static int kCGLCPCurrentRendererID() {
        return kCGLCPCurrentRendererID;
    }
    private static final int kCGLCPGPUVertexProcessing = (int)310L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPGPUVertexProcessing = 310
     * }
     */
    public static int kCGLCPGPUVertexProcessing() {
        return kCGLCPGPUVertexProcessing;
    }
    private static final int kCGLCPGPUFragmentProcessing = (int)311L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPGPUFragmentProcessing = 311
     * }
     */
    public static int kCGLCPGPUFragmentProcessing() {
        return kCGLCPGPUFragmentProcessing;
    }
    private static final int kCGLCPHasDrawable = (int)314L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPHasDrawable = 314
     * }
     */
    public static int kCGLCPHasDrawable() {
        return kCGLCPHasDrawable;
    }
    private static final int kCGLCPMPSwapsInFlight = (int)315L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPMPSwapsInFlight = 315
     * }
     */
    public static int kCGLCPMPSwapsInFlight() {
        return kCGLCPMPSwapsInFlight;
    }
    private static final int kCGLCPGPURestartStatus = (int)317L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPGPURestartStatus = 317
     * }
     */
    public static int kCGLCPGPURestartStatus() {
        return kCGLCPGPURestartStatus;
    }
    private static final int kCGLCPAbortOnGPURestartStatusBlacklisted = (int)318L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPAbortOnGPURestartStatusBlacklisted = 318
     * }
     */
    public static int kCGLCPAbortOnGPURestartStatusBlacklisted() {
        return kCGLCPAbortOnGPURestartStatusBlacklisted;
    }
    private static final int kCGLCPAbortOnGPURestartStatusDenied = (int)318L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPAbortOnGPURestartStatusDenied = 318
     * }
     */
    public static int kCGLCPAbortOnGPURestartStatusDenied() {
        return kCGLCPAbortOnGPURestartStatusDenied;
    }
    private static final int kCGLCPSupportGPURestart = (int)319L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPSupportGPURestart = 319
     * }
     */
    public static int kCGLCPSupportGPURestart() {
        return kCGLCPSupportGPURestart;
    }
    private static final int kCGLCPSupportSeparateAddressSpace = (int)320L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPSupportSeparateAddressSpace = 320
     * }
     */
    public static int kCGLCPSupportSeparateAddressSpace() {
        return kCGLCPSupportSeparateAddressSpace;
    }
    private static final int kCGLCPContextPriorityRequest = (int)608L;
    /**
     * {@snippet lang=c :
     * enum _CGLContextParameter.kCGLCPContextPriorityRequest = 608
     * }
     */
    public static int kCGLCPContextPriorityRequest() {
        return kCGLCPContextPriorityRequest;
    }
    private static final int kCGLCPContextPriorityRequestHigh = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.kCGLCPContextPriorityRequestHigh = 0
     * }
     */
    public static int kCGLCPContextPriorityRequestHigh() {
        return kCGLCPContextPriorityRequestHigh;
    }
    private static final int kCGLCPContextPriorityRequestNormal = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.kCGLCPContextPriorityRequestNormal = 1
     * }
     */
    public static int kCGLCPContextPriorityRequestNormal() {
        return kCGLCPContextPriorityRequestNormal;
    }
    private static final int kCGLCPContextPriorityRequestLow = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.kCGLCPContextPriorityRequestLow = 2
     * }
     */
    public static int kCGLCPContextPriorityRequestLow() {
        return kCGLCPContextPriorityRequestLow;
    }
    private static final int kCGLGOFormatCacheSize = (int)501L;
    /**
     * {@snippet lang=c :
     * enum _CGLGlobalOption.kCGLGOFormatCacheSize = 501
     * }
     */
    public static int kCGLGOFormatCacheSize() {
        return kCGLGOFormatCacheSize;
    }
    private static final int kCGLGOClearFormatCache = (int)502L;
    /**
     * {@snippet lang=c :
     * enum _CGLGlobalOption.kCGLGOClearFormatCache = 502
     * }
     */
    public static int kCGLGOClearFormatCache() {
        return kCGLGOClearFormatCache;
    }
    private static final int kCGLGORetainRenderers = (int)503L;
    /**
     * {@snippet lang=c :
     * enum _CGLGlobalOption.kCGLGORetainRenderers = 503
     * }
     */
    public static int kCGLGORetainRenderers() {
        return kCGLGORetainRenderers;
    }
    private static final int kCGLGOUseBuildCache = (int)506L;
    /**
     * {@snippet lang=c :
     * enum _CGLGlobalOption.kCGLGOUseBuildCache = 506
     * }
     */
    public static int kCGLGOUseBuildCache() {
        return kCGLGOUseBuildCache;
    }
    private static final int kCGLGOResetLibrary = (int)504L;
    /**
     * {@snippet lang=c :
     * enum _CGLGlobalOption.kCGLGOResetLibrary = 504
     * }
     */
    public static int kCGLGOResetLibrary() {
        return kCGLGOResetLibrary;
    }
    private static final int kCGLGOUseErrorHandler = (int)505L;
    /**
     * {@snippet lang=c :
     * enum _CGLGlobalOption.kCGLGOUseErrorHandler = 505
     * }
     */
    public static int kCGLGOUseErrorHandler() {
        return kCGLGOUseErrorHandler;
    }
    private static final int kCGLOGLPVersion_Legacy = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum _CGLOpenGLProfile.kCGLOGLPVersion_Legacy = 4096
     * }
     */
    public static int kCGLOGLPVersion_Legacy() {
        return kCGLOGLPVersion_Legacy;
    }
    private static final int kCGLOGLPVersion_3_2_Core = (int)12800L;
    /**
     * {@snippet lang=c :
     * enum _CGLOpenGLProfile.kCGLOGLPVersion_3_2_Core = 12800
     * }
     */
    public static int kCGLOGLPVersion_3_2_Core() {
        return kCGLOGLPVersion_3_2_Core;
    }
    private static final int kCGLOGLPVersion_GL3_Core = (int)12800L;
    /**
     * {@snippet lang=c :
     * enum _CGLOpenGLProfile.kCGLOGLPVersion_GL3_Core = 12800
     * }
     */
    public static int kCGLOGLPVersion_GL3_Core() {
        return kCGLOGLPVersion_GL3_Core;
    }
    private static final int kCGLOGLPVersion_GL4_Core = (int)16640L;
    /**
     * {@snippet lang=c :
     * enum _CGLOpenGLProfile.kCGLOGLPVersion_GL4_Core = 16640
     * }
     */
    public static int kCGLOGLPVersion_GL4_Core() {
        return kCGLOGLPVersion_GL4_Core;
    }
    private static final int kCGLNoError = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLNoError = 0
     * }
     */
    public static int kCGLNoError() {
        return kCGLNoError;
    }
    private static final int kCGLBadAttribute = (int)10000L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadAttribute = 10000
     * }
     */
    public static int kCGLBadAttribute() {
        return kCGLBadAttribute;
    }
    private static final int kCGLBadProperty = (int)10001L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadProperty = 10001
     * }
     */
    public static int kCGLBadProperty() {
        return kCGLBadProperty;
    }
    private static final int kCGLBadPixelFormat = (int)10002L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadPixelFormat = 10002
     * }
     */
    public static int kCGLBadPixelFormat() {
        return kCGLBadPixelFormat;
    }
    private static final int kCGLBadRendererInfo = (int)10003L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadRendererInfo = 10003
     * }
     */
    public static int kCGLBadRendererInfo() {
        return kCGLBadRendererInfo;
    }
    private static final int kCGLBadContext = (int)10004L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadContext = 10004
     * }
     */
    public static int kCGLBadContext() {
        return kCGLBadContext;
    }
    private static final int kCGLBadDrawable = (int)10005L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadDrawable = 10005
     * }
     */
    public static int kCGLBadDrawable() {
        return kCGLBadDrawable;
    }
    private static final int kCGLBadDisplay = (int)10006L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadDisplay = 10006
     * }
     */
    public static int kCGLBadDisplay() {
        return kCGLBadDisplay;
    }
    private static final int kCGLBadState = (int)10007L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadState = 10007
     * }
     */
    public static int kCGLBadState() {
        return kCGLBadState;
    }
    private static final int kCGLBadValue = (int)10008L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadValue = 10008
     * }
     */
    public static int kCGLBadValue() {
        return kCGLBadValue;
    }
    private static final int kCGLBadMatch = (int)10009L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadMatch = 10009
     * }
     */
    public static int kCGLBadMatch() {
        return kCGLBadMatch;
    }
    private static final int kCGLBadEnumeration = (int)10010L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadEnumeration = 10010
     * }
     */
    public static int kCGLBadEnumeration() {
        return kCGLBadEnumeration;
    }
    private static final int kCGLBadOffScreen = (int)10011L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadOffScreen = 10011
     * }
     */
    public static int kCGLBadOffScreen() {
        return kCGLBadOffScreen;
    }
    private static final int kCGLBadFullScreen = (int)10012L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadFullScreen = 10012
     * }
     */
    public static int kCGLBadFullScreen() {
        return kCGLBadFullScreen;
    }
    private static final int kCGLBadWindow = (int)10013L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadWindow = 10013
     * }
     */
    public static int kCGLBadWindow() {
        return kCGLBadWindow;
    }
    private static final int kCGLBadAddress = (int)10014L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadAddress = 10014
     * }
     */
    public static int kCGLBadAddress() {
        return kCGLBadAddress;
    }
    private static final int kCGLBadCodeModule = (int)10015L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadCodeModule = 10015
     * }
     */
    public static int kCGLBadCodeModule() {
        return kCGLBadCodeModule;
    }
    private static final int kCGLBadAlloc = (int)10016L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadAlloc = 10016
     * }
     */
    public static int kCGLBadAlloc() {
        return kCGLBadAlloc;
    }
    private static final int kCGLBadConnection = (int)10017L;
    /**
     * {@snippet lang=c :
     * enum _CGLError.kCGLBadConnection = 10017
     * }
     */
    public static int kCGLBadConnection() {
        return kCGLBadConnection;
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t GLbitfield
     * }
     */
    public static final OfInt GLbitfield = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint8_t GLboolean
     * }
     */
    public static final OfByte GLboolean = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int8_t GLbyte
     * }
     */
    public static final OfByte GLbyte = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef float GLclampf
     * }
     */
    public static final OfFloat GLclampf = opencl_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t GLenum
     * }
     */
    public static final OfInt GLenum = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float GLfloat
     * }
     */
    public static final OfFloat GLfloat = opencl_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef int32_t GLint
     * }
     */
    public static final OfInt GLint = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int16_t GLshort
     * }
     */
    public static final OfShort GLshort = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t GLsizei
     * }
     */
    public static final OfInt GLsizei = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint8_t GLubyte
     * }
     */
    public static final OfByte GLubyte = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint32_t GLuint
     * }
     */
    public static final OfInt GLuint = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t GLushort
     * }
     */
    public static final OfShort GLushort = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef char GLchar
     * }
     */
    public static final OfByte GLchar = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef char GLcharARB
     * }
     */
    public static final OfByte GLcharARB = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef void *GLhandleARB
     * }
     */
    public static final AddressLayout GLhandleARB = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef double GLdouble
     * }
     */
    public static final OfDouble GLdouble = opencl_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double GLclampd
     * }
     */
    public static final OfDouble GLclampd = opencl_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef int32_t GLfixed
     * }
     */
    public static final OfInt GLfixed = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t GLhalf
     * }
     */
    public static final OfShort GLhalf = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t GLhalfARB
     * }
     */
    public static final OfShort GLhalfARB = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int64_t GLint64
     * }
     */
    public static final OfLong GLint64 = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct __GLsync *GLsync
     * }
     */
    public static final AddressLayout GLsync = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef uint64_t GLuint64
     * }
     */
    public static final OfLong GLuint64 = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t GLint64EXT
     * }
     */
    public static final OfLong GLint64EXT = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t GLuint64EXT
     * }
     */
    public static final OfLong GLuint64EXT = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t GLintptr
     * }
     */
    public static final OfLong GLintptr = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t GLsizeiptr
     * }
     */
    public static final OfLong GLsizeiptr = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t GLintptrARB
     * }
     */
    public static final OfLong GLintptrARB = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t GLsizeiptrARB
     * }
     */
    public static final OfLong GLsizeiptrARB = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct CGLShareGroupRec *CGLShareGroupObj
     * }
     */
    public static final AddressLayout CGLShareGroupObj = opencl_h.C_POINTER;

    private static class CGLGetShareGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("CGLGetShareGroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * CGLShareGroupObj  _Nullable CGLGetShareGroup(CGLContextObj  _Nonnull ctx)
     * }
     */
    public static FunctionDescriptor CGLGetShareGroup$descriptor() {
        return CGLGetShareGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * CGLShareGroupObj  _Nullable CGLGetShareGroup(CGLContextObj  _Nonnull ctx)
     * }
     */
    public static MethodHandle CGLGetShareGroup$handle() {
        return CGLGetShareGroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * CGLShareGroupObj  _Nullable CGLGetShareGroup(CGLContextObj  _Nonnull ctx)
     * }
     */
    public static MemorySegment CGLGetShareGroup$address() {
        return CGLGetShareGroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * CGLShareGroupObj  _Nullable CGLGetShareGroup(CGLContextObj  _Nonnull ctx)
     * }
     */
    public static MemorySegment CGLGetShareGroup(MemorySegment ctx) {
        var mh$ = CGLGetShareGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CGLGetShareGroup", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CGLGetDeviceFromGLRenderer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("CGLGetDeviceFromGLRenderer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * cl_device_id  _Nonnull CGLGetDeviceFromGLRenderer(GLint rendererID)
     * }
     */
    public static FunctionDescriptor CGLGetDeviceFromGLRenderer$descriptor() {
        return CGLGetDeviceFromGLRenderer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * cl_device_id  _Nonnull CGLGetDeviceFromGLRenderer(GLint rendererID)
     * }
     */
    public static MethodHandle CGLGetDeviceFromGLRenderer$handle() {
        return CGLGetDeviceFromGLRenderer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * cl_device_id  _Nonnull CGLGetDeviceFromGLRenderer(GLint rendererID)
     * }
     */
    public static MemorySegment CGLGetDeviceFromGLRenderer$address() {
        return CGLGetDeviceFromGLRenderer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * cl_device_id  _Nonnull CGLGetDeviceFromGLRenderer(GLint rendererID)
     * }
     */
    public static MemorySegment CGLGetDeviceFromGLRenderer(int rendererID) {
        var mh$ = CGLGetDeviceFromGLRenderer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CGLGetDeviceFromGLRenderer", rendererID);
            }
            return (MemorySegment)mh$.invokeExact(rendererID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetGLContextInfoAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetGLContextInfoAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * cl_int clGetGLContextInfoAPPLE(cl_context _Nonnull, void * _Nonnull, cl_gl_platform_info, size_t, void * _Nullable, size_t * _Nullable)
     * }
     */
    public static FunctionDescriptor clGetGLContextInfoAPPLE$descriptor() {
        return clGetGLContextInfoAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * cl_int clGetGLContextInfoAPPLE(cl_context _Nonnull, void * _Nonnull, cl_gl_platform_info, size_t, void * _Nullable, size_t * _Nullable)
     * }
     */
    public static MethodHandle clGetGLContextInfoAPPLE$handle() {
        return clGetGLContextInfoAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * cl_int clGetGLContextInfoAPPLE(cl_context _Nonnull, void * _Nonnull, cl_gl_platform_info, size_t, void * _Nullable, size_t * _Nullable)
     * }
     */
    public static MemorySegment clGetGLContextInfoAPPLE$address() {
        return clGetGLContextInfoAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * cl_int clGetGLContextInfoAPPLE(cl_context _Nonnull, void * _Nonnull, cl_gl_platform_info, size_t, void * _Nullable, size_t * _Nullable)
     * }
     */
    public static int clGetGLContextInfoAPPLE(MemorySegment x0, MemorySegment x1, int x2, long x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clGetGLContextInfoAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetGLContextInfoAPPLE", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateEventFromGLsyncKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateEventFromGLsyncKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_event  _Nullable clCreateEventFromGLsyncKHR(cl_context _Nonnull, cl_GLsync _Nonnull, cl_int * _Nullable)
     * }
     */
    public static FunctionDescriptor clCreateEventFromGLsyncKHR$descriptor() {
        return clCreateEventFromGLsyncKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_event  _Nullable clCreateEventFromGLsyncKHR(cl_context _Nonnull, cl_GLsync _Nonnull, cl_int * _Nullable)
     * }
     */
    public static MethodHandle clCreateEventFromGLsyncKHR$handle() {
        return clCreateEventFromGLsyncKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_event  _Nullable clCreateEventFromGLsyncKHR(cl_context _Nonnull, cl_GLsync _Nonnull, cl_int * _Nullable)
     * }
     */
    public static MemorySegment clCreateEventFromGLsyncKHR$address() {
        return clCreateEventFromGLsyncKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_event  _Nullable clCreateEventFromGLsyncKHR(cl_context _Nonnull, cl_GLsync _Nonnull, cl_int * _Nullable)
     * }
     */
    public static MemorySegment clCreateEventFromGLsyncKHR(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = clCreateEventFromGLsyncKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateEventFromGLsyncKHR", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __IOSurface *IOSurfaceRef
     * }
     */
    public static final AddressLayout IOSurfaceRef = opencl_h.C_POINTER;

    private static class clCreateImageFromIOSurface2DAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateImageFromIOSurface2DAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * cl_mem  _Nullable clCreateImageFromIOSurface2DAPPLE(cl_context _Nonnull, cl_mem_flags, const cl_image_format * _Nonnull, size_t, size_t, IOSurfaceRef _Nonnull, cl_int * _Nullable)
     * }
     */
    public static FunctionDescriptor clCreateImageFromIOSurface2DAPPLE$descriptor() {
        return clCreateImageFromIOSurface2DAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * cl_mem  _Nullable clCreateImageFromIOSurface2DAPPLE(cl_context _Nonnull, cl_mem_flags, const cl_image_format * _Nonnull, size_t, size_t, IOSurfaceRef _Nonnull, cl_int * _Nullable)
     * }
     */
    public static MethodHandle clCreateImageFromIOSurface2DAPPLE$handle() {
        return clCreateImageFromIOSurface2DAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * cl_mem  _Nullable clCreateImageFromIOSurface2DAPPLE(cl_context _Nonnull, cl_mem_flags, const cl_image_format * _Nonnull, size_t, size_t, IOSurfaceRef _Nonnull, cl_int * _Nullable)
     * }
     */
    public static MemorySegment clCreateImageFromIOSurface2DAPPLE$address() {
        return clCreateImageFromIOSurface2DAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * cl_mem  _Nullable clCreateImageFromIOSurface2DAPPLE(cl_context _Nonnull, cl_mem_flags, const cl_image_format * _Nonnull, size_t, size_t, IOSurfaceRef _Nonnull, cl_int * _Nullable)
     * }
     */
    public static MemorySegment clCreateImageFromIOSurface2DAPPLE(MemorySegment x0, long x1, MemorySegment x2, long x3, long x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = clCreateImageFromIOSurface2DAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateImageFromIOSurface2DAPPLE", x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef intptr_t cl_iosurface_properties_APPLE
     * }
     */
    public static final OfLong cl_iosurface_properties_APPLE = opencl_h.C_LONG;

    private static class clCreateImageFromIOSurfaceWithPropertiesAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateImageFromIOSurfaceWithPropertiesAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * cl_mem  _Nullable clCreateImageFromIOSurfaceWithPropertiesAPPLE(cl_context _Nonnull, cl_mem_flags, const cl_image_format * _Nonnull, const cl_image_desc * _Nonnull, cl_iosurface_properties_APPLE * _Nonnull, cl_int * _Nullable)
     * }
     */
    public static FunctionDescriptor clCreateImageFromIOSurfaceWithPropertiesAPPLE$descriptor() {
        return clCreateImageFromIOSurfaceWithPropertiesAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * cl_mem  _Nullable clCreateImageFromIOSurfaceWithPropertiesAPPLE(cl_context _Nonnull, cl_mem_flags, const cl_image_format * _Nonnull, const cl_image_desc * _Nonnull, cl_iosurface_properties_APPLE * _Nonnull, cl_int * _Nullable)
     * }
     */
    public static MethodHandle clCreateImageFromIOSurfaceWithPropertiesAPPLE$handle() {
        return clCreateImageFromIOSurfaceWithPropertiesAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * cl_mem  _Nullable clCreateImageFromIOSurfaceWithPropertiesAPPLE(cl_context _Nonnull, cl_mem_flags, const cl_image_format * _Nonnull, const cl_image_desc * _Nonnull, cl_iosurface_properties_APPLE * _Nonnull, cl_int * _Nullable)
     * }
     */
    public static MemorySegment clCreateImageFromIOSurfaceWithPropertiesAPPLE$address() {
        return clCreateImageFromIOSurfaceWithPropertiesAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * cl_mem  _Nullable clCreateImageFromIOSurfaceWithPropertiesAPPLE(cl_context _Nonnull, cl_mem_flags, const cl_image_format * _Nonnull, const cl_image_desc * _Nonnull, cl_iosurface_properties_APPLE * _Nonnull, cl_int * _Nullable)
     * }
     */
    public static MemorySegment clCreateImageFromIOSurfaceWithPropertiesAPPLE(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = clCreateImageFromIOSurfaceWithPropertiesAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateImageFromIOSurfaceWithPropertiesAPPLE", x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = opencl_h.C_POINTER;

    private static class clSetMemObjectDestructorAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clSetMemObjectDestructorAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * cl_int clSetMemObjectDestructorAPPLE(cl_mem, void (*)(cl_mem, void *), void *)
     * }
     */
    public static FunctionDescriptor clSetMemObjectDestructorAPPLE$descriptor() {
        return clSetMemObjectDestructorAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * cl_int clSetMemObjectDestructorAPPLE(cl_mem, void (*)(cl_mem, void *), void *)
     * }
     */
    public static MethodHandle clSetMemObjectDestructorAPPLE$handle() {
        return clSetMemObjectDestructorAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * cl_int clSetMemObjectDestructorAPPLE(cl_mem, void (*)(cl_mem, void *), void *)
     * }
     */
    public static MemorySegment clSetMemObjectDestructorAPPLE$address() {
        return clSetMemObjectDestructorAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * cl_int clSetMemObjectDestructorAPPLE(cl_mem, void (*)(cl_mem, void *), void *)
     * }
     */
    public static int clSetMemObjectDestructorAPPLE(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = clSetMemObjectDestructorAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetMemObjectDestructorAPPLE", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clLogMessagesToSystemLogAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clLogMessagesToSystemLogAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clLogMessagesToSystemLogAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static FunctionDescriptor clLogMessagesToSystemLogAPPLE$descriptor() {
        return clLogMessagesToSystemLogAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clLogMessagesToSystemLogAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static MethodHandle clLogMessagesToSystemLogAPPLE$handle() {
        return clLogMessagesToSystemLogAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clLogMessagesToSystemLogAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static MemorySegment clLogMessagesToSystemLogAPPLE$address() {
        return clLogMessagesToSystemLogAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clLogMessagesToSystemLogAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static void clLogMessagesToSystemLogAPPLE(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = clLogMessagesToSystemLogAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clLogMessagesToSystemLogAPPLE", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clLogMessagesToStdoutAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clLogMessagesToStdoutAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clLogMessagesToStdoutAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static FunctionDescriptor clLogMessagesToStdoutAPPLE$descriptor() {
        return clLogMessagesToStdoutAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clLogMessagesToStdoutAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static MethodHandle clLogMessagesToStdoutAPPLE$handle() {
        return clLogMessagesToStdoutAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clLogMessagesToStdoutAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static MemorySegment clLogMessagesToStdoutAPPLE$address() {
        return clLogMessagesToStdoutAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clLogMessagesToStdoutAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static void clLogMessagesToStdoutAPPLE(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = clLogMessagesToStdoutAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clLogMessagesToStdoutAPPLE", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clLogMessagesToStderrAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clLogMessagesToStderrAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clLogMessagesToStderrAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static FunctionDescriptor clLogMessagesToStderrAPPLE$descriptor() {
        return clLogMessagesToStderrAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clLogMessagesToStderrAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static MethodHandle clLogMessagesToStderrAPPLE$handle() {
        return clLogMessagesToStderrAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clLogMessagesToStderrAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static MemorySegment clLogMessagesToStderrAPPLE$address() {
        return clLogMessagesToStderrAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clLogMessagesToStderrAPPLE(const char *, const void *, size_t, void *)
     * }
     */
    public static void clLogMessagesToStderrAPPLE(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = clLogMessagesToStderrAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clLogMessagesToStderrAPPLE", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateContextAndCommandQueueAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateContextAndCommandQueueAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCreateContextAndCommandQueueAPPLE(const cl_context_properties *, cl_uint, const cl_device_id *, void (*)(const char *, const void *, size_t, void *), void *, cl_command_queue_properties, cl_context *, cl_command_queue *)
     * }
     */
    public static FunctionDescriptor clCreateContextAndCommandQueueAPPLE$descriptor() {
        return clCreateContextAndCommandQueueAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCreateContextAndCommandQueueAPPLE(const cl_context_properties *, cl_uint, const cl_device_id *, void (*)(const char *, const void *, size_t, void *), void *, cl_command_queue_properties, cl_context *, cl_command_queue *)
     * }
     */
    public static MethodHandle clCreateContextAndCommandQueueAPPLE$handle() {
        return clCreateContextAndCommandQueueAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clCreateContextAndCommandQueueAPPLE(const cl_context_properties *, cl_uint, const cl_device_id *, void (*)(const char *, const void *, size_t, void *), void *, cl_command_queue_properties, cl_context *, cl_command_queue *)
     * }
     */
    public static MemorySegment clCreateContextAndCommandQueueAPPLE$address() {
        return clCreateContextAndCommandQueueAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clCreateContextAndCommandQueueAPPLE(const cl_context_properties *, cl_uint, const cl_device_id *, void (*)(const char *, const void *, size_t, void *), void *, cl_command_queue_properties, cl_context *, cl_command_queue *)
     * }
     */
    public static int clCreateContextAndCommandQueueAPPLE(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5, MemorySegment x6, MemorySegment x7) {
        var mh$ = clCreateContextAndCommandQueueAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateContextAndCommandQueueAPPLE", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateProgramAndKernelsWithSourceAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateProgramAndKernelsWithSourceAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCreateProgramAndKernelsWithSourceAPPLE(cl_context, cl_uint, const char **, const size_t *, cl_uint, const cl_device_id *, const char *, cl_uint, const char **, cl_program *, cl_kernel *)
     * }
     */
    public static FunctionDescriptor clCreateProgramAndKernelsWithSourceAPPLE$descriptor() {
        return clCreateProgramAndKernelsWithSourceAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCreateProgramAndKernelsWithSourceAPPLE(cl_context, cl_uint, const char **, const size_t *, cl_uint, const cl_device_id *, const char *, cl_uint, const char **, cl_program *, cl_kernel *)
     * }
     */
    public static MethodHandle clCreateProgramAndKernelsWithSourceAPPLE$handle() {
        return clCreateProgramAndKernelsWithSourceAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clCreateProgramAndKernelsWithSourceAPPLE(cl_context, cl_uint, const char **, const size_t *, cl_uint, const cl_device_id *, const char *, cl_uint, const char **, cl_program *, cl_kernel *)
     * }
     */
    public static MemorySegment clCreateProgramAndKernelsWithSourceAPPLE$address() {
        return clCreateProgramAndKernelsWithSourceAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clCreateProgramAndKernelsWithSourceAPPLE(cl_context, cl_uint, const char **, const size_t *, cl_uint, const cl_device_id *, const char *, cl_uint, const char **, cl_program *, cl_kernel *)
     * }
     */
    public static int clCreateProgramAndKernelsWithSourceAPPLE(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, int x4, MemorySegment x5, MemorySegment x6, int x7, MemorySegment x8, MemorySegment x9, MemorySegment x10) {
        var mh$ = clCreateProgramAndKernelsWithSourceAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateProgramAndKernelsWithSourceAPPLE", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgsListAPPLE(cl_kernel, cl_uint, ...)
     * }
     */
    public static class clSetKernelArgsListAPPLE {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opencl_h.C_INT,
                opencl_h.C_POINTER,
                opencl_h.C_INT
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("clSetKernelArgsListAPPLE");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private clSetKernelArgsListAPPLE(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern cl_int clSetKernelArgsListAPPLE(cl_kernel, cl_uint, ...)
         * }
         */
        public static clSetKernelArgsListAPPLE makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new clSetKernelArgsListAPPLE(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, int x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("clSetKernelArgsListAPPLE", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class clSetKernelArgsVaListAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clSetKernelArgsVaListAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgsVaListAPPLE(cl_kernel, cl_uint, va_list)
     * }
     */
    public static FunctionDescriptor clSetKernelArgsVaListAPPLE$descriptor() {
        return clSetKernelArgsVaListAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgsVaListAPPLE(cl_kernel, cl_uint, va_list)
     * }
     */
    public static MethodHandle clSetKernelArgsVaListAPPLE$handle() {
        return clSetKernelArgsVaListAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgsVaListAPPLE(cl_kernel, cl_uint, va_list)
     * }
     */
    public static MemorySegment clSetKernelArgsVaListAPPLE$address() {
        return clSetKernelArgsVaListAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgsVaListAPPLE(cl_kernel, cl_uint, va_list)
     * }
     */
    public static int clSetKernelArgsVaListAPPLE(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = clSetKernelArgsVaListAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetKernelArgsVaListAPPLE", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetKernelArgByNameAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clSetKernelArgByNameAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgByNameAPPLE(cl_kernel, const char *, size_t, const void *)
     * }
     */
    public static FunctionDescriptor clSetKernelArgByNameAPPLE$descriptor() {
        return clSetKernelArgByNameAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgByNameAPPLE(cl_kernel, const char *, size_t, const void *)
     * }
     */
    public static MethodHandle clSetKernelArgByNameAPPLE$handle() {
        return clSetKernelArgByNameAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgByNameAPPLE(cl_kernel, const char *, size_t, const void *)
     * }
     */
    public static MemorySegment clSetKernelArgByNameAPPLE$address() {
        return clSetKernelArgByNameAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgByNameAPPLE(cl_kernel, const char *, size_t, const void *)
     * }
     */
    public static int clSetKernelArgByNameAPPLE(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = clSetKernelArgByNameAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetKernelArgByNameAPPLE", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _cl_dag *cl_dag
     * }
     */
    public static final AddressLayout cl_dag = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int cl_dag_node
     * }
     */
    public static final OfInt cl_dag_node = opencl_h.C_INT;

    private static class clCreateDAGAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateDAGAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * cl_dag clCreateDAGAPPLE(cl_context c)
     * }
     */
    public static FunctionDescriptor clCreateDAGAPPLE$descriptor() {
        return clCreateDAGAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * cl_dag clCreateDAGAPPLE(cl_context c)
     * }
     */
    public static MethodHandle clCreateDAGAPPLE$handle() {
        return clCreateDAGAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * cl_dag clCreateDAGAPPLE(cl_context c)
     * }
     */
    public static MemorySegment clCreateDAGAPPLE$address() {
        return clCreateDAGAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * cl_dag clCreateDAGAPPLE(cl_context c)
     * }
     */
    public static MemorySegment clCreateDAGAPPLE(MemorySegment c) {
        var mh$ = clCreateDAGAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateDAGAPPLE", c);
            }
            return (MemorySegment)mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseDAGAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clReleaseDAGAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clReleaseDAGAPPLE(cl_dag dag)
     * }
     */
    public static FunctionDescriptor clReleaseDAGAPPLE$descriptor() {
        return clReleaseDAGAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clReleaseDAGAPPLE(cl_dag dag)
     * }
     */
    public static MethodHandle clReleaseDAGAPPLE$handle() {
        return clReleaseDAGAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clReleaseDAGAPPLE(cl_dag dag)
     * }
     */
    public static MemorySegment clReleaseDAGAPPLE$address() {
        return clReleaseDAGAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clReleaseDAGAPPLE(cl_dag dag)
     * }
     */
    public static void clReleaseDAGAPPLE(MemorySegment dag) {
        var mh$ = clReleaseDAGAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseDAGAPPLE", dag);
            }
            mh$.invokeExact(dag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetDAGNodeAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clGetDAGNodeAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * cl_dag_node clGetDAGNodeAPPLE(cl_dag d, cl_kernel f, cl_dag_node *args, unsigned int *arg_indices, unsigned int nargs)
     * }
     */
    public static FunctionDescriptor clGetDAGNodeAPPLE$descriptor() {
        return clGetDAGNodeAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * cl_dag_node clGetDAGNodeAPPLE(cl_dag d, cl_kernel f, cl_dag_node *args, unsigned int *arg_indices, unsigned int nargs)
     * }
     */
    public static MethodHandle clGetDAGNodeAPPLE$handle() {
        return clGetDAGNodeAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * cl_dag_node clGetDAGNodeAPPLE(cl_dag d, cl_kernel f, cl_dag_node *args, unsigned int *arg_indices, unsigned int nargs)
     * }
     */
    public static MemorySegment clGetDAGNodeAPPLE$address() {
        return clGetDAGNodeAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * cl_dag_node clGetDAGNodeAPPLE(cl_dag d, cl_kernel f, cl_dag_node *args, unsigned int *arg_indices, unsigned int nargs)
     * }
     */
    public static int clGetDAGNodeAPPLE(MemorySegment d, MemorySegment f, MemorySegment args, MemorySegment arg_indices, int nargs) {
        var mh$ = clGetDAGNodeAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetDAGNodeAPPLE", d, f, args, arg_indices, nargs);
            }
            return (int)mh$.invokeExact(d, f, args, arg_indices, nargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateKernelFromDAGAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateKernelFromDAGAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * cl_kernel clCreateKernelFromDAGAPPLE(cl_dag d, cl_uint n, const cl_device_id *list)
     * }
     */
    public static FunctionDescriptor clCreateKernelFromDAGAPPLE$descriptor() {
        return clCreateKernelFromDAGAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * cl_kernel clCreateKernelFromDAGAPPLE(cl_dag d, cl_uint n, const cl_device_id *list)
     * }
     */
    public static MethodHandle clCreateKernelFromDAGAPPLE$handle() {
        return clCreateKernelFromDAGAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * cl_kernel clCreateKernelFromDAGAPPLE(cl_dag d, cl_uint n, const cl_device_id *list)
     * }
     */
    public static MemorySegment clCreateKernelFromDAGAPPLE$address() {
        return clCreateKernelFromDAGAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * cl_kernel clCreateKernelFromDAGAPPLE(cl_dag d, cl_uint n, const cl_device_id *list)
     * }
     */
    public static MemorySegment clCreateKernelFromDAGAPPLE(MemorySegment d, int n, MemorySegment list) {
        var mh$ = clCreateKernelFromDAGAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateKernelFromDAGAPPLE", d, n, list);
            }
            return (MemorySegment)mh$.invokeExact(d, n, list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef intptr_t cl_queue_properties_APPLE
     * }
     */
    public static final OfLong cl_queue_properties_APPLE = opencl_h.C_LONG;

    private static class clCreateCommandQueueWithPropertiesAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("clCreateCommandQueueWithPropertiesAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueueWithPropertiesAPPLE(cl_context, cl_device_id, const cl_queue_properties_APPLE *, cl_int *)
     * }
     */
    public static FunctionDescriptor clCreateCommandQueueWithPropertiesAPPLE$descriptor() {
        return clCreateCommandQueueWithPropertiesAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueueWithPropertiesAPPLE(cl_context, cl_device_id, const cl_queue_properties_APPLE *, cl_int *)
     * }
     */
    public static MethodHandle clCreateCommandQueueWithPropertiesAPPLE$handle() {
        return clCreateCommandQueueWithPropertiesAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueueWithPropertiesAPPLE(cl_context, cl_device_id, const cl_queue_properties_APPLE *, cl_int *)
     * }
     */
    public static MemorySegment clCreateCommandQueueWithPropertiesAPPLE$address() {
        return clCreateCommandQueueWithPropertiesAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueueWithPropertiesAPPLE(cl_context, cl_device_id, const cl_queue_properties_APPLE *, cl_int *)
     * }
     */
    public static MemorySegment clCreateCommandQueueWithPropertiesAPPLE(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = clCreateCommandQueueWithPropertiesAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateCommandQueueWithPropertiesAPPLE", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = opencl_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfLong u_long = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t quad_t
     * }
     */
    public static final OfLong quad_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef quad_t *qaddr_t
     * }
     */
    public static final AddressLayout qaddr_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef char *caddr_t
     * }
     */
    public static final AddressLayout caddr_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int32_t daddr_t
     * }
     */
    public static final OfInt daddr_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fixpt_t
     * }
     */
    public static final OfInt fixpt_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino_t ino_t
     * }
     */
    public static final OfLong ino_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t ino64_t
     * }
     */
    public static final OfLong ino64_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t key_t
     * }
     */
    public static final OfInt key_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t nlink_t
     * }
     */
    public static final OfShort nlink_t = opencl_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int32_t segsz_t
     * }
     */
    public static final OfInt segsz_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t swblk_t
     * }
     */
    public static final OfInt swblk_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_clock_t clock_t
     * }
     */
    public static final OfLong clock_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = opencl_h.C_INT;

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __int32_t fd_mask
     * }
     */
    public static final OfInt fd_mask = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_t pthread_t
     * }
     */
    public static final AddressLayout pthread_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_key_t pthread_key_t
     * }
     */
    public static final OfLong pthread_key_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfInt fsblkcnt_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfInt fsfilcnt_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = opencl_h.C_INT;

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dst, MemorySegment __src, long __len) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dst, __src, __len);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset(MemorySegment __b, int __c, long __len) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __b, __c, __len);
            }
            return (MemorySegment)mh$.invokeExact(__b, __c, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __s1, __s2);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

