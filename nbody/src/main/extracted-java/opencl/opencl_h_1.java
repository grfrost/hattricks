// Generated by jextract

package opencl;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class opencl_h_1 extends opencl_h_2 {

    opencl_h_1() {
        // Should not be called directly
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __s1, __s2, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __charset);
            }
            return (MemorySegment)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok(MemorySegment __str, MemorySegment __sep) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __str, __sep);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __s1, __s2, __n);
            }
            return (long)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __str, MemorySegment __sep, MemorySegment __lasts) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __str, __sep, __lasts);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep, __lasts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __strerrbuf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __strerrbuf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __strerrbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s1) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s1);
            }
            return (MemorySegment)mh$.invokeExact(__s1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dst, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dst, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __s1, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __s1, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static long strnlen(MemorySegment __s1, long __n) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __s1, __n);
            }
            return (long)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static FunctionDescriptor memset_s$descriptor() {
        return memset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MethodHandle memset_s$handle() {
        return memset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MemorySegment memset_s$address() {
        return memset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static int memset_s(MemorySegment __s, long __smax, int __c, long __n) {
        var mh$ = memset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_s", __s, __smax, __c, __n);
            }
            return (int)mh$.invokeExact(__s, __smax, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem(MemorySegment __big, long __big_len, MemorySegment __little, long __little_len) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __big, __big_len, __little, __little_len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __big_len, __little, __little_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memset_pattern4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern4$descriptor() {
        return memset_pattern4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern4$handle() {
        return memset_pattern4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern4$address() {
        return memset_pattern4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static void memset_pattern4(MemorySegment __b, MemorySegment __pattern4, long __len) {
        var mh$ = memset_pattern4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern4", __b, __pattern4, __len);
            }
            mh$.invokeExact(__b, __pattern4, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memset_pattern8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern8$descriptor() {
        return memset_pattern8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern8$handle() {
        return memset_pattern8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern8$address() {
        return memset_pattern8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static void memset_pattern8(MemorySegment __b, MemorySegment __pattern8, long __len) {
        var mh$ = memset_pattern8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern8", __b, __pattern8, __len);
            }
            mh$.invokeExact(__b, __pattern8, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("memset_pattern16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern16$descriptor() {
        return memset_pattern16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern16$handle() {
        return memset_pattern16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern16$address() {
        return memset_pattern16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static void memset_pattern16(MemorySegment __b, MemorySegment __pattern16, long __len) {
        var mh$ = memset_pattern16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern16", __b, __pattern16, __len);
            }
            mh$.invokeExact(__b, __pattern16, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strnstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static FunctionDescriptor strnstr$descriptor() {
        return strnstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MethodHandle strnstr$handle() {
        return strnstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr$address() {
        return strnstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr(MemorySegment __big, MemorySegment __little, long __len) {
        var mh$ = strnstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnstr", __big, __little, __len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcat(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcpy(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static FunctionDescriptor strmode$descriptor() {
        return strmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MethodHandle strmode$handle() {
        return strmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MemorySegment strmode$address() {
        return strmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static void strmode(int __mode, MemorySegment __bp) {
        var mh$ = strmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strmode", __mode, __bp);
            }
            mh$.invokeExact(__mode, __bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static void swab(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timingsafe_bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("timingsafe_bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static FunctionDescriptor timingsafe_bcmp$descriptor() {
        return timingsafe_bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MethodHandle timingsafe_bcmp$handle() {
        return timingsafe_bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MemorySegment timingsafe_bcmp$address() {
        return timingsafe_bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static int timingsafe_bcmp(MemorySegment __b1, MemorySegment __b2, long __len) {
        var mh$ = timingsafe_bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timingsafe_bcmp", __b1, __b2, __len);
            }
            return (int)mh$.invokeExact(__b1, __b2, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strsignal_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strsignal_r$descriptor() {
        return strsignal_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strsignal_r$handle() {
        return strsignal_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strsignal_r$address() {
        return strsignal_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static int strsignal_r(int __sig, MemorySegment __strsignalbuf, long __buflen) {
        var mh$ = strsignal_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal_r", __sig, __strsignalbuf, __buflen);
            }
            return (int)mh$.invokeExact(__sig, __strsignalbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static int bcmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static void bcopy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static void bzero(MemorySegment x0, long x1) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index(MemorySegment x0, int x1) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex(MemorySegment x0, int x1) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static int ffs(int x0) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static int strcasecmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static int strncasecmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static int ffsl(long x0) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static int ffsll(long x0) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static FunctionDescriptor fls$descriptor() {
        return fls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MethodHandle fls$handle() {
        return fls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MemorySegment fls$address() {
        return fls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static int fls(int x0) {
        var mh$ = fls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fls", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("flsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static FunctionDescriptor flsl$descriptor() {
        return flsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MethodHandle flsl$handle() {
        return flsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MemorySegment flsl$address() {
        return flsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static int flsl(long x0) {
        var mh$ = flsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("flsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static FunctionDescriptor flsll$descriptor() {
        return flsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MethodHandle flsll$handle() {
        return flsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MemorySegment flsll$address() {
        return flsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static int flsll(long x0) {
        var mh$ = flsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlistbulk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getattrlistbulk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static FunctionDescriptor getattrlistbulk$descriptor() {
        return getattrlistbulk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static MethodHandle getattrlistbulk$handle() {
        return getattrlistbulk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static MemorySegment getattrlistbulk$address() {
        return getattrlistbulk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static int getattrlistbulk(int x0, MemorySegment x1, MemorySegment x2, long x3, long x4) {
        var mh$ = getattrlistbulk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlistbulk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlistat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getattrlistat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static FunctionDescriptor getattrlistat$descriptor() {
        return getattrlistat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static MethodHandle getattrlistat$handle() {
        return getattrlistat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static MemorySegment getattrlistat$address() {
        return getattrlistat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static int getattrlistat(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, long x5) {
        var mh$ = getattrlistat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlistat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setattrlistat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setattrlistat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static FunctionDescriptor setattrlistat$descriptor() {
        return setattrlistat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static MethodHandle setattrlistat$handle() {
        return setattrlistat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static MemorySegment setattrlistat$address() {
        return setattrlistat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static int setattrlistat(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = setattrlistat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setattrlistat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freadlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("freadlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor freadlink$descriptor() {
        return freadlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static MethodHandle freadlink$handle() {
        return freadlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static MemorySegment freadlink$address() {
        return freadlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static long freadlink(int x0, MemorySegment x1, long x2) {
        var mh$ = freadlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freadlink", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class faccessat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("faccessat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static FunctionDescriptor faccessat$descriptor() {
        return faccessat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static MethodHandle faccessat$handle() {
        return faccessat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static MemorySegment faccessat$address() {
        return faccessat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static int faccessat(int x0, MemorySegment x1, int x2, int x3) {
        var mh$ = faccessat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("faccessat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchownat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fchownat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static FunctionDescriptor fchownat$descriptor() {
        return fchownat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static MethodHandle fchownat$handle() {
        return fchownat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static MemorySegment fchownat$address() {
        return fchownat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static int fchownat(int x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = fchownat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchownat", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class linkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("linkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static FunctionDescriptor linkat$descriptor() {
        return linkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static MethodHandle linkat$handle() {
        return linkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static MemorySegment linkat$address() {
        return linkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static int linkat(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = linkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("linkat", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("readlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static FunctionDescriptor readlinkat$descriptor() {
        return readlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static MethodHandle readlinkat$handle() {
        return readlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static MemorySegment readlinkat$address() {
        return readlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static long readlinkat(int x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = readlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlinkat", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("symlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor symlinkat$descriptor() {
        return symlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static MethodHandle symlinkat$handle() {
        return symlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static MemorySegment symlinkat$address() {
        return symlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static int symlinkat(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = symlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlinkat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("unlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static FunctionDescriptor unlinkat$descriptor() {
        return unlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static MethodHandle unlinkat$handle() {
        return unlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static MemorySegment unlinkat$address() {
        return unlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static int unlinkat(int x0, MemorySegment x1, int x2) {
        var mh$ = unlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlinkat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static MemorySegment _exit$address() {
        return _exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static void _exit(int x0) {
        var mh$ = _exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static FunctionDescriptor access$descriptor() {
        return access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static MethodHandle access$handle() {
        return access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static MemorySegment access$address() {
        return access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static int access(MemorySegment x0, int x1) {
        var mh$ = access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("access", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("alarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static FunctionDescriptor alarm$descriptor() {
        return alarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static MethodHandle alarm$handle() {
        return alarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static MemorySegment alarm$address() {
        return alarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static int alarm(int x0) {
        var mh$ = alarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alarm", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("chdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static FunctionDescriptor chdir$descriptor() {
        return chdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static MethodHandle chdir$handle() {
        return chdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static MemorySegment chdir$address() {
        return chdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static int chdir(MemorySegment x0) {
        var mh$ = chdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("chown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor chown$descriptor() {
        return chown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static MethodHandle chown$handle() {
        return chown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static MemorySegment chown$address() {
        return chown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static int chown(MemorySegment x0, int x1, int x2) {
        var mh$ = chown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static FunctionDescriptor close$descriptor() {
        return close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static MethodHandle close$handle() {
        return close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static MemorySegment close$address() {
        return close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static int close(int x0) {
        var mh$ = close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("close", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static FunctionDescriptor dup$descriptor() {
        return dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static MethodHandle dup$handle() {
        return dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static MemorySegment dup$address() {
        return dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static int dup(int x0) {
        var mh$ = dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dup2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static FunctionDescriptor dup2$descriptor() {
        return dup2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static MethodHandle dup2$handle() {
        return dup2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static MemorySegment dup2$address() {
        return dup2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static int dup2(int x0, int x1) {
        var mh$ = dup2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup2", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execl(const char *__path, const char *__arg0, ...)
     * }
     */
    public static class execl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opencl_h.C_INT,
                opencl_h.C_POINTER,
                opencl_h.C_POINTER
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("execl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execl(const char *__path, const char *__arg0, ...)
         * }
         */
        public static execl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execl", __path, __arg0, x2);
                }
                return (int)spreader.invokeExact(__path, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execle(const char *__path, const char *__arg0, ...)
     * }
     */
    public static class execle {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opencl_h.C_INT,
                opencl_h.C_POINTER,
                opencl_h.C_POINTER
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("execle");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execle(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execle(const char *__path, const char *__arg0, ...)
         * }
         */
        public static execle makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execle(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execle", __path, __arg0, x2);
                }
                return (int)spreader.invokeExact(__path, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execlp(const char *__file, const char *__arg0, ...)
     * }
     */
    public static class execlp {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opencl_h.C_INT,
                opencl_h.C_POINTER,
                opencl_h.C_POINTER
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("execlp");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execlp(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execlp(const char *__file, const char *__arg0, ...)
         * }
         */
        public static execlp makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execlp(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __file, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execlp", __file, __arg0, x2);
                }
                return (int)spreader.invokeExact(__file, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class execv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("execv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execv$descriptor() {
        return execv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static MethodHandle execv$handle() {
        return execv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static MemorySegment execv$address() {
        return execv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static int execv(MemorySegment __path, MemorySegment __argv) {
        var mh$ = execv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execv", __path, __argv);
            }
            return (int)mh$.invokeExact(__path, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("execve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static FunctionDescriptor execve$descriptor() {
        return execve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static MethodHandle execve$handle() {
        return execve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static MemorySegment execve$address() {
        return execve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static int execve(MemorySegment __file, MemorySegment __argv, MemorySegment __envp) {
        var mh$ = execve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execve", __file, __argv, __envp);
            }
            return (int)mh$.invokeExact(__file, __argv, __envp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("execvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execvp$descriptor() {
        return execvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static MethodHandle execvp$handle() {
        return execvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static MemorySegment execvp$address() {
        return execvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static int execvp(MemorySegment __file, MemorySegment __argv) {
        var mh$ = execvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvp", __file, __argv);
            }
            return (int)mh$.invokeExact(__file, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static FunctionDescriptor fork$descriptor() {
        return fork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static MethodHandle fork$handle() {
        return fork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static MemorySegment fork$address() {
        return fork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static int fork() {
        var mh$ = fork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fork");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fpathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static FunctionDescriptor fpathconf$descriptor() {
        return fpathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static MethodHandle fpathconf$handle() {
        return fpathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static MemorySegment fpathconf$address() {
        return fpathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static long fpathconf(int x0, int x1) {
        var mh$ = fpathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpathconf", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getcwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getcwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static FunctionDescriptor getcwd$descriptor() {
        return getcwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MethodHandle getcwd$handle() {
        return getcwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MemorySegment getcwd$address() {
        return getcwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MemorySegment getcwd(MemorySegment x0, long x1) {
        var mh$ = getcwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getcwd", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static FunctionDescriptor getegid$descriptor() {
        return getegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static MethodHandle getegid$handle() {
        return getegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static MemorySegment getegid$address() {
        return getegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static int getegid() {
        var mh$ = getegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getegid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class geteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("geteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static FunctionDescriptor geteuid$descriptor() {
        return geteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static MethodHandle geteuid$handle() {
        return geteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static MemorySegment geteuid$address() {
        return geteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static int geteuid() {
        var mh$ = geteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("geteuid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static FunctionDescriptor getgid$descriptor() {
        return getgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static MethodHandle getgid$handle() {
        return getgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static MemorySegment getgid$address() {
        return getgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static int getgid() {
        var mh$ = getgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static FunctionDescriptor getgroups$descriptor() {
        return getgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static MethodHandle getgroups$handle() {
        return getgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static MemorySegment getgroups$address() {
        return getgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static int getgroups(int x0, MemorySegment x1) {
        var mh$ = getgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static FunctionDescriptor getlogin$descriptor() {
        return getlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MethodHandle getlogin$handle() {
        return getlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MemorySegment getlogin$address() {
        return getlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MemorySegment getlogin() {
        var mh$ = getlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static FunctionDescriptor getpgrp$descriptor() {
        return getpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static MethodHandle getpgrp$handle() {
        return getpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static MemorySegment getpgrp$address() {
        return getpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static int getpgrp() {
        var mh$ = getpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static FunctionDescriptor getpid$descriptor() {
        return getpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static MethodHandle getpid$handle() {
        return getpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static MemorySegment getpid$address() {
        return getpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static int getpid() {
        var mh$ = getpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getppid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getppid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static FunctionDescriptor getppid$descriptor() {
        return getppid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static MethodHandle getppid$handle() {
        return getppid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static MemorySegment getppid$address() {
        return getppid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static int getppid() {
        var mh$ = getppid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getppid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static FunctionDescriptor getuid$descriptor() {
        return getuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static MethodHandle getuid$handle() {
        return getuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static MemorySegment getuid$address() {
        return getuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static int getuid() {
        var mh$ = getuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getuid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isatty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("isatty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static FunctionDescriptor isatty$descriptor() {
        return isatty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static MethodHandle isatty$handle() {
        return isatty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static MemorySegment isatty$address() {
        return isatty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static int isatty(int x0) {
        var mh$ = isatty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isatty", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static FunctionDescriptor link$descriptor() {
        return link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static MethodHandle link$handle() {
        return link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static MemorySegment link$address() {
        return link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static int link(MemorySegment x0, MemorySegment x1) {
        var mh$ = link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("link", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT,
            opencl_h.C_LONG_LONG,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("lseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static FunctionDescriptor lseek$descriptor() {
        return lseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static MethodHandle lseek$handle() {
        return lseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static MemorySegment lseek$address() {
        return lseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static long lseek(int x0, long x1, int x2) {
        var mh$ = lseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lseek", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("pathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static FunctionDescriptor pathconf$descriptor() {
        return pathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static MethodHandle pathconf$handle() {
        return pathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static MemorySegment pathconf$address() {
        return pathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static long pathconf(MemorySegment x0, int x1) {
        var mh$ = pathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pathconf", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static FunctionDescriptor pause$descriptor() {
        return pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static MethodHandle pause$handle() {
        return pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static MemorySegment pause$address() {
        return pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static int pause() {
        var mh$ = pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pause");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("pipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static FunctionDescriptor pipe$descriptor() {
        return pipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static MethodHandle pipe$handle() {
        return pipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static MemorySegment pipe$address() {
        return pipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static int pipe(MemorySegment x0) {
        var mh$ = pipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pipe", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static FunctionDescriptor read$descriptor() {
        return read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static MethodHandle read$handle() {
        return read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static MemorySegment read$address() {
        return read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static long read(int x0, MemorySegment x1, long x2) {
        var mh$ = read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("read", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("rmdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static FunctionDescriptor rmdir$descriptor() {
        return rmdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static MethodHandle rmdir$handle() {
        return rmdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static MemorySegment rmdir$address() {
        return rmdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static int rmdir(MemorySegment x0) {
        var mh$ = rmdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static FunctionDescriptor setgid$descriptor() {
        return setgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static MethodHandle setgid$handle() {
        return setgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static MemorySegment setgid$address() {
        return setgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static int setgid(int x0) {
        var mh$ = setgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static FunctionDescriptor setpgid$descriptor() {
        return setpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static MethodHandle setpgid$handle() {
        return setpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static MemorySegment setpgid$address() {
        return setpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static int setpgid(int x0, int x1) {
        var mh$ = setpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static FunctionDescriptor setsid$descriptor() {
        return setsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static MethodHandle setsid$handle() {
        return setsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static MemorySegment setsid$address() {
        return setsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static int setsid() {
        var mh$ = setsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static FunctionDescriptor setuid$descriptor() {
        return setuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static MethodHandle setuid$handle() {
        return setuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static MemorySegment setuid$address() {
        return setuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static int setuid(int x0) {
        var mh$ = setuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setuid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static FunctionDescriptor sleep$descriptor() {
        return sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static MethodHandle sleep$handle() {
        return sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static MemorySegment sleep$address() {
        return sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static int sleep(int x0) {
        var mh$ = sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sleep", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sysconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("sysconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static FunctionDescriptor sysconf$descriptor() {
        return sysconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static MethodHandle sysconf$handle() {
        return sysconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static MemorySegment sysconf$address() {
        return sysconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static long sysconf(int x0) {
        var mh$ = sysconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sysconf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcgetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("tcgetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static FunctionDescriptor tcgetpgrp$descriptor() {
        return tcgetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static MethodHandle tcgetpgrp$handle() {
        return tcgetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static MemorySegment tcgetpgrp$address() {
        return tcgetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static int tcgetpgrp(int x0) {
        var mh$ = tcgetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcgetpgrp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcsetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("tcsetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static FunctionDescriptor tcsetpgrp$descriptor() {
        return tcsetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static MethodHandle tcsetpgrp$handle() {
        return tcsetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static MemorySegment tcsetpgrp$address() {
        return tcsetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static int tcsetpgrp(int x0, int x1) {
        var mh$ = tcsetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcsetpgrp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ttyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static FunctionDescriptor ttyname$descriptor() {
        return ttyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MethodHandle ttyname$handle() {
        return ttyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MemorySegment ttyname$address() {
        return ttyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MemorySegment ttyname(int x0) {
        var mh$ = ttyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ttyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static FunctionDescriptor ttyname_r$descriptor() {
        return ttyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static MethodHandle ttyname_r$handle() {
        return ttyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static MemorySegment ttyname_r$address() {
        return ttyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static int ttyname_r(int x0, MemorySegment x1, long x2) {
        var mh$ = ttyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname_r", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static int unlink(MemorySegment x0) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static FunctionDescriptor write$descriptor() {
        return write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static MethodHandle write$handle() {
        return write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static MemorySegment write$address() {
        return write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static long write(int __fd, MemorySegment __buf, long __nbyte) {
        var mh$ = write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("write", __fd, __buf, __nbyte);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class confstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("confstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static FunctionDescriptor confstr$descriptor() {
        return confstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static MethodHandle confstr$handle() {
        return confstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static MemorySegment confstr$address() {
        return confstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static long confstr(int x0, MemorySegment x1, long x2) {
        var mh$ = confstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("confstr", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static FunctionDescriptor getopt$descriptor() {
        return getopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static MethodHandle getopt$handle() {
        return getopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static MemorySegment getopt$address() {
        return getopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static int getopt(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optarg$constants {
        public static final AddressLayout LAYOUT = opencl_h.C_POINTER;
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("optarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static AddressLayout optarg$layout() {
        return optarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg$segment() {
        return optarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg() {
        return optarg$constants.SEGMENT.get(optarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static void optarg(MemorySegment varValue) {
        optarg$constants.SEGMENT.set(optarg$constants.LAYOUT, 0L, varValue);
    }

    private static class optind$constants {
        public static final OfInt LAYOUT = opencl_h.C_INT;
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("optind").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static OfInt optind$layout() {
        return optind$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static MemorySegment optind$segment() {
        return optind$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static int optind() {
        return optind$constants.SEGMENT.get(optind$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static void optind(int varValue) {
        optind$constants.SEGMENT.set(optind$constants.LAYOUT, 0L, varValue);
    }

    private static class opterr$constants {
        public static final OfInt LAYOUT = opencl_h.C_INT;
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("opterr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static OfInt opterr$layout() {
        return opterr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static MemorySegment opterr$segment() {
        return opterr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static int opterr() {
        return opterr$constants.SEGMENT.get(opterr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static void opterr(int varValue) {
        opterr$constants.SEGMENT.set(opterr$constants.LAYOUT, 0L, varValue);
    }

    private static class optopt$constants {
        public static final OfInt LAYOUT = opencl_h.C_INT;
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("optopt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static OfInt optopt$layout() {
        return optopt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static MemorySegment optopt$segment() {
        return optopt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static int optopt() {
        return optopt$constants.SEGMENT.get(optopt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static void optopt(int varValue) {
        optopt$constants.SEGMENT.set(optopt$constants.LAYOUT, 0L, varValue);
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid(MemorySegment x0) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class brk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("brk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static FunctionDescriptor brk$descriptor() {
        return brk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MethodHandle brk$handle() {
        return brk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MemorySegment brk$address() {
        return brk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MemorySegment brk(MemorySegment x0) {
        var mh$ = brk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("brk", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chroot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("chroot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static FunctionDescriptor chroot$descriptor() {
        return chroot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static MethodHandle chroot$handle() {
        return chroot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static MemorySegment chroot$address() {
        return chroot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static int chroot(MemorySegment x0) {
        var mh$ = chroot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chroot", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("crypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static FunctionDescriptor crypt$descriptor() {
        return crypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MethodHandle crypt$handle() {
        return crypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MemorySegment crypt$address() {
        return crypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MemorySegment crypt(MemorySegment x0, MemorySegment x1) {
        var mh$ = crypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crypt", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class encrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("encrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static FunctionDescriptor encrypt$descriptor() {
        return encrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static MethodHandle encrypt$handle() {
        return encrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static MemorySegment encrypt$address() {
        return encrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static void encrypt(MemorySegment x0, int x1) {
        var mh$ = encrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("encrypt", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fchdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static FunctionDescriptor fchdir$descriptor() {
        return fchdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static MethodHandle fchdir$handle() {
        return fchdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static MemorySegment fchdir$address() {
        return fchdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static int fchdir(int x0) {
        var mh$ = fchdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static FunctionDescriptor gethostid$descriptor() {
        return gethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static MethodHandle gethostid$handle() {
        return gethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static MemorySegment gethostid$address() {
        return gethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static long gethostid() {
        var mh$ = gethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostid");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static FunctionDescriptor getpgid$descriptor() {
        return getpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static MethodHandle getpgid$handle() {
        return getpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static MemorySegment getpgid$address() {
        return getpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static int getpgid(int x0) {
        var mh$ = getpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static FunctionDescriptor getsid$descriptor() {
        return getsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static MethodHandle getsid$handle() {
        return getsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static MemorySegment getsid$address() {
        return getsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static int getsid(int x0) {
        var mh$ = getsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdtablesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getdtablesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static FunctionDescriptor getdtablesize$descriptor() {
        return getdtablesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static MethodHandle getdtablesize$handle() {
        return getdtablesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static MemorySegment getdtablesize$address() {
        return getdtablesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static int getdtablesize() {
        var mh$ = getdtablesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdtablesize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpagesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getpagesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static FunctionDescriptor getpagesize$descriptor() {
        return getpagesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static MethodHandle getpagesize$handle() {
        return getpagesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static MemorySegment getpagesize$address() {
        return getpagesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static int getpagesize() {
        var mh$ = getpagesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpagesize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getpass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static FunctionDescriptor getpass$descriptor() {
        return getpass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MethodHandle getpass$handle() {
        return getpass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MemorySegment getpass$address() {
        return getpass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MemorySegment getpass(MemorySegment x0) {
        var mh$ = getpass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpass", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static FunctionDescriptor getwd$descriptor() {
        return getwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MethodHandle getwd$handle() {
        return getwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MemorySegment getwd$address() {
        return getwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MemorySegment getwd(MemorySegment x0) {
        var mh$ = getwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwd", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("lchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor lchown$descriptor() {
        return lchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static MethodHandle lchown$handle() {
        return lchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static MemorySegment lchown$address() {
        return lchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static int lchown(MemorySegment x0, int x1, int x2) {
        var mh$ = lchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lockf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("lockf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static FunctionDescriptor lockf$descriptor() {
        return lockf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static MethodHandle lockf$handle() {
        return lockf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static MemorySegment lockf$address() {
        return lockf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static int lockf(int x0, int x1, long x2) {
        var mh$ = lockf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lockf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("nice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static FunctionDescriptor nice$descriptor() {
        return nice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static MethodHandle nice$handle() {
        return nice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static MemorySegment nice$address() {
        return nice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static int nice(int x0) {
        var mh$ = nice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nice", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("pread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static FunctionDescriptor pread$descriptor() {
        return pread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MethodHandle pread$handle() {
        return pread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MemorySegment pread$address() {
        return pread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static long pread(int __fd, MemorySegment __buf, long __nbyte, long __offset) {
        var mh$ = pread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pread", __fd, __buf, __nbyte, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("pwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static FunctionDescriptor pwrite$descriptor() {
        return pwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MethodHandle pwrite$handle() {
        return pwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MemorySegment pwrite$address() {
        return pwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static long pwrite(int __fd, MemorySegment __buf, long __nbyte, long __offset) {
        var mh$ = pwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pwrite", __fd, __buf, __nbyte, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("sbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static FunctionDescriptor sbrk$descriptor() {
        return sbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MethodHandle sbrk$handle() {
        return sbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MemorySegment sbrk$address() {
        return sbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MemorySegment sbrk(int x0) {
        var mh$ = sbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbrk", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static FunctionDescriptor setpgrp$descriptor() {
        return setpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static MethodHandle setpgrp$handle() {
        return setpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static MemorySegment setpgrp$address() {
        return setpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static int setpgrp() {
        var mh$ = setpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setregid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setregid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static FunctionDescriptor setregid$descriptor() {
        return setregid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static MethodHandle setregid$handle() {
        return setregid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static MemorySegment setregid$address() {
        return setregid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static int setregid(int x0, int x1) {
        var mh$ = setregid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setregid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setreuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setreuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static FunctionDescriptor setreuid$descriptor() {
        return setreuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static MethodHandle setreuid$handle() {
        return setreuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static MemorySegment setreuid$address() {
        return setreuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static int setreuid(int x0, int x1) {
        var mh$ = setreuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setreuid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static FunctionDescriptor sync$descriptor() {
        return sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static MethodHandle sync$handle() {
        return sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static MemorySegment sync$address() {
        return sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static void sync() {
        var mh$ = sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("truncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static FunctionDescriptor truncate$descriptor() {
        return truncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static MethodHandle truncate$handle() {
        return truncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static MemorySegment truncate$address() {
        return truncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static int truncate(MemorySegment x0, long x1) {
        var mh$ = truncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ualarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ualarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static FunctionDescriptor ualarm$descriptor() {
        return ualarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static MethodHandle ualarm$handle() {
        return ualarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static MemorySegment ualarm$address() {
        return ualarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static int ualarm(int x0, int x1) {
        var mh$ = ualarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ualarm", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class usleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("usleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static FunctionDescriptor usleep$descriptor() {
        return usleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static MethodHandle usleep$handle() {
        return usleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static MemorySegment usleep$address() {
        return usleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static int usleep(int x0) {
        var mh$ = usleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("usleep", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("vfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static FunctionDescriptor vfork$descriptor() {
        return vfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static MethodHandle vfork$handle() {
        return vfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static MemorySegment vfork$address() {
        return vfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static int vfork() {
        var mh$ = vfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfork");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fsync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static FunctionDescriptor fsync$descriptor() {
        return fsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static MethodHandle fsync$handle() {
        return fsync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static MemorySegment fsync$address() {
        return fsync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static int fsync(int x0) {
        var mh$ = fsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftruncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ftruncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static FunctionDescriptor ftruncate$descriptor() {
        return ftruncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static MethodHandle ftruncate$handle() {
        return ftruncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static MemorySegment ftruncate$address() {
        return ftruncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static int ftruncate(int x0, long x1) {
        var mh$ = ftruncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftruncate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getlogin_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static FunctionDescriptor getlogin_r$descriptor() {
        return getlogin_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static MethodHandle getlogin_r$handle() {
        return getlogin_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static MemorySegment getlogin_r$address() {
        return getlogin_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static int getlogin_r(MemorySegment x0, long x1) {
        var mh$ = getlogin_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin_r", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor fchown$descriptor() {
        return fchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static MethodHandle fchown$handle() {
        return fchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static MemorySegment fchown$address() {
        return fchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static int fchown(int x0, int x1, int x2) {
        var mh$ = fchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static FunctionDescriptor gethostname$descriptor() {
        return gethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static MethodHandle gethostname$handle() {
        return gethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static MemorySegment gethostname$address() {
        return gethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static int gethostname(MemorySegment x0, long x1) {
        var mh$ = gethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("readlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor readlink$descriptor() {
        return readlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static MethodHandle readlink$handle() {
        return readlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static MemorySegment readlink$address() {
        return readlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static long readlink(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = readlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlink", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static FunctionDescriptor setegid$descriptor() {
        return setegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static MethodHandle setegid$handle() {
        return setegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static MemorySegment setegid$address() {
        return setegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static int setegid(int x0) {
        var mh$ = setegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setegid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("seteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static FunctionDescriptor seteuid$descriptor() {
        return seteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static MethodHandle seteuid$handle() {
        return seteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static MemorySegment seteuid$address() {
        return seteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static int seteuid(int x0) {
        var mh$ = seteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seteuid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static FunctionDescriptor symlink$descriptor() {
        return symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static MethodHandle symlink$handle() {
        return symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static MemorySegment symlink$address() {
        return symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static int symlink(MemorySegment x0, MemorySegment x1) {
        var mh$ = symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlink", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = opencl_h.C_INT;

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static int pselect(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static int select(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class accessx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("accessx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static FunctionDescriptor accessx_np$descriptor() {
        return accessx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static MethodHandle accessx_np$handle() {
        return accessx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static MemorySegment accessx_np$address() {
        return accessx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static int accessx_np(MemorySegment x0, long x1, MemorySegment x2, int x3) {
        var mh$ = accessx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accessx_np", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("acct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static FunctionDescriptor acct$descriptor() {
        return acct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static MethodHandle acct$handle() {
        return acct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static MemorySegment acct$address() {
        return acct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static int acct(MemorySegment x0) {
        var mh$ = acct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acct", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class add_profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("add_profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static FunctionDescriptor add_profil$descriptor() {
        return add_profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MethodHandle add_profil$handle() {
        return add_profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MemorySegment add_profil$address() {
        return add_profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static int add_profil(MemorySegment x0, long x1, long x2, int x3) {
        var mh$ = add_profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("add_profil", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("endusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static FunctionDescriptor endusershell$descriptor() {
        return endusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static MethodHandle endusershell$handle() {
        return endusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static MemorySegment endusershell$address() {
        return endusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static void endusershell() {
        var mh$ = endusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endusershell");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execvP$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("execvP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execvP$descriptor() {
        return execvP$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static MethodHandle execvP$handle() {
        return execvP$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static MemorySegment execvP$address() {
        return execvP$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static int execvP(MemorySegment __file, MemorySegment __searchpath, MemorySegment __argv) {
        var mh$ = execvP$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvP", __file, __searchpath, __argv);
            }
            return (int)mh$.invokeExact(__file, __searchpath, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflagstostr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fflagstostr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static FunctionDescriptor fflagstostr$descriptor() {
        return fflagstostr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MethodHandle fflagstostr$handle() {
        return fflagstostr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MemorySegment fflagstostr$address() {
        return fflagstostr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MemorySegment fflagstostr(long x0) {
        var mh$ = fflagstostr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflagstostr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static FunctionDescriptor getdomainname$descriptor() {
        return getdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static MethodHandle getdomainname$handle() {
        return getdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static MemorySegment getdomainname$address() {
        return getdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static int getdomainname(MemorySegment x0, int x1) {
        var mh$ = getdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdomainname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrouplist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getgrouplist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static FunctionDescriptor getgrouplist$descriptor() {
        return getgrouplist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static MethodHandle getgrouplist$handle() {
        return getgrouplist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static MemorySegment getgrouplist$address() {
        return getgrouplist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static int getgrouplist(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = getgrouplist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrouplist", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostuuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gethostuuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static FunctionDescriptor gethostuuid$descriptor() {
        return gethostuuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static MethodHandle gethostuuid$handle() {
        return gethostuuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static MemorySegment gethostuuid$address() {
        return gethostuuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static int gethostuuid(MemorySegment x0, MemorySegment x1) {
        var mh$ = gethostuuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostuuid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_SHORT,
            opencl_h.C_POINTER,
            opencl_h.C_SHORT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static FunctionDescriptor getmode$descriptor() {
        return getmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static MethodHandle getmode$handle() {
        return getmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static MemorySegment getmode$address() {
        return getmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static short getmode(MemorySegment x0, short x1) {
        var mh$ = getmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getmode", x0, x1);
            }
            return (short)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeereid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getpeereid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static FunctionDescriptor getpeereid$descriptor() {
        return getpeereid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static MethodHandle getpeereid$handle() {
        return getpeereid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static MemorySegment getpeereid$address() {
        return getpeereid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static int getpeereid(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getpeereid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeereid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getsgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static FunctionDescriptor getsgroups_np$descriptor() {
        return getsgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static MethodHandle getsgroups_np$handle() {
        return getsgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static MemorySegment getsgroups_np$address() {
        return getsgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static int getsgroups_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = getsgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static FunctionDescriptor getusershell$descriptor() {
        return getusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MethodHandle getusershell$handle() {
        return getusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MemorySegment getusershell$address() {
        return getusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MemorySegment getusershell() {
        var mh$ = getusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getusershell");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getwgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static FunctionDescriptor getwgroups_np$descriptor() {
        return getwgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static MethodHandle getwgroups_np$handle() {
        return getwgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static MemorySegment getwgroups_np$address() {
        return getwgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static int getwgroups_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = getwgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("initgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static FunctionDescriptor initgroups$descriptor() {
        return initgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static MethodHandle initgroups$handle() {
        return initgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static MemorySegment initgroups$address() {
        return initgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static int initgroups(MemorySegment x0, int x1) {
        var mh$ = initgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class issetugid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("issetugid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static FunctionDescriptor issetugid$descriptor() {
        return issetugid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static MethodHandle issetugid$handle() {
        return issetugid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static MemorySegment issetugid$address() {
        return issetugid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static int issetugid() {
        var mh$ = issetugid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("issetugid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment x0) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_SHORT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mknod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknod$descriptor() {
        return mknod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknod$handle() {
        return mknod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknod$address() {
        return mknod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static int mknod(MemorySegment x0, short x1, int x2) {
        var mh$ = mknod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknod", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkpath_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_SHORT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkpath_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static FunctionDescriptor mkpath_np$descriptor() {
        return mkpath_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static MethodHandle mkpath_np$handle() {
        return mkpath_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static MemorySegment mkpath_np$address() {
        return mkpath_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static int mkpath_np(MemorySegment path, short omode) {
        var mh$ = mkpath_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkpath_np", path, omode);
            }
            return (int)mh$.invokeExact(path, omode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkpathat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_SHORT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkpathat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static FunctionDescriptor mkpathat_np$descriptor() {
        return mkpathat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static MethodHandle mkpathat_np$handle() {
        return mkpathat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static MemorySegment mkpathat_np$address() {
        return mkpathat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static int mkpathat_np(int dfd, MemorySegment path, short omode) {
        var mh$ = mkpathat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkpathat_np", dfd, path, omode);
            }
            return (int)mh$.invokeExact(dfd, path, omode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static int mkstemps(MemorySegment x0, int x1) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkostemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static FunctionDescriptor mkostemp$descriptor() {
        return mkostemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static MethodHandle mkostemp$handle() {
        return mkostemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static MemorySegment mkostemp$address() {
        return mkostemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static int mkostemp(MemorySegment path, int oflags) {
        var mh$ = mkostemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostemp", path, oflags);
            }
            return (int)mh$.invokeExact(path, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkostemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static FunctionDescriptor mkostemps$descriptor() {
        return mkostemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static MethodHandle mkostemps$handle() {
        return mkostemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static MemorySegment mkostemps$address() {
        return mkostemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static int mkostemps(MemorySegment path, int slen, int oflags) {
        var mh$ = mkostemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostemps", path, slen, oflags);
            }
            return (int)mh$.invokeExact(path, slen, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp_dprotected_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkstemp_dprotected_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static FunctionDescriptor mkstemp_dprotected_np$descriptor() {
        return mkstemp_dprotected_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static MethodHandle mkstemp_dprotected_np$handle() {
        return mkstemp_dprotected_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static MemorySegment mkstemp_dprotected_np$address() {
        return mkstemp_dprotected_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static int mkstemp_dprotected_np(MemorySegment path, int dpclass, int dpflags) {
        var mh$ = mkstemp_dprotected_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp_dprotected_np", path, dpclass, dpflags);
            }
            return (int)mh$.invokeExact(path, dpclass, dpflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtempat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkdtempat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static FunctionDescriptor mkdtempat_np$descriptor() {
        return mkdtempat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MethodHandle mkdtempat_np$handle() {
        return mkdtempat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MemorySegment mkdtempat_np$address() {
        return mkdtempat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MemorySegment mkdtempat_np(int dfd, MemorySegment path) {
        var mh$ = mkdtempat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtempat_np", dfd, path);
            }
            return (MemorySegment)mh$.invokeExact(dfd, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstempsat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkstempsat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static FunctionDescriptor mkstempsat_np$descriptor() {
        return mkstempsat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static MethodHandle mkstempsat_np$handle() {
        return mkstempsat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static MemorySegment mkstempsat_np$address() {
        return mkstempsat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static int mkstempsat_np(int dfd, MemorySegment path, int slen) {
        var mh$ = mkstempsat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstempsat_np", dfd, path, slen);
            }
            return (int)mh$.invokeExact(dfd, path, slen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostempsat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mkostempsat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static FunctionDescriptor mkostempsat_np$descriptor() {
        return mkostempsat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static MethodHandle mkostempsat_np$handle() {
        return mkostempsat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static MemorySegment mkostempsat_np$address() {
        return mkostempsat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static int mkostempsat_np(int dfd, MemorySegment path, int slen, int oflags) {
        var mh$ = mkostempsat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostempsat_np", dfd, path, slen, oflags);
            }
            return (int)mh$.invokeExact(dfd, path, slen, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nfssvc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("nfssvc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static FunctionDescriptor nfssvc$descriptor() {
        return nfssvc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static MethodHandle nfssvc$handle() {
        return nfssvc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static MemorySegment nfssvc$address() {
        return nfssvc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static int nfssvc(int x0, MemorySegment x1) {
        var mh$ = nfssvc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nfssvc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static FunctionDescriptor profil$descriptor() {
        return profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MethodHandle profil$handle() {
        return profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MemorySegment profil$address() {
        return profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static int profil(MemorySegment x0, long x1, long x2, int x3) {
        var mh$ = profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("profil", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setugid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("pthread_setugid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor pthread_setugid_np$descriptor() {
        return pthread_setugid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static MethodHandle pthread_setugid_np$handle() {
        return pthread_setugid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static MemorySegment pthread_setugid_np$address() {
        return pthread_setugid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static int pthread_setugid_np(int x0, int x1) {
        var mh$ = pthread_setugid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setugid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getugid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("pthread_getugid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static FunctionDescriptor pthread_getugid_np$descriptor() {
        return pthread_getugid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static MethodHandle pthread_getugid_np$handle() {
        return pthread_getugid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static MemorySegment pthread_getugid_np$address() {
        return pthread_getugid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static int pthread_getugid_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_getugid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getugid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reboot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("reboot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static FunctionDescriptor reboot$descriptor() {
        return reboot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static MethodHandle reboot$handle() {
        return reboot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static MemorySegment reboot$address() {
        return reboot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static int reboot(int x0) {
        var mh$ = reboot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reboot", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class revoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("revoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static FunctionDescriptor revoke$descriptor() {
        return revoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static MethodHandle revoke$handle() {
        return revoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static MemorySegment revoke$address() {
        return revoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static int revoke(MemorySegment x0) {
        var mh$ = revoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("revoke", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("rcmd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static FunctionDescriptor rcmd$descriptor() {
        return rcmd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static MethodHandle rcmd$handle() {
        return rcmd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static MemorySegment rcmd$address() {
        return rcmd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static int rcmd(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = rcmd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("rcmd_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static FunctionDescriptor rcmd_af$descriptor() {
        return rcmd_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static MethodHandle rcmd_af$handle() {
        return rcmd_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static MemorySegment rcmd_af$address() {
        return rcmd_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static int rcmd_af(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6) {
        var mh$ = rcmd_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd_af", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("rresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static FunctionDescriptor rresvport$descriptor() {
        return rresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static MethodHandle rresvport$handle() {
        return rresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static MemorySegment rresvport$address() {
        return rresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static int rresvport(MemorySegment x0) {
        var mh$ = rresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("rresvport_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static FunctionDescriptor rresvport_af$descriptor() {
        return rresvport_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static MethodHandle rresvport_af$handle() {
        return rresvport_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static MemorySegment rresvport_af$address() {
        return rresvport_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static int rresvport_af(MemorySegment x0, int x1) {
        var mh$ = rresvport_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport_af", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("iruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor iruserok$descriptor() {
        return iruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static MethodHandle iruserok$handle() {
        return iruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static MemorySegment iruserok$address() {
        return iruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static int iruserok(long x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = iruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok_sa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("iruserok_sa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor iruserok_sa$descriptor() {
        return iruserok_sa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static MethodHandle iruserok_sa$handle() {
        return iruserok_sa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static MemorySegment iruserok_sa$address() {
        return iruserok_sa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static int iruserok_sa(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = iruserok_sa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok_sa", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor ruserok$descriptor() {
        return ruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static MethodHandle ruserok$handle() {
        return ruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static MemorySegment ruserok$address() {
        return ruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static int ruserok(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ruserok", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static FunctionDescriptor setdomainname$descriptor() {
        return setdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static MethodHandle setdomainname$handle() {
        return setdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static MemorySegment setdomainname$address() {
        return setdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static int setdomainname(MemorySegment x0, int x1) {
        var mh$ = setdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setdomainname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static FunctionDescriptor setgroups$descriptor() {
        return setgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static MethodHandle setgroups$handle() {
        return setgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static MemorySegment setgroups$address() {
        return setgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static int setgroups(int x0, MemorySegment x1) {
        var mh$ = setgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("sethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static FunctionDescriptor sethostid$descriptor() {
        return sethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static MethodHandle sethostid$handle() {
        return sethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static MemorySegment sethostid$address() {
        return sethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static void sethostid(long x0) {
        var mh$ = sethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostid", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("sethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static FunctionDescriptor sethostname$descriptor() {
        return sethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static MethodHandle sethostname$handle() {
        return sethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static MemorySegment sethostname$address() {
        return sethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static int sethostname(MemorySegment x0, int x1) {
        var mh$ = sethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static FunctionDescriptor setlogin$descriptor() {
        return setlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static MethodHandle setlogin$handle() {
        return setlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static MemorySegment setlogin$address() {
        return setlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static int setlogin(MemorySegment x0) {
        var mh$ = setlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlogin", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static FunctionDescriptor setmode$descriptor() {
        return setmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MethodHandle setmode$handle() {
        return setmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MemorySegment setmode$address() {
        return setmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MemorySegment setmode(MemorySegment x0) {
        var mh$ = setmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setmode", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setrgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static FunctionDescriptor setrgid$descriptor() {
        return setrgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static MethodHandle setrgid$handle() {
        return setrgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static MemorySegment setrgid$address() {
        return setrgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static int setrgid(int x0) {
        var mh$ = setrgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setruid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setruid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static FunctionDescriptor setruid$descriptor() {
        return setruid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static MethodHandle setruid$handle() {
        return setruid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static MemorySegment setruid$address() {
        return setruid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static int setruid(int x0) {
        var mh$ = setruid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setruid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setsgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static FunctionDescriptor setsgroups_np$descriptor() {
        return setsgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static MethodHandle setsgroups_np$handle() {
        return setsgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static MemorySegment setsgroups_np$address() {
        return setsgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static int setsgroups_np(int x0, MemorySegment x1) {
        var mh$ = setsgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static FunctionDescriptor setusershell$descriptor() {
        return setusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static MethodHandle setusershell$handle() {
        return setusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static MemorySegment setusershell$address() {
        return setusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static void setusershell() {
        var mh$ = setusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setusershell");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setwgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setwgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static FunctionDescriptor setwgroups_np$descriptor() {
        return setwgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static MethodHandle setwgroups_np$handle() {
        return setwgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static MemorySegment setwgroups_np$address() {
        return setwgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static int setwgroups_np(int x0, MemorySegment x1) {
        var mh$ = setwgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setwgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtofflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtofflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static FunctionDescriptor strtofflags$descriptor() {
        return strtofflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static MethodHandle strtofflags$handle() {
        return strtofflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static MemorySegment strtofflags$address() {
        return strtofflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static int strtofflags(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strtofflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtofflags", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swapon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("swapon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static FunctionDescriptor swapon$descriptor() {
        return swapon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static MethodHandle swapon$handle() {
        return swapon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static MemorySegment swapon$address() {
        return swapon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static int swapon(MemorySegment x0) {
        var mh$ = swapon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swapon", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyslot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ttyslot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static FunctionDescriptor ttyslot$descriptor() {
        return ttyslot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static MethodHandle ttyslot$handle() {
        return ttyslot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static MemorySegment ttyslot$address() {
        return ttyslot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static int ttyslot() {
        var mh$ = ttyslot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyslot");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class undelete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("undelete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static FunctionDescriptor undelete$descriptor() {
        return undelete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static MethodHandle undelete$handle() {
        return undelete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static MemorySegment undelete$address() {
        return undelete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static int undelete(MemorySegment x0) {
        var mh$ = undelete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("undelete", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unwhiteout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("unwhiteout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static FunctionDescriptor unwhiteout$descriptor() {
        return unwhiteout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static MethodHandle unwhiteout$handle() {
        return unwhiteout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static MemorySegment unwhiteout$address() {
        return unwhiteout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static int unwhiteout(MemorySegment x0) {
        var mh$ = unwhiteout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unwhiteout", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc(long x0) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int syscall(int, ...)
     * }
     */
    public static class syscall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opencl_h.C_INT,
                opencl_h.C_INT
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("syscall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private syscall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int syscall(int, ...)
         * }
         */
        public static syscall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new syscall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("syscall", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = opencl_h.C_POINTER;
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fgetattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor fgetattrlist$descriptor() {
        return fgetattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle fgetattrlist$handle() {
        return fgetattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment fgetattrlist$address() {
        return fgetattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static int fgetattrlist(int x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = fgetattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fsetattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor fsetattrlist$descriptor() {
        return fsetattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle fsetattrlist$handle() {
        return fsetattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment fsetattrlist$address() {
        return fsetattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static int fsetattrlist(int x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = fsetattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor getattrlist$descriptor() {
        return getattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle getattrlist$handle() {
        return getattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment getattrlist$address() {
        return getattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static int getattrlist(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = getattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor setattrlist$descriptor() {
        return setattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle setattrlist$handle() {
        return setattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment setattrlist$address() {
        return setattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static int setattrlist(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = setattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exchangedata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("exchangedata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor exchangedata$descriptor() {
        return exchangedata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle exchangedata$handle() {
        return exchangedata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment exchangedata$address() {
        return exchangedata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static int exchangedata(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = exchangedata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exchangedata", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdirentriesattr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getdirentriesattr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static FunctionDescriptor getdirentriesattr$descriptor() {
        return getdirentriesattr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static MethodHandle getdirentriesattr$handle() {
        return getdirentriesattr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static MemorySegment getdirentriesattr$address() {
        return getdirentriesattr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static int getdirentriesattr(int x0, MemorySegment x1, MemorySegment x2, long x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7) {
        var mh$ = getdirentriesattr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdirentriesattr", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class searchfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("searchfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static FunctionDescriptor searchfs$descriptor() {
        return searchfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static MethodHandle searchfs$handle() {
        return searchfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static MemorySegment searchfs$address() {
        return searchfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static int searchfs(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5) {
        var mh$ = searchfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("searchfs", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fsctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor fsctl$descriptor() {
        return fsctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static MethodHandle fsctl$handle() {
        return fsctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static MemorySegment fsctl$address() {
        return fsctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static int fsctl(MemorySegment x0, long x1, MemorySegment x2, int x3) {
        var mh$ = fsctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsctl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ffsctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor ffsctl$descriptor() {
        return ffsctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static MethodHandle ffsctl$handle() {
        return ffsctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static MemorySegment ffsctl$address() {
        return ffsctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static int ffsctl(int x0, long x1, MemorySegment x2, int x3) {
        var mh$ = ffsctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsctl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync_volume_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fsync_volume_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static FunctionDescriptor fsync_volume_np$descriptor() {
        return fsync_volume_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static MethodHandle fsync_volume_np$handle() {
        return fsync_volume_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static MemorySegment fsync_volume_np$address() {
        return fsync_volume_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static int fsync_volume_np(int x0, int x1) {
        var mh$ = fsync_volume_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync_volume_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync_volume_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("sync_volume_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static FunctionDescriptor sync_volume_np$descriptor() {
        return sync_volume_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static MethodHandle sync_volume_np$handle() {
        return sync_volume_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static MemorySegment sync_volume_np$address() {
        return sync_volume_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static int sync_volume_np(MemorySegment x0, int x1) {
        var mh$ = sync_volume_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync_volume_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optreset$constants {
        public static final OfInt LAYOUT = opencl_h.C_INT;
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("optreset").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static OfInt optreset$layout() {
        return optreset$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static MemorySegment optreset$segment() {
        return optreset$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static int optreset() {
        return optreset$constants.SEGMENT.get(optreset$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static void optreset(int varValue) {
        optreset$constants.SEGMENT.set(optreset$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef struct _filesec *filesec_t
     * }
     */
    public static final AddressLayout filesec_t = opencl_h.C_POINTER;
    private static final int FILESEC_OWNER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FILESEC_OWNER = 1
     * }
     */
    public static int FILESEC_OWNER() {
        return FILESEC_OWNER;
    }
    private static final int FILESEC_GROUP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FILESEC_GROUP = 2
     * }
     */
    public static int FILESEC_GROUP() {
        return FILESEC_GROUP;
    }
    private static final int FILESEC_UUID = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FILESEC_UUID = 3
     * }
     */
    public static int FILESEC_UUID() {
        return FILESEC_UUID;
    }
    private static final int FILESEC_MODE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FILESEC_MODE = 4
     * }
     */
    public static int FILESEC_MODE() {
        return FILESEC_MODE;
    }
    private static final int FILESEC_ACL = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FILESEC_ACL = 5
     * }
     */
    public static int FILESEC_ACL() {
        return FILESEC_ACL;
    }
    private static final int FILESEC_GRPUUID = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FILESEC_GRPUUID = 6
     * }
     */
    public static int FILESEC_GRPUUID() {
        return FILESEC_GRPUUID;
    }
    private static final int FILESEC_ACL_RAW = (int)100L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FILESEC_ACL_RAW = 100
     * }
     */
    public static int FILESEC_ACL_RAW() {
        return FILESEC_ACL_RAW;
    }
    private static final int FILESEC_ACL_ALLOCSIZE = (int)101L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FILESEC_ACL_ALLOCSIZE = 101
     * }
     */
    public static int FILESEC_ACL_ALLOCSIZE() {
        return FILESEC_ACL_ALLOCSIZE;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int open(const char *, int, ...)
     * }
     */
    public static class open {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opencl_h.C_INT,
                opencl_h.C_POINTER,
                opencl_h.C_INT
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("open");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private open(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int open(const char *, int, ...)
         * }
         */
        public static open makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new open(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, int x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("open", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int openat(int, const char *, int, ...)
     * }
     */
    public static class openat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opencl_h.C_INT,
                opencl_h.C_INT,
                opencl_h.C_POINTER,
                opencl_h.C_INT
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("openat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private openat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int openat(int, const char *, int, ...)
         * }
         */
        public static openat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new openat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, MemorySegment x1, int x2, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("openat", x0, x1, x2, x3);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class creat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_SHORT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("creat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int creat(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor creat$descriptor() {
        return creat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int creat(const char *, mode_t)
     * }
     */
    public static MethodHandle creat$handle() {
        return creat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int creat(const char *, mode_t)
     * }
     */
    public static MemorySegment creat$address() {
        return creat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int creat(const char *, mode_t)
     * }
     */
    public static int creat(MemorySegment x0, short x1) {
        var mh$ = creat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("creat", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fcntl(int, int, ...)
     * }
     */
    public static class fcntl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opencl_h.C_INT,
                opencl_h.C_INT,
                opencl_h.C_INT
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("fcntl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fcntl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fcntl(int, int, ...)
         * }
         */
        public static fcntl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fcntl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, int x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fcntl", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class openx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("openx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openx_np(const char *, int, filesec_t)
     * }
     */
    public static FunctionDescriptor openx_np$descriptor() {
        return openx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openx_np(const char *, int, filesec_t)
     * }
     */
    public static MethodHandle openx_np$handle() {
        return openx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openx_np(const char *, int, filesec_t)
     * }
     */
    public static MemorySegment openx_np$address() {
        return openx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openx_np(const char *, int, filesec_t)
     * }
     */
    public static int openx_np(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = openx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openx_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int open_dprotected_np(const char *, int, int, int, ...)
     * }
     */
    public static class open_dprotected_np {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opencl_h.C_INT,
                opencl_h.C_POINTER,
                opencl_h.C_INT,
                opencl_h.C_INT,
                opencl_h.C_INT
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("open_dprotected_np");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private open_dprotected_np(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int open_dprotected_np(const char *, int, int, int, ...)
         * }
         */
        public static open_dprotected_np makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new open_dprotected_np(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, int x1, int x2, int x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("open_dprotected_np", x0, x1, x2, x3, x4);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int openat_dprotected_np(int, const char *, int, int, int, ...)
     * }
     */
    public static class openat_dprotected_np {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                opencl_h.C_INT,
                opencl_h.C_INT,
                opencl_h.C_POINTER,
                opencl_h.C_INT,
                opencl_h.C_INT,
                opencl_h.C_INT
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("openat_dprotected_np");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private openat_dprotected_np(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int openat_dprotected_np(int, const char *, int, int, int, ...)
         * }
         */
        public static openat_dprotected_np makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new openat_dprotected_np(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, MemorySegment x1, int x2, int x3, int x4, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("openat_dprotected_np", x0, x1, x2, x3, x4, x5);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class openat_authenticated_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("openat_authenticated_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int openat_authenticated_np(int, const char *, int, int)
     * }
     */
    public static FunctionDescriptor openat_authenticated_np$descriptor() {
        return openat_authenticated_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int openat_authenticated_np(int, const char *, int, int)
     * }
     */
    public static MethodHandle openat_authenticated_np$handle() {
        return openat_authenticated_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int openat_authenticated_np(int, const char *, int, int)
     * }
     */
    public static MemorySegment openat_authenticated_np$address() {
        return openat_authenticated_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int openat_authenticated_np(int, const char *, int, int)
     * }
     */
    public static int openat_authenticated_np(int x0, MemorySegment x1, int x2, int x3) {
        var mh$ = openat_authenticated_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("openat_authenticated_np", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("flock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flock(int, int)
     * }
     */
    public static FunctionDescriptor flock$descriptor() {
        return flock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flock(int, int)
     * }
     */
    public static MethodHandle flock$handle() {
        return flock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flock(int, int)
     * }
     */
    public static MemorySegment flock$address() {
        return flock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flock(int, int)
     * }
     */
    public static int flock(int x0, int x1) {
        var mh$ = flock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flock", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class filesec_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("filesec_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * filesec_t filesec_init()
     * }
     */
    public static FunctionDescriptor filesec_init$descriptor() {
        return filesec_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * filesec_t filesec_init()
     * }
     */
    public static MethodHandle filesec_init$handle() {
        return filesec_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * filesec_t filesec_init()
     * }
     */
    public static MemorySegment filesec_init$address() {
        return filesec_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * filesec_t filesec_init()
     * }
     */
    public static MemorySegment filesec_init() {
        var mh$ = filesec_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("filesec_init");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class filesec_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("filesec_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * filesec_t filesec_dup(filesec_t)
     * }
     */
    public static FunctionDescriptor filesec_dup$descriptor() {
        return filesec_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * filesec_t filesec_dup(filesec_t)
     * }
     */
    public static MethodHandle filesec_dup$handle() {
        return filesec_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * filesec_t filesec_dup(filesec_t)
     * }
     */
    public static MemorySegment filesec_dup$address() {
        return filesec_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * filesec_t filesec_dup(filesec_t)
     * }
     */
    public static MemorySegment filesec_dup(MemorySegment x0) {
        var mh$ = filesec_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("filesec_dup", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class filesec_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("filesec_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void filesec_free(filesec_t)
     * }
     */
    public static FunctionDescriptor filesec_free$descriptor() {
        return filesec_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void filesec_free(filesec_t)
     * }
     */
    public static MethodHandle filesec_free$handle() {
        return filesec_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void filesec_free(filesec_t)
     * }
     */
    public static MemorySegment filesec_free$address() {
        return filesec_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void filesec_free(filesec_t)
     * }
     */
    public static void filesec_free(MemorySegment x0) {
        var mh$ = filesec_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("filesec_free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class filesec_get_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("filesec_get_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int filesec_get_property(filesec_t, filesec_property_t, void *)
     * }
     */
    public static FunctionDescriptor filesec_get_property$descriptor() {
        return filesec_get_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int filesec_get_property(filesec_t, filesec_property_t, void *)
     * }
     */
    public static MethodHandle filesec_get_property$handle() {
        return filesec_get_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int filesec_get_property(filesec_t, filesec_property_t, void *)
     * }
     */
    public static MemorySegment filesec_get_property$address() {
        return filesec_get_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int filesec_get_property(filesec_t, filesec_property_t, void *)
     * }
     */
    public static int filesec_get_property(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = filesec_get_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("filesec_get_property", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class filesec_query_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("filesec_query_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int filesec_query_property(filesec_t, filesec_property_t, int *)
     * }
     */
    public static FunctionDescriptor filesec_query_property$descriptor() {
        return filesec_query_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int filesec_query_property(filesec_t, filesec_property_t, int *)
     * }
     */
    public static MethodHandle filesec_query_property$handle() {
        return filesec_query_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int filesec_query_property(filesec_t, filesec_property_t, int *)
     * }
     */
    public static MemorySegment filesec_query_property$address() {
        return filesec_query_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int filesec_query_property(filesec_t, filesec_property_t, int *)
     * }
     */
    public static int filesec_query_property(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = filesec_query_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("filesec_query_property", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class filesec_set_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("filesec_set_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int filesec_set_property(filesec_t, filesec_property_t, const void *)
     * }
     */
    public static FunctionDescriptor filesec_set_property$descriptor() {
        return filesec_set_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int filesec_set_property(filesec_t, filesec_property_t, const void *)
     * }
     */
    public static MethodHandle filesec_set_property$handle() {
        return filesec_set_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int filesec_set_property(filesec_t, filesec_property_t, const void *)
     * }
     */
    public static MemorySegment filesec_set_property$address() {
        return filesec_set_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int filesec_set_property(filesec_t, filesec_property_t, const void *)
     * }
     */
    public static int filesec_set_property(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = filesec_set_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("filesec_set_property", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class filesec_unset_property {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("filesec_unset_property");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int filesec_unset_property(filesec_t, filesec_property_t)
     * }
     */
    public static FunctionDescriptor filesec_unset_property$descriptor() {
        return filesec_unset_property.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int filesec_unset_property(filesec_t, filesec_property_t)
     * }
     */
    public static MethodHandle filesec_unset_property$handle() {
        return filesec_unset_property.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int filesec_unset_property(filesec_t, filesec_property_t)
     * }
     */
    public static MemorySegment filesec_unset_property$address() {
        return filesec_unset_property.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int filesec_unset_property(filesec_t, filesec_property_t)
     * }
     */
    public static int filesec_unset_property(MemorySegment x0, int x1) {
        var mh$ = filesec_unset_property.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("filesec_unset_property", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class os_retain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_retain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *os_retain(void *object)
     * }
     */
    public static FunctionDescriptor os_retain$descriptor() {
        return os_retain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *os_retain(void *object)
     * }
     */
    public static MethodHandle os_retain$handle() {
        return os_retain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *os_retain(void *object)
     * }
     */
    public static MemorySegment os_retain$address() {
        return os_retain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *os_retain(void *object)
     * }
     */
    public static MemorySegment os_retain(MemorySegment object) {
        var mh$ = os_retain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_retain", object);
            }
            return (MemorySegment)mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class os_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void os_release(void *object)
     * }
     */
    public static FunctionDescriptor os_release$descriptor() {
        return os_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void os_release(void *object)
     * }
     */
    public static MethodHandle os_release$handle() {
        return os_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void os_release(void *object)
     * }
     */
    public static MemorySegment os_release$address() {
        return os_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void os_release(void *object)
     * }
     */
    public static void os_release(MemorySegment object) {
        var mh$ = os_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_release", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = opencl_h.C_POINTER;

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint64_t rlim_t
     * }
     */
    public static final OfLong rlim_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *rusage_info_t
     * }
     */
    public static final AddressLayout rusage_info_t = opencl_h.C_POINTER;

    private static class getpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static FunctionDescriptor getpriority$descriptor() {
        return getpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MethodHandle getpriority$handle() {
        return getpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MemorySegment getpriority$address() {
        return getpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static int getpriority(int x0, int x1) {
        var mh$ = getpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpriority", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static FunctionDescriptor getiopolicy_np$descriptor() {
        return getiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MethodHandle getiopolicy_np$handle() {
        return getiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MemorySegment getiopolicy_np$address() {
        return getiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static int getiopolicy_np(int x0, int x1) {
        var mh$ = getiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getiopolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static FunctionDescriptor getrlimit$descriptor() {
        return getrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MethodHandle getrlimit$handle() {
        return getrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MemorySegment getrlimit$address() {
        return getrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static int getrlimit(int x0, MemorySegment x1) {
        var mh$ = getrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrusage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getrusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static FunctionDescriptor getrusage$descriptor() {
        return getrusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MethodHandle getrusage$handle() {
        return getrusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MemorySegment getrusage$address() {
        return getrusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static int getrusage(int x0, MemorySegment x1) {
        var mh$ = getrusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrusage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static FunctionDescriptor setpriority$descriptor() {
        return setpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MethodHandle setpriority$handle() {
        return setpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MemorySegment setpriority$address() {
        return setpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static int setpriority(int x0, int x1, int x2) {
        var mh$ = setpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpriority", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static FunctionDescriptor setiopolicy_np$descriptor() {
        return setiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MethodHandle setiopolicy_np$handle() {
        return setiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MemorySegment setiopolicy_np$address() {
        return setiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static int setiopolicy_np(int x0, int x1, int x2) {
        var mh$ = setiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setiopolicy_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static FunctionDescriptor setrlimit$descriptor() {
        return setrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MethodHandle setrlimit$handle() {
        return setrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MemorySegment setrlimit$address() {
        return setrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static int setrlimit(int x0, MemorySegment x1) {
        var mh$ = setrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static FunctionDescriptor wait$descriptor() {
        return wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static MethodHandle wait$handle() {
        return wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static MemorySegment wait$address() {
        return wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static int wait(MemorySegment x0) {
        var mh$ = wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static int waitpid(int x0, MemorySegment x1, int x2) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static int waitid(int x0, int x1, MemorySegment x2, int x3) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static int wait3(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static int wait4(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca(long x0) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ct_rune_t ct_rune_t
     * }
     */
    public static final OfInt ct_rune_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_rune_t rune_t
     * }
     */
    public static final OfInt rune_t = opencl_h.C_INT;

    private static class __mb_cur_max$constants {
        public static final OfInt LAYOUT = opencl_h.C_INT;
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("__mb_cur_max").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static OfInt __mb_cur_max$layout() {
        return __mb_cur_max$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static MemorySegment __mb_cur_max$segment() {
        return __mb_cur_max$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static int __mb_cur_max() {
        return __mb_cur_max$constants.SEGMENT.get(__mb_cur_max$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static void __mb_cur_max(int varValue) {
        __mb_cur_max$constants.SEGMENT.set(__mb_cur_max$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long malloc_type_id_t
     * }
     */
    public static final OfLong malloc_type_id_t = opencl_h.C_LONG_LONG;

    private static class malloc_type_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_malloc$descriptor() {
        return malloc_type_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_malloc$handle() {
        return malloc_type_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc$address() {
        return malloc_type_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc(long size, long type_id) {
        var mh$ = malloc_type_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_malloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_calloc$descriptor() {
        return malloc_type_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_calloc$handle() {
        return malloc_type_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc$address() {
        return malloc_type_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc(long count, long size, long type_id) {
        var mh$ = malloc_type_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_calloc", count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_free$descriptor() {
        return malloc_type_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_free$handle() {
        return malloc_type_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_free$address() {
        return malloc_type_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_free(MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_free", ptr, type_id);
            }
            mh$.invokeExact(ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_realloc$descriptor() {
        return malloc_type_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_realloc$handle() {
        return malloc_type_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc$address() {
        return malloc_type_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc(MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_realloc", ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_valloc$descriptor() {
        return malloc_type_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_valloc$handle() {
        return malloc_type_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc$address() {
        return malloc_type_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc(long size, long type_id) {
        var mh$ = malloc_type_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_valloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_aligned_alloc$descriptor() {
        return malloc_type_aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_aligned_alloc$handle() {
        return malloc_type_aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc$address() {
        return malloc_type_aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc(long alignment, long size, long type_id) {
        var mh$ = malloc_type_aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_aligned_alloc", alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_posix_memalign$descriptor() {
        return malloc_type_posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_posix_memalign$handle() {
        return malloc_type_posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_posix_memalign$address() {
        return malloc_type_posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static int malloc_type_posix_memalign(MemorySegment memptr, long alignment, long size, long type_id) {
        var mh$ = malloc_type_posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_posix_memalign", memptr, alignment, size, type_id);
            }
            return (int)mh$.invokeExact(memptr, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_zone_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_malloc$descriptor() {
        return malloc_type_zone_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_malloc$handle() {
        return malloc_type_zone_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc$address() {
        return malloc_type_zone_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_malloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_zone_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_calloc$descriptor() {
        return malloc_type_zone_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_calloc$handle() {
        return malloc_type_zone_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc$address() {
        return malloc_type_zone_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc(MemorySegment zone, long count, long size, long type_id) {
        var mh$ = malloc_type_zone_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_calloc", zone, count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_zone_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_free$descriptor() {
        return malloc_type_zone_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_free$handle() {
        return malloc_type_zone_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_free$address() {
        return malloc_type_zone_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_zone_free(MemorySegment zone, MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_zone_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_free", zone, ptr, type_id);
            }
            mh$.invokeExact(zone, ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_zone_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_realloc$descriptor() {
        return malloc_type_zone_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_realloc$handle() {
        return malloc_type_zone_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc$address() {
        return malloc_type_zone_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc(MemorySegment zone, MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_zone_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_realloc", zone, ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_zone_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_valloc$descriptor() {
        return malloc_type_zone_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_valloc$handle() {
        return malloc_type_zone_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc$address() {
        return malloc_type_zone_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_valloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc_type_zone_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_memalign$descriptor() {
        return malloc_type_zone_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_memalign$handle() {
        return malloc_type_zone_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign$address() {
        return malloc_type_zone_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign(MemorySegment zone, long alignment, long size, long type_id) {
        var mh$ = malloc_type_zone_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_memalign", zone, alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __count, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __count, __size);
            }
            return (MemorySegment)mh$.invokeExact(__count, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static void free(MemorySegment x0) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static int abs(int x0) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_DOUBLE,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static double atof(MemorySegment x0) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static int atoi(MemorySegment x0) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static long atol(MemorySegment x0) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static long atoll(MemorySegment x0) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int x0, int x1) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static void exit(int x0) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv(MemorySegment x0) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static long labs(long x0) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            opencl_h.C_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static long llabs(long x0) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static long mbstowcs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static int mbtowc(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void qsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static void srand(int x0) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_DOUBLE,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static double strtod(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_FLOAT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static float strtof(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static int system(MemorySegment x0) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static long wcstombs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static int wctomb(MemorySegment x0, int x1) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static long a64l(MemorySegment x0) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_DOUBLE    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_DOUBLE,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_DOUBLE,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static double erand48(MemorySegment x0) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_DOUBLE,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_DOUBLE,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt(double x0, int x1, MemorySegment x2) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grantpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("grantpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static FunctionDescriptor grantpt$descriptor() {
        return grantpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MethodHandle grantpt$handle() {
        return grantpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MemorySegment grantpt$address() {
        return grantpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static int grantpt(int x0) {
        var mh$ = grantpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grantpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate(int x0, MemorySegment x1, long x2) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static long jrand48(MemorySegment x0) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a(long x0) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static void lcong48(MemorySegment x0) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static long nrand48(MemorySegment x0) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_openpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("posix_openpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static FunctionDescriptor posix_openpt$descriptor() {
        return posix_openpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MethodHandle posix_openpt$handle() {
        return posix_openpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MemorySegment posix_openpt$address() {
        return posix_openpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static int posix_openpt(int x0) {
        var mh$ = posix_openpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_openpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ptsname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static FunctionDescriptor ptsname$descriptor() {
        return ptsname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MethodHandle ptsname$handle() {
        return ptsname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname$address() {
        return ptsname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname(int x0) {
        var mh$ = ptsname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("ptsname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static FunctionDescriptor ptsname_r$descriptor() {
        return ptsname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MethodHandle ptsname_r$handle() {
        return ptsname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MemorySegment ptsname_r$address() {
        return ptsname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static int ptsname_r(int fildes, MemorySegment buffer, long buflen) {
        var mh$ = ptsname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname_r", fildes, buffer, buflen);
            }
            return (int)mh$.invokeExact(fildes, buffer, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static int putenv(MemorySegment x0) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static int rand_r(MemorySegment x0) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("realpath$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath(MemorySegment x0, MemorySegment x1) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48(MemorySegment x0) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __overwrite) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __overwrite);
            }
            return (int)mh$.invokeExact(__name, __value, __overwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate(MemorySegment x0) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static void srand48(long x0) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static void srandom(int x0) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlockpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("unlockpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static FunctionDescriptor unlockpt$descriptor() {
        return unlockpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MethodHandle unlockpt$handle() {
        return unlockpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MemorySegment unlockpt$address() {
        return unlockpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static int unlockpt(int x0) {
        var mh$ = unlockpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlockpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static int unsetenv(MemorySegment x0) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int x1) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_SHORT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_SHORT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static int getloadavg(MemorySegment x0, int x1) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("reallocf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocf$descriptor() {
        return reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle reallocf$handle() {
        return reallocf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf$address() {
        return reallocf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf(MemorySegment __ptr, long __size) {
        var mh$ = reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocf", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int boolean_t
     * }
     */
    public static final OfInt boolean_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t natural_t
     * }
     */
    public static final OfInt natural_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int integer_t
     * }
     */
    public static final OfInt integer_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t vm_offset_t
     * }
     */
    public static final OfLong vm_offset_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t vm_size_t
     * }
     */
    public static final OfLong vm_size_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_address_t
     * }
     */
    public static final OfLong mach_vm_address_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_offset_t
     * }
     */
    public static final OfLong mach_vm_offset_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t mach_vm_size_t
     * }
     */
    public static final OfLong mach_vm_size_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_offset_t
     * }
     */
    public static final OfLong vm_map_offset_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_address_t
     * }
     */
    public static final OfLong vm_map_address_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t vm_map_size_t
     * }
     */
    public static final OfLong vm_map_size_t = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_offset_t
     * }
     */
    public static final OfInt vm32_offset_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_address_t
     * }
     */
    public static final OfInt vm32_address_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t vm32_size_t
     * }
     */
    public static final OfInt vm32_size_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef vm_offset_t mach_port_context_t
     * }
     */
    public static final OfLong mach_port_context_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_name_t
     * }
     */
    public static final OfInt mach_port_name_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_name_t *mach_port_name_array_t
     * }
     */
    public static final AddressLayout mach_port_name_array_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_t mach_port_t
     * }
     */
    public static final OfInt mach_port_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_t *mach_port_array_t
     * }
     */
    public static final AddressLayout mach_port_array_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_right_t
     * }
     */
    public static final OfInt mach_port_right_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_type_t
     * }
     */
    public static final OfInt mach_port_type_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef mach_port_type_t *mach_port_type_array_t
     * }
     */
    public static final AddressLayout mach_port_type_array_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_urefs_t
     * }
     */
    public static final OfInt mach_port_urefs_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_port_delta_t
     * }
     */
    public static final OfInt mach_port_delta_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_seqno_t
     * }
     */
    public static final OfInt mach_port_seqno_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_mscount_t
     * }
     */
    public static final OfInt mach_port_mscount_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_msgcount_t
     * }
     */
    public static final OfInt mach_port_msgcount_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_port_rights_t
     * }
     */
    public static final OfInt mach_port_rights_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_port_srights_t
     * }
     */
    public static final OfInt mach_port_srights_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t *mach_port_info_t
     * }
     */
    public static final AddressLayout mach_port_info_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int mach_port_flavor_t
     * }
     */
    public static final OfInt mach_port_flavor_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct mach_service_port_info {
     *     char mspi_string_name[255];
     *     uint8_t mspi_domain_type;
     * } *mach_service_port_info_t
     * }
     */
    public static final AddressLayout mach_service_port_info_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef mach_port_options_t *mach_port_options_ptr_t
     * }
     */
    public static final AddressLayout mach_port_options_ptr_t = opencl_h.C_POINTER;
    private static final int kGUARD_EXC_DESTROY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_DESTROY = 1
     * }
     */
    public static int kGUARD_EXC_DESTROY() {
        return kGUARD_EXC_DESTROY;
    }
    private static final int kGUARD_EXC_MOD_REFS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS = 2
     * }
     */
    public static int kGUARD_EXC_MOD_REFS() {
        return kGUARD_EXC_MOD_REFS;
    }
    private static final int kGUARD_EXC_INVALID_OPTIONS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_OPTIONS = 3
     * }
     */
    public static int kGUARD_EXC_INVALID_OPTIONS() {
        return kGUARD_EXC_INVALID_OPTIONS;
    }
    private static final int kGUARD_EXC_SET_CONTEXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SET_CONTEXT = 4
     * }
     */
    public static int kGUARD_EXC_SET_CONTEXT() {
        return kGUARD_EXC_SET_CONTEXT;
    }
    private static final int kGUARD_EXC_THREAD_SET_STATE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_THREAD_SET_STATE = 5
     * }
     */
    public static int kGUARD_EXC_THREAD_SET_STATE() {
        return kGUARD_EXC_THREAD_SET_STATE;
    }
    private static final int kGUARD_EXC_UNGUARDED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_UNGUARDED = 8
     * }
     */
    public static int kGUARD_EXC_UNGUARDED() {
        return kGUARD_EXC_UNGUARDED;
    }
    private static final int kGUARD_EXC_INCORRECT_GUARD = (int)16L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INCORRECT_GUARD = 16
     * }
     */
    public static int kGUARD_EXC_INCORRECT_GUARD() {
        return kGUARD_EXC_INCORRECT_GUARD;
    }
    private static final int kGUARD_EXC_IMMOVABLE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE = 32
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE() {
        return kGUARD_EXC_IMMOVABLE;
    }
    private static final int kGUARD_EXC_STRICT_REPLY = (int)64L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_STRICT_REPLY = 64
     * }
     */
    public static int kGUARD_EXC_STRICT_REPLY() {
        return kGUARD_EXC_STRICT_REPLY;
    }
    private static final int kGUARD_EXC_MSG_FILTERED = (int)128L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MSG_FILTERED = 128
     * }
     */
    public static int kGUARD_EXC_MSG_FILTERED() {
        return kGUARD_EXC_MSG_FILTERED;
    }
    private static final int kGUARD_EXC_INVALID_RIGHT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_RIGHT = 256
     * }
     */
    public static int kGUARD_EXC_INVALID_RIGHT() {
        return kGUARD_EXC_INVALID_RIGHT;
    }
    private static final int kGUARD_EXC_INVALID_NAME = (int)512L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_NAME = 512
     * }
     */
    public static int kGUARD_EXC_INVALID_NAME() {
        return kGUARD_EXC_INVALID_NAME;
    }
    private static final int kGUARD_EXC_INVALID_VALUE = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_VALUE = 1024
     * }
     */
    public static int kGUARD_EXC_INVALID_VALUE() {
        return kGUARD_EXC_INVALID_VALUE;
    }
    private static final int kGUARD_EXC_INVALID_ARGUMENT = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_INVALID_ARGUMENT = 2048
     * }
     */
    public static int kGUARD_EXC_INVALID_ARGUMENT() {
        return kGUARD_EXC_INVALID_ARGUMENT;
    }
    private static final int kGUARD_EXC_RIGHT_EXISTS = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RIGHT_EXISTS = 4096
     * }
     */
    public static int kGUARD_EXC_RIGHT_EXISTS() {
        return kGUARD_EXC_RIGHT_EXISTS;
    }
    private static final int kGUARD_EXC_KERN_NO_SPACE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_NO_SPACE = 8192
     * }
     */
    public static int kGUARD_EXC_KERN_NO_SPACE() {
        return kGUARD_EXC_KERN_NO_SPACE;
    }
    private static final int kGUARD_EXC_KERN_FAILURE = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_FAILURE = 16384
     * }
     */
    public static int kGUARD_EXC_KERN_FAILURE() {
        return kGUARD_EXC_KERN_FAILURE;
    }
    private static final int kGUARD_EXC_KERN_RESOURCE = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_KERN_RESOURCE = 32768
     * }
     */
    public static int kGUARD_EXC_KERN_RESOURCE() {
        return kGUARD_EXC_KERN_RESOURCE;
    }
    private static final int kGUARD_EXC_SEND_INVALID_REPLY = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_REPLY = 65536
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_REPLY() {
        return kGUARD_EXC_SEND_INVALID_REPLY;
    }
    private static final int kGUARD_EXC_SEND_INVALID_VOUCHER = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_VOUCHER = 131072
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_VOUCHER() {
        return kGUARD_EXC_SEND_INVALID_VOUCHER;
    }
    private static final int kGUARD_EXC_SEND_INVALID_RIGHT = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_SEND_INVALID_RIGHT = 262144
     * }
     */
    public static int kGUARD_EXC_SEND_INVALID_RIGHT() {
        return kGUARD_EXC_SEND_INVALID_RIGHT;
    }
    private static final int kGUARD_EXC_RCV_INVALID_NAME = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_INVALID_NAME = 524288
     * }
     */
    public static int kGUARD_EXC_RCV_INVALID_NAME() {
        return kGUARD_EXC_RCV_INVALID_NAME;
    }
    private static final int kGUARD_EXC_RCV_GUARDED_DESC = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_RCV_GUARDED_DESC = 1048576
     * }
     */
    public static int kGUARD_EXC_RCV_GUARDED_DESC() {
        return kGUARD_EXC_RCV_GUARDED_DESC;
    }
    private static final int kGUARD_EXC_MOD_REFS_NON_FATAL = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_MOD_REFS_NON_FATAL = 2097152
     * }
     */
    public static int kGUARD_EXC_MOD_REFS_NON_FATAL() {
        return kGUARD_EXC_MOD_REFS_NON_FATAL;
    }
    private static final int kGUARD_EXC_IMMOVABLE_NON_FATAL = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_IMMOVABLE_NON_FATAL = 4194304
     * }
     */
    public static int kGUARD_EXC_IMMOVABLE_NON_FATAL() {
        return kGUARD_EXC_IMMOVABLE_NON_FATAL;
    }
    private static final int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS = 8388608
     * }
     */
    public static int kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS() {
        return kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS;
    }
    private static final int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = (int)16777216L;
    /**
     * {@snippet lang=c :
     * enum mach_port_guard_exception_codes.kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE = 16777216
     * }
     */
    public static int kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE() {
        return kGUARD_EXC_EXCEPTION_BEHAVIOR_ENFORCE;
    }
    private static final int OS_CLOCK_MACH_ABSOLUTE_TIME = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OS_CLOCK_MACH_ABSOLUTE_TIME = 32
     * }
     */
    public static int OS_CLOCK_MACH_ABSOLUTE_TIME() {
        return OS_CLOCK_MACH_ABSOLUTE_TIME;
    }
    /**
     * {@snippet lang=c :
     * typedef struct os_workgroup_s *os_workgroup_t
     * }
     */
    public static final AddressLayout os_workgroup_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct os_workgroup_attr_opaque_s {
     *     uint32_t sig;
     *     char opaque[60];
     * } *os_workgroup_attr_t
     * }
     */
    public static final AddressLayout os_workgroup_attr_t = opencl_h.C_POINTER;

    private static class os_workgroup_copy_port {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_copy_port");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int os_workgroup_copy_port(os_workgroup_t  _Nonnull wg, mach_port_t * _Nonnull mach_port_out)
     * }
     */
    public static FunctionDescriptor os_workgroup_copy_port$descriptor() {
        return os_workgroup_copy_port.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int os_workgroup_copy_port(os_workgroup_t  _Nonnull wg, mach_port_t * _Nonnull mach_port_out)
     * }
     */
    public static MethodHandle os_workgroup_copy_port$handle() {
        return os_workgroup_copy_port.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int os_workgroup_copy_port(os_workgroup_t  _Nonnull wg, mach_port_t * _Nonnull mach_port_out)
     * }
     */
    public static MemorySegment os_workgroup_copy_port$address() {
        return os_workgroup_copy_port.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int os_workgroup_copy_port(os_workgroup_t  _Nonnull wg, mach_port_t * _Nonnull mach_port_out)
     * }
     */
    public static int os_workgroup_copy_port(MemorySegment wg, MemorySegment mach_port_out) {
        var mh$ = os_workgroup_copy_port.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_copy_port", wg, mach_port_out);
            }
            return (int)mh$.invokeExact(wg, mach_port_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class os_workgroup_create_with_port {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_create_with_port");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern os_workgroup_t  _Nullable os_workgroup_create_with_port(const char * _Nullable name, mach_port_t mach_port)
     * }
     */
    public static FunctionDescriptor os_workgroup_create_with_port$descriptor() {
        return os_workgroup_create_with_port.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern os_workgroup_t  _Nullable os_workgroup_create_with_port(const char * _Nullable name, mach_port_t mach_port)
     * }
     */
    public static MethodHandle os_workgroup_create_with_port$handle() {
        return os_workgroup_create_with_port.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern os_workgroup_t  _Nullable os_workgroup_create_with_port(const char * _Nullable name, mach_port_t mach_port)
     * }
     */
    public static MemorySegment os_workgroup_create_with_port$address() {
        return os_workgroup_create_with_port.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern os_workgroup_t  _Nullable os_workgroup_create_with_port(const char * _Nullable name, mach_port_t mach_port)
     * }
     */
    public static MemorySegment os_workgroup_create_with_port(MemorySegment name, int mach_port) {
        var mh$ = os_workgroup_create_with_port.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_create_with_port", name, mach_port);
            }
            return (MemorySegment)mh$.invokeExact(name, mach_port);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class os_workgroup_create_with_workgroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_create_with_workgroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern os_workgroup_t  _Nullable os_workgroup_create_with_workgroup(const char * _Nullable name, os_workgroup_t  _Nonnull wg)
     * }
     */
    public static FunctionDescriptor os_workgroup_create_with_workgroup$descriptor() {
        return os_workgroup_create_with_workgroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern os_workgroup_t  _Nullable os_workgroup_create_with_workgroup(const char * _Nullable name, os_workgroup_t  _Nonnull wg)
     * }
     */
    public static MethodHandle os_workgroup_create_with_workgroup$handle() {
        return os_workgroup_create_with_workgroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern os_workgroup_t  _Nullable os_workgroup_create_with_workgroup(const char * _Nullable name, os_workgroup_t  _Nonnull wg)
     * }
     */
    public static MemorySegment os_workgroup_create_with_workgroup$address() {
        return os_workgroup_create_with_workgroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern os_workgroup_t  _Nullable os_workgroup_create_with_workgroup(const char * _Nullable name, os_workgroup_t  _Nonnull wg)
     * }
     */
    public static MemorySegment os_workgroup_create_with_workgroup(MemorySegment name, MemorySegment wg) {
        var mh$ = os_workgroup_create_with_workgroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_create_with_workgroup", name, wg);
            }
            return (MemorySegment)mh$.invokeExact(name, wg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct os_workgroup_join_token_opaque_s {
     *     uint32_t sig;
     *     char opaque[36];
     * } *os_workgroup_join_token_t
     * }
     */
    public static final AddressLayout os_workgroup_join_token_t = opencl_h.C_POINTER;

    private static class os_workgroup_join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int os_workgroup_join(os_workgroup_t  _Nonnull wg, os_workgroup_join_token_t  _Nonnull token_out)
     * }
     */
    public static FunctionDescriptor os_workgroup_join$descriptor() {
        return os_workgroup_join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int os_workgroup_join(os_workgroup_t  _Nonnull wg, os_workgroup_join_token_t  _Nonnull token_out)
     * }
     */
    public static MethodHandle os_workgroup_join$handle() {
        return os_workgroup_join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int os_workgroup_join(os_workgroup_t  _Nonnull wg, os_workgroup_join_token_t  _Nonnull token_out)
     * }
     */
    public static MemorySegment os_workgroup_join$address() {
        return os_workgroup_join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int os_workgroup_join(os_workgroup_t  _Nonnull wg, os_workgroup_join_token_t  _Nonnull token_out)
     * }
     */
    public static int os_workgroup_join(MemorySegment wg, MemorySegment token_out) {
        var mh$ = os_workgroup_join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_join", wg, token_out);
            }
            return (int)mh$.invokeExact(wg, token_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class os_workgroup_leave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_leave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void os_workgroup_leave(os_workgroup_t  _Nonnull wg, os_workgroup_join_token_t  _Nonnull token)
     * }
     */
    public static FunctionDescriptor os_workgroup_leave$descriptor() {
        return os_workgroup_leave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void os_workgroup_leave(os_workgroup_t  _Nonnull wg, os_workgroup_join_token_t  _Nonnull token)
     * }
     */
    public static MethodHandle os_workgroup_leave$handle() {
        return os_workgroup_leave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void os_workgroup_leave(os_workgroup_t  _Nonnull wg, os_workgroup_join_token_t  _Nonnull token)
     * }
     */
    public static MemorySegment os_workgroup_leave$address() {
        return os_workgroup_leave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void os_workgroup_leave(os_workgroup_t  _Nonnull wg, os_workgroup_join_token_t  _Nonnull token)
     * }
     */
    public static void os_workgroup_leave(MemorySegment wg, MemorySegment token) {
        var mh$ = os_workgroup_leave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_leave", wg, token);
            }
            mh$.invokeExact(wg, token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t os_workgroup_index
     * }
     */
    public static final OfInt os_workgroup_index = opencl_h.C_INT;

    private static class os_workgroup_set_working_arena {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_set_working_arena");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int os_workgroup_set_working_arena(os_workgroup_t  _Nonnull wg, void * _Nullable arena, uint32_t max_workers, os_workgroup_working_arena_destructor_t  _Nonnull destructor)
     * }
     */
    public static FunctionDescriptor os_workgroup_set_working_arena$descriptor() {
        return os_workgroup_set_working_arena.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int os_workgroup_set_working_arena(os_workgroup_t  _Nonnull wg, void * _Nullable arena, uint32_t max_workers, os_workgroup_working_arena_destructor_t  _Nonnull destructor)
     * }
     */
    public static MethodHandle os_workgroup_set_working_arena$handle() {
        return os_workgroup_set_working_arena.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int os_workgroup_set_working_arena(os_workgroup_t  _Nonnull wg, void * _Nullable arena, uint32_t max_workers, os_workgroup_working_arena_destructor_t  _Nonnull destructor)
     * }
     */
    public static MemorySegment os_workgroup_set_working_arena$address() {
        return os_workgroup_set_working_arena.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int os_workgroup_set_working_arena(os_workgroup_t  _Nonnull wg, void * _Nullable arena, uint32_t max_workers, os_workgroup_working_arena_destructor_t  _Nonnull destructor)
     * }
     */
    public static int os_workgroup_set_working_arena(MemorySegment wg, MemorySegment arena, int max_workers, MemorySegment destructor) {
        var mh$ = os_workgroup_set_working_arena.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_set_working_arena", wg, arena, max_workers, destructor);
            }
            return (int)mh$.invokeExact(wg, arena, max_workers, destructor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class os_workgroup_get_working_arena {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_get_working_arena");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable os_workgroup_get_working_arena(os_workgroup_t  _Nonnull wg, os_workgroup_index * _Nullable index_out)
     * }
     */
    public static FunctionDescriptor os_workgroup_get_working_arena$descriptor() {
        return os_workgroup_get_working_arena.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable os_workgroup_get_working_arena(os_workgroup_t  _Nonnull wg, os_workgroup_index * _Nullable index_out)
     * }
     */
    public static MethodHandle os_workgroup_get_working_arena$handle() {
        return os_workgroup_get_working_arena.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable os_workgroup_get_working_arena(os_workgroup_t  _Nonnull wg, os_workgroup_index * _Nullable index_out)
     * }
     */
    public static MemorySegment os_workgroup_get_working_arena$address() {
        return os_workgroup_get_working_arena.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable os_workgroup_get_working_arena(os_workgroup_t  _Nonnull wg, os_workgroup_index * _Nullable index_out)
     * }
     */
    public static MemorySegment os_workgroup_get_working_arena(MemorySegment wg, MemorySegment index_out) {
        var mh$ = os_workgroup_get_working_arena.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_get_working_arena", wg, index_out);
            }
            return (MemorySegment)mh$.invokeExact(wg, index_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class os_workgroup_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void os_workgroup_cancel(os_workgroup_t  _Nonnull wg)
     * }
     */
    public static FunctionDescriptor os_workgroup_cancel$descriptor() {
        return os_workgroup_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void os_workgroup_cancel(os_workgroup_t  _Nonnull wg)
     * }
     */
    public static MethodHandle os_workgroup_cancel$handle() {
        return os_workgroup_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void os_workgroup_cancel(os_workgroup_t  _Nonnull wg)
     * }
     */
    public static MemorySegment os_workgroup_cancel$address() {
        return os_workgroup_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void os_workgroup_cancel(os_workgroup_t  _Nonnull wg)
     * }
     */
    public static void os_workgroup_cancel(MemorySegment wg) {
        var mh$ = os_workgroup_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_cancel", wg);
            }
            mh$.invokeExact(wg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class os_workgroup_testcancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_BOOL,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_testcancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool os_workgroup_testcancel(os_workgroup_t  _Nonnull wg)
     * }
     */
    public static FunctionDescriptor os_workgroup_testcancel$descriptor() {
        return os_workgroup_testcancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool os_workgroup_testcancel(os_workgroup_t  _Nonnull wg)
     * }
     */
    public static MethodHandle os_workgroup_testcancel$handle() {
        return os_workgroup_testcancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool os_workgroup_testcancel(os_workgroup_t  _Nonnull wg)
     * }
     */
    public static MemorySegment os_workgroup_testcancel$address() {
        return os_workgroup_testcancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool os_workgroup_testcancel(os_workgroup_t  _Nonnull wg)
     * }
     */
    public static boolean os_workgroup_testcancel(MemorySegment wg) {
        var mh$ = os_workgroup_testcancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_testcancel", wg);
            }
            return (boolean)mh$.invokeExact(wg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct os_workgroup_max_parallel_threads_attr_s *os_workgroup_mpt_attr_t
     * }
     */
    public static final AddressLayout os_workgroup_mpt_attr_t = opencl_h.C_POINTER;

    private static class os_workgroup_max_parallel_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_max_parallel_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int os_workgroup_max_parallel_threads(os_workgroup_t  _Nonnull wg, os_workgroup_mpt_attr_t  _Nullable attr)
     * }
     */
    public static FunctionDescriptor os_workgroup_max_parallel_threads$descriptor() {
        return os_workgroup_max_parallel_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int os_workgroup_max_parallel_threads(os_workgroup_t  _Nonnull wg, os_workgroup_mpt_attr_t  _Nullable attr)
     * }
     */
    public static MethodHandle os_workgroup_max_parallel_threads$handle() {
        return os_workgroup_max_parallel_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int os_workgroup_max_parallel_threads(os_workgroup_t  _Nonnull wg, os_workgroup_mpt_attr_t  _Nullable attr)
     * }
     */
    public static MemorySegment os_workgroup_max_parallel_threads$address() {
        return os_workgroup_max_parallel_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int os_workgroup_max_parallel_threads(os_workgroup_t  _Nonnull wg, os_workgroup_mpt_attr_t  _Nullable attr)
     * }
     */
    public static int os_workgroup_max_parallel_threads(MemorySegment wg, MemorySegment attr) {
        var mh$ = os_workgroup_max_parallel_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_max_parallel_threads", wg, attr);
            }
            return (int)mh$.invokeExact(wg, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef os_workgroup_t os_workgroup_interval_t
     * }
     */
    public static final AddressLayout os_workgroup_interval_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct os_workgroup_interval_data_opaque_s {
     *     uint32_t sig;
     *     char opaque[56];
     * } *os_workgroup_interval_data_t
     * }
     */
    public static final AddressLayout os_workgroup_interval_data_t = opencl_h.C_POINTER;

    private static class os_workgroup_interval_start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_interval_start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int os_workgroup_interval_start(os_workgroup_interval_t  _Nonnull wg, uint64_t start, uint64_t deadline, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static FunctionDescriptor os_workgroup_interval_start$descriptor() {
        return os_workgroup_interval_start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int os_workgroup_interval_start(os_workgroup_interval_t  _Nonnull wg, uint64_t start, uint64_t deadline, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static MethodHandle os_workgroup_interval_start$handle() {
        return os_workgroup_interval_start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int os_workgroup_interval_start(os_workgroup_interval_t  _Nonnull wg, uint64_t start, uint64_t deadline, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static MemorySegment os_workgroup_interval_start$address() {
        return os_workgroup_interval_start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int os_workgroup_interval_start(os_workgroup_interval_t  _Nonnull wg, uint64_t start, uint64_t deadline, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static int os_workgroup_interval_start(MemorySegment wg, long start, long deadline, MemorySegment data) {
        var mh$ = os_workgroup_interval_start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_interval_start", wg, start, deadline, data);
            }
            return (int)mh$.invokeExact(wg, start, deadline, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class os_workgroup_interval_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_interval_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int os_workgroup_interval_update(os_workgroup_interval_t  _Nonnull wg, uint64_t deadline, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static FunctionDescriptor os_workgroup_interval_update$descriptor() {
        return os_workgroup_interval_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int os_workgroup_interval_update(os_workgroup_interval_t  _Nonnull wg, uint64_t deadline, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static MethodHandle os_workgroup_interval_update$handle() {
        return os_workgroup_interval_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int os_workgroup_interval_update(os_workgroup_interval_t  _Nonnull wg, uint64_t deadline, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static MemorySegment os_workgroup_interval_update$address() {
        return os_workgroup_interval_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int os_workgroup_interval_update(os_workgroup_interval_t  _Nonnull wg, uint64_t deadline, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static int os_workgroup_interval_update(MemorySegment wg, long deadline, MemorySegment data) {
        var mh$ = os_workgroup_interval_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_interval_update", wg, deadline, data);
            }
            return (int)mh$.invokeExact(wg, deadline, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class os_workgroup_interval_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_interval_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int os_workgroup_interval_finish(os_workgroup_interval_t  _Nonnull wg, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static FunctionDescriptor os_workgroup_interval_finish$descriptor() {
        return os_workgroup_interval_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int os_workgroup_interval_finish(os_workgroup_interval_t  _Nonnull wg, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static MethodHandle os_workgroup_interval_finish$handle() {
        return os_workgroup_interval_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int os_workgroup_interval_finish(os_workgroup_interval_t  _Nonnull wg, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static MemorySegment os_workgroup_interval_finish$address() {
        return os_workgroup_interval_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int os_workgroup_interval_finish(os_workgroup_interval_t  _Nonnull wg, os_workgroup_interval_data_t  _Nullable data)
     * }
     */
    public static int os_workgroup_interval_finish(MemorySegment wg, MemorySegment data) {
        var mh$ = os_workgroup_interval_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_interval_finish", wg, data);
            }
            return (int)mh$.invokeExact(wg, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef os_workgroup_t os_workgroup_parallel_t
     * }
     */
    public static final AddressLayout os_workgroup_parallel_t = opencl_h.C_POINTER;

    private static class os_workgroup_parallel_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("os_workgroup_parallel_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern os_workgroup_parallel_t  _Nullable os_workgroup_parallel_create(const char * _Nullable name, os_workgroup_attr_t  _Nullable attr)
     * }
     */
    public static FunctionDescriptor os_workgroup_parallel_create$descriptor() {
        return os_workgroup_parallel_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern os_workgroup_parallel_t  _Nullable os_workgroup_parallel_create(const char * _Nullable name, os_workgroup_attr_t  _Nullable attr)
     * }
     */
    public static MethodHandle os_workgroup_parallel_create$handle() {
        return os_workgroup_parallel_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern os_workgroup_parallel_t  _Nullable os_workgroup_parallel_create(const char * _Nullable name, os_workgroup_attr_t  _Nullable attr)
     * }
     */
    public static MemorySegment os_workgroup_parallel_create$address() {
        return os_workgroup_parallel_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern os_workgroup_parallel_t  _Nullable os_workgroup_parallel_create(const char * _Nullable name, os_workgroup_attr_t  _Nullable attr)
     * }
     */
    public static MemorySegment os_workgroup_parallel_create(MemorySegment name, MemorySegment attr) {
        var mh$ = os_workgroup_parallel_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("os_workgroup_parallel_create", name, attr);
            }
            return (MemorySegment)mh$.invokeExact(name, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int alarm_type_t
     * }
     */
    public static final OfInt alarm_type_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sleep_type_t
     * }
     */
    public static final OfInt sleep_type_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int clock_id_t
     * }
     */
    public static final OfInt clock_id_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int clock_flavor_t
     * }
     */
    public static final OfInt clock_flavor_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int *clock_attr_t
     * }
     */
    public static final AddressLayout clock_attr_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int clock_res_t
     * }
     */
    public static final OfInt clock_res_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t dispatch_time_t
     * }
     */
    public static final OfLong dispatch_time_t = opencl_h.C_LONG_LONG;
    private static final long DISPATCH_WALLTIME_NOW = -2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPATCH_WALLTIME_NOW = -2
     * }
     */
    public static long DISPATCH_WALLTIME_NOW() {
        return DISPATCH_WALLTIME_NOW;
    }

    private static class dispatch_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
     * }
     */
    public static FunctionDescriptor dispatch_time$descriptor() {
        return dispatch_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
     * }
     */
    public static MethodHandle dispatch_time$handle() {
        return dispatch_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
     * }
     */
    public static MemorySegment dispatch_time$address() {
        return dispatch_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
     * }
     */
    public static long dispatch_time(long when, long delta) {
        var mh$ = dispatch_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_time", when, delta);
            }
            return (long)mh$.invokeExact(when, delta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_walltime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_walltime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_time_t dispatch_walltime(const struct timespec * _Nullable when, int64_t delta)
     * }
     */
    public static FunctionDescriptor dispatch_walltime$descriptor() {
        return dispatch_walltime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_time_t dispatch_walltime(const struct timespec * _Nullable when, int64_t delta)
     * }
     */
    public static MethodHandle dispatch_walltime$handle() {
        return dispatch_walltime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_time_t dispatch_walltime(const struct timespec * _Nullable when, int64_t delta)
     * }
     */
    public static MemorySegment dispatch_walltime$address() {
        return dispatch_walltime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_time_t dispatch_walltime(const struct timespec * _Nullable when, int64_t delta)
     * }
     */
    public static long dispatch_walltime(MemorySegment when, long delta) {
        var mh$ = dispatch_walltime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_walltime", when, delta);
            }
            return (long)mh$.invokeExact(when, delta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int QOS_CLASS_USER_INTERACTIVE = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_USER_INTERACTIVE = 33
     * }
     */
    public static int QOS_CLASS_USER_INTERACTIVE() {
        return QOS_CLASS_USER_INTERACTIVE;
    }
    private static final int QOS_CLASS_USER_INITIATED = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_USER_INITIATED = 25
     * }
     */
    public static int QOS_CLASS_USER_INITIATED() {
        return QOS_CLASS_USER_INITIATED;
    }
    private static final int QOS_CLASS_DEFAULT = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_DEFAULT = 21
     * }
     */
    public static int QOS_CLASS_DEFAULT() {
        return QOS_CLASS_DEFAULT;
    }
    private static final int QOS_CLASS_UTILITY = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_UTILITY = 17
     * }
     */
    public static int QOS_CLASS_UTILITY() {
        return QOS_CLASS_UTILITY;
    }
    private static final int QOS_CLASS_BACKGROUND = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_BACKGROUND = 9
     * }
     */
    public static int QOS_CLASS_BACKGROUND() {
        return QOS_CLASS_BACKGROUND;
    }
    private static final int QOS_CLASS_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_UNSPECIFIED = 0
     * }
     */
    public static int QOS_CLASS_UNSPECIFIED() {
        return QOS_CLASS_UNSPECIFIED;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int qos_class_t
     * }
     */
    public static final OfInt qos_class_t = opencl_h.C_INT;

    private static class qos_class_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("qos_class_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static FunctionDescriptor qos_class_self$descriptor() {
        return qos_class_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static MethodHandle qos_class_self$handle() {
        return qos_class_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static MemorySegment qos_class_self$address() {
        return qos_class_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static int qos_class_self() {
        var mh$ = qos_class_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qos_class_self");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qos_class_main {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("qos_class_main");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static FunctionDescriptor qos_class_main$descriptor() {
        return qos_class_main.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static MethodHandle qos_class_main$handle() {
        return qos_class_main.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static MemorySegment qos_class_main$address() {
        return qos_class_main.ADDR;
    }

    /**
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static int qos_class_main() {
        var mh$ = qos_class_main.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qos_class_main");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef qos_class_t dispatch_qos_class_t
     * }
     */
    public static final OfInt dispatch_qos_class_t = opencl_h.C_INT;

    private static class dispatch_retain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            dispatch_object_t.layout()
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_retain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_retain(dispatch_object_t object)
     * }
     */
    public static FunctionDescriptor dispatch_retain$descriptor() {
        return dispatch_retain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_retain(dispatch_object_t object)
     * }
     */
    public static MethodHandle dispatch_retain$handle() {
        return dispatch_retain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_retain(dispatch_object_t object)
     * }
     */
    public static MemorySegment dispatch_retain$address() {
        return dispatch_retain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_retain(dispatch_object_t object)
     * }
     */
    public static void dispatch_retain(MemorySegment object) {
        var mh$ = dispatch_retain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_retain", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            dispatch_object_t.layout()
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_release(dispatch_object_t object)
     * }
     */
    public static FunctionDescriptor dispatch_release$descriptor() {
        return dispatch_release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_release(dispatch_object_t object)
     * }
     */
    public static MethodHandle dispatch_release$handle() {
        return dispatch_release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_release(dispatch_object_t object)
     * }
     */
    public static MemorySegment dispatch_release$address() {
        return dispatch_release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_release(dispatch_object_t object)
     * }
     */
    public static void dispatch_release(MemorySegment object) {
        var mh$ = dispatch_release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_release", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_get_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            dispatch_object_t.layout()
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_get_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_get_context(dispatch_object_t object)
     * }
     */
    public static FunctionDescriptor dispatch_get_context$descriptor() {
        return dispatch_get_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_get_context(dispatch_object_t object)
     * }
     */
    public static MethodHandle dispatch_get_context$handle() {
        return dispatch_get_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_get_context(dispatch_object_t object)
     * }
     */
    public static MemorySegment dispatch_get_context$address() {
        return dispatch_get_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_get_context(dispatch_object_t object)
     * }
     */
    public static MemorySegment dispatch_get_context(MemorySegment object) {
        var mh$ = dispatch_get_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_get_context", object);
            }
            return (MemorySegment)mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_set_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            dispatch_object_t.layout(),
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_set_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_set_context(dispatch_object_t object, void * _Nullable context)
     * }
     */
    public static FunctionDescriptor dispatch_set_context$descriptor() {
        return dispatch_set_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_set_context(dispatch_object_t object, void * _Nullable context)
     * }
     */
    public static MethodHandle dispatch_set_context$handle() {
        return dispatch_set_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_set_context(dispatch_object_t object, void * _Nullable context)
     * }
     */
    public static MemorySegment dispatch_set_context$address() {
        return dispatch_set_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_set_context(dispatch_object_t object, void * _Nullable context)
     * }
     */
    public static void dispatch_set_context(MemorySegment object, MemorySegment context) {
        var mh$ = dispatch_set_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_set_context", object, context);
            }
            mh$.invokeExact(object, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_set_finalizer_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            dispatch_object_t.layout(),
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_set_finalizer_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t  _Nullable finalizer)
     * }
     */
    public static FunctionDescriptor dispatch_set_finalizer_f$descriptor() {
        return dispatch_set_finalizer_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t  _Nullable finalizer)
     * }
     */
    public static MethodHandle dispatch_set_finalizer_f$handle() {
        return dispatch_set_finalizer_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t  _Nullable finalizer)
     * }
     */
    public static MemorySegment dispatch_set_finalizer_f$address() {
        return dispatch_set_finalizer_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t  _Nullable finalizer)
     * }
     */
    public static void dispatch_set_finalizer_f(MemorySegment object, MemorySegment finalizer) {
        var mh$ = dispatch_set_finalizer_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_set_finalizer_f", object, finalizer);
            }
            mh$.invokeExact(object, finalizer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_activate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            dispatch_object_t.layout()
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_activate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_activate(dispatch_object_t object)
     * }
     */
    public static FunctionDescriptor dispatch_activate$descriptor() {
        return dispatch_activate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_activate(dispatch_object_t object)
     * }
     */
    public static MethodHandle dispatch_activate$handle() {
        return dispatch_activate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_activate(dispatch_object_t object)
     * }
     */
    public static MemorySegment dispatch_activate$address() {
        return dispatch_activate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_activate(dispatch_object_t object)
     * }
     */
    public static void dispatch_activate(MemorySegment object) {
        var mh$ = dispatch_activate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_activate", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_suspend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            dispatch_object_t.layout()
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_suspend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_suspend(dispatch_object_t object)
     * }
     */
    public static FunctionDescriptor dispatch_suspend$descriptor() {
        return dispatch_suspend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_suspend(dispatch_object_t object)
     * }
     */
    public static MethodHandle dispatch_suspend$handle() {
        return dispatch_suspend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_suspend(dispatch_object_t object)
     * }
     */
    public static MemorySegment dispatch_suspend$address() {
        return dispatch_suspend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_suspend(dispatch_object_t object)
     * }
     */
    public static void dispatch_suspend(MemorySegment object) {
        var mh$ = dispatch_suspend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_suspend", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_resume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            dispatch_object_t.layout()
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_resume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_resume(dispatch_object_t object)
     * }
     */
    public static FunctionDescriptor dispatch_resume$descriptor() {
        return dispatch_resume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_resume(dispatch_object_t object)
     * }
     */
    public static MethodHandle dispatch_resume$handle() {
        return dispatch_resume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_resume(dispatch_object_t object)
     * }
     */
    public static MemorySegment dispatch_resume$address() {
        return dispatch_resume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_resume(dispatch_object_t object)
     * }
     */
    public static void dispatch_resume(MemorySegment object) {
        var mh$ = dispatch_resume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_resume", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_set_qos_class_floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            dispatch_object_t.layout(),
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_set_qos_class_floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_set_qos_class_floor(dispatch_object_t object, dispatch_qos_class_t qos_class, int relative_priority)
     * }
     */
    public static FunctionDescriptor dispatch_set_qos_class_floor$descriptor() {
        return dispatch_set_qos_class_floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_set_qos_class_floor(dispatch_object_t object, dispatch_qos_class_t qos_class, int relative_priority)
     * }
     */
    public static MethodHandle dispatch_set_qos_class_floor$handle() {
        return dispatch_set_qos_class_floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_set_qos_class_floor(dispatch_object_t object, dispatch_qos_class_t qos_class, int relative_priority)
     * }
     */
    public static MemorySegment dispatch_set_qos_class_floor$address() {
        return dispatch_set_qos_class_floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_set_qos_class_floor(dispatch_object_t object, dispatch_qos_class_t qos_class, int relative_priority)
     * }
     */
    public static void dispatch_set_qos_class_floor(MemorySegment object, int qos_class, int relative_priority) {
        var mh$ = dispatch_set_qos_class_floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_set_qos_class_floor", object, qos_class, relative_priority);
            }
            mh$.invokeExact(object, qos_class, relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_wait(void * _Nonnull object, dispatch_time_t timeout)
     * }
     */
    public static FunctionDescriptor dispatch_wait$descriptor() {
        return dispatch_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_wait(void * _Nonnull object, dispatch_time_t timeout)
     * }
     */
    public static MethodHandle dispatch_wait$handle() {
        return dispatch_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_wait(void * _Nonnull object, dispatch_time_t timeout)
     * }
     */
    public static MemorySegment dispatch_wait$address() {
        return dispatch_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intptr_t dispatch_wait(void * _Nonnull object, dispatch_time_t timeout)
     * }
     */
    public static long dispatch_wait(MemorySegment object, long timeout) {
        var mh$ = dispatch_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_wait", object, timeout);
            }
            return (long)mh$.invokeExact(object, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_notify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            dispatch_object_t.layout(),
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_notify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_notify(void * _Nonnull object, dispatch_object_t queue, dispatch_block_t  _Nonnull notification_block)
     * }
     */
    public static FunctionDescriptor dispatch_notify$descriptor() {
        return dispatch_notify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_notify(void * _Nonnull object, dispatch_object_t queue, dispatch_block_t  _Nonnull notification_block)
     * }
     */
    public static MethodHandle dispatch_notify$handle() {
        return dispatch_notify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_notify(void * _Nonnull object, dispatch_object_t queue, dispatch_block_t  _Nonnull notification_block)
     * }
     */
    public static MemorySegment dispatch_notify$address() {
        return dispatch_notify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_notify(void * _Nonnull object, dispatch_object_t queue, dispatch_block_t  _Nonnull notification_block)
     * }
     */
    public static void dispatch_notify(MemorySegment object, MemorySegment queue, MemorySegment notification_block) {
        var mh$ = dispatch_notify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_notify", object, queue, notification_block);
            }
            mh$.invokeExact(object, queue, notification_block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_cancel(void * _Nonnull object)
     * }
     */
    public static FunctionDescriptor dispatch_cancel$descriptor() {
        return dispatch_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_cancel(void * _Nonnull object)
     * }
     */
    public static MethodHandle dispatch_cancel$handle() {
        return dispatch_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_cancel(void * _Nonnull object)
     * }
     */
    public static MemorySegment dispatch_cancel$address() {
        return dispatch_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_cancel(void * _Nonnull object)
     * }
     */
    public static void dispatch_cancel(MemorySegment object) {
        var mh$ = dispatch_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_cancel", object);
            }
            mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_testcancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_testcancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_testcancel(void * _Nonnull object)
     * }
     */
    public static FunctionDescriptor dispatch_testcancel$descriptor() {
        return dispatch_testcancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_testcancel(void * _Nonnull object)
     * }
     */
    public static MethodHandle dispatch_testcancel$handle() {
        return dispatch_testcancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_testcancel(void * _Nonnull object)
     * }
     */
    public static MemorySegment dispatch_testcancel$address() {
        return dispatch_testcancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intptr_t dispatch_testcancel(void * _Nonnull object)
     * }
     */
    public static long dispatch_testcancel(MemorySegment object) {
        var mh$ = dispatch_testcancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_testcancel", object);
            }
            return (long)mh$.invokeExact(object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void dispatch_debug(dispatch_object_t object, const char * _Nonnull message, ...)
     * }
     */
    public static class dispatch_debug {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                dispatch_object_t.layout(),
                opencl_h.C_POINTER
            );
        private static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_debug");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dispatch_debug(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void dispatch_debug(dispatch_object_t object, const char * _Nonnull message, ...)
         * }
         */
        public static dispatch_debug makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dispatch_debug(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment object, MemorySegment message, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dispatch_debug", object, message, x2);
                }
                spreader.invokeExact(object, message, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class dispatch_debugv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            dispatch_object_t.layout(),
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_debugv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_debugv(dispatch_object_t object, const char * _Nonnull message, va_list ap)
     * }
     */
    public static FunctionDescriptor dispatch_debugv$descriptor() {
        return dispatch_debugv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_debugv(dispatch_object_t object, const char * _Nonnull message, va_list ap)
     * }
     */
    public static MethodHandle dispatch_debugv$handle() {
        return dispatch_debugv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_debugv(dispatch_object_t object, const char * _Nonnull message, va_list ap)
     * }
     */
    public static MemorySegment dispatch_debugv$address() {
        return dispatch_debugv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_debugv(dispatch_object_t object, const char * _Nonnull message, va_list ap)
     * }
     */
    public static void dispatch_debugv(MemorySegment object, MemorySegment message, MemorySegment ap) {
        var mh$ = dispatch_debugv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_debugv", object, message, ap);
            }
            mh$.invokeExact(object, message, ap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct dispatch_queue_s *dispatch_queue_t
     * }
     */
    public static final AddressLayout dispatch_queue_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef dispatch_queue_t dispatch_queue_global_t
     * }
     */
    public static final AddressLayout dispatch_queue_global_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef dispatch_queue_t dispatch_queue_serial_executor_t
     * }
     */
    public static final AddressLayout dispatch_queue_serial_executor_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef dispatch_queue_t dispatch_queue_serial_t
     * }
     */
    public static final AddressLayout dispatch_queue_serial_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef dispatch_queue_serial_t dispatch_queue_main_t
     * }
     */
    public static final AddressLayout dispatch_queue_main_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef dispatch_queue_t dispatch_queue_concurrent_t
     * }
     */
    public static final AddressLayout dispatch_queue_concurrent_t = opencl_h.C_POINTER;

    private static class dispatch_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_async(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_async$descriptor() {
        return dispatch_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_async(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_async$handle() {
        return dispatch_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_async(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_async$address() {
        return dispatch_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_async(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_async(MemorySegment queue, MemorySegment block) {
        var mh$ = dispatch_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_async", queue, block);
            }
            mh$.invokeExact(queue, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_async_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_async_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_async_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static FunctionDescriptor dispatch_async_f$descriptor() {
        return dispatch_async_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_async_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MethodHandle dispatch_async_f$handle() {
        return dispatch_async_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_async_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MemorySegment dispatch_async_f$address() {
        return dispatch_async_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_async_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static void dispatch_async_f(MemorySegment queue, MemorySegment context, MemorySegment work) {
        var mh$ = dispatch_async_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_async_f", queue, context, work);
            }
            mh$.invokeExact(queue, context, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_sync(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_sync$descriptor() {
        return dispatch_sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_sync(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_sync$handle() {
        return dispatch_sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_sync(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_sync$address() {
        return dispatch_sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_sync(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_sync(MemorySegment queue, MemorySegment block) {
        var mh$ = dispatch_sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_sync", queue, block);
            }
            mh$.invokeExact(queue, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_sync_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_sync_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_sync_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static FunctionDescriptor dispatch_sync_f$descriptor() {
        return dispatch_sync_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_sync_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MethodHandle dispatch_sync_f$handle() {
        return dispatch_sync_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_sync_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MemorySegment dispatch_sync_f$address() {
        return dispatch_sync_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_sync_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static void dispatch_sync_f(MemorySegment queue, MemorySegment context, MemorySegment work) {
        var mh$ = dispatch_sync_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_sync_f", queue, context, work);
            }
            mh$.invokeExact(queue, context, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_async_and_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_async_and_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_async_and_wait(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_async_and_wait$descriptor() {
        return dispatch_async_and_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_async_and_wait(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_async_and_wait$handle() {
        return dispatch_async_and_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_async_and_wait(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_async_and_wait$address() {
        return dispatch_async_and_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_async_and_wait(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_async_and_wait(MemorySegment queue, MemorySegment block) {
        var mh$ = dispatch_async_and_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_async_and_wait", queue, block);
            }
            mh$.invokeExact(queue, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_async_and_wait_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_async_and_wait_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_async_and_wait_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static FunctionDescriptor dispatch_async_and_wait_f$descriptor() {
        return dispatch_async_and_wait_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_async_and_wait_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MethodHandle dispatch_async_and_wait_f$handle() {
        return dispatch_async_and_wait_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_async_and_wait_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MemorySegment dispatch_async_and_wait_f$address() {
        return dispatch_async_and_wait_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_async_and_wait_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static void dispatch_async_and_wait_f(MemorySegment queue, MemorySegment context, MemorySegment work) {
        var mh$ = dispatch_async_and_wait_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_async_and_wait_f", queue, context, work);
            }
            mh$.invokeExact(queue, context, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_apply(size_t iterations, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull block)(size_t))
     * }
     */
    public static FunctionDescriptor dispatch_apply$descriptor() {
        return dispatch_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_apply(size_t iterations, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull block)(size_t))
     * }
     */
    public static MethodHandle dispatch_apply$handle() {
        return dispatch_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_apply(size_t iterations, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull block)(size_t))
     * }
     */
    public static MemorySegment dispatch_apply$address() {
        return dispatch_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_apply(size_t iterations, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull block)(size_t))
     * }
     */
    public static void dispatch_apply(long iterations, MemorySegment queue, MemorySegment block) {
        var mh$ = dispatch_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_apply", iterations, queue, block);
            }
            mh$.invokeExact(iterations, queue, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_apply_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_apply_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_apply_f(size_t iterations, dispatch_queue_t  _Nonnull queue, void * _Nullable context, void (* _Nonnull work)(void * _Nullable, size_t))
     * }
     */
    public static FunctionDescriptor dispatch_apply_f$descriptor() {
        return dispatch_apply_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_apply_f(size_t iterations, dispatch_queue_t  _Nonnull queue, void * _Nullable context, void (* _Nonnull work)(void * _Nullable, size_t))
     * }
     */
    public static MethodHandle dispatch_apply_f$handle() {
        return dispatch_apply_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_apply_f(size_t iterations, dispatch_queue_t  _Nonnull queue, void * _Nullable context, void (* _Nonnull work)(void * _Nullable, size_t))
     * }
     */
    public static MemorySegment dispatch_apply_f$address() {
        return dispatch_apply_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_apply_f(size_t iterations, dispatch_queue_t  _Nonnull queue, void * _Nullable context, void (* _Nonnull work)(void * _Nullable, size_t))
     * }
     */
    public static void dispatch_apply_f(long iterations, MemorySegment queue, MemorySegment context, MemorySegment work) {
        var mh$ = dispatch_apply_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_apply_f", iterations, queue, context, work);
            }
            mh$.invokeExact(iterations, queue, context, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_get_current_queue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_get_current_queue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_get_current_queue()
     * }
     */
    public static FunctionDescriptor dispatch_get_current_queue$descriptor() {
        return dispatch_get_current_queue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_get_current_queue()
     * }
     */
    public static MethodHandle dispatch_get_current_queue$handle() {
        return dispatch_get_current_queue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_get_current_queue()
     * }
     */
    public static MemorySegment dispatch_get_current_queue$address() {
        return dispatch_get_current_queue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_get_current_queue()
     * }
     */
    public static MemorySegment dispatch_get_current_queue() {
        var mh$ = dispatch_get_current_queue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_get_current_queue");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long dispatch_queue_priority_t
     * }
     */
    public static final OfLong dispatch_queue_priority_t = opencl_h.C_LONG;

    private static class dispatch_get_global_queue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_get_global_queue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_queue_global_t  _Nonnull dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
     * }
     */
    public static FunctionDescriptor dispatch_get_global_queue$descriptor() {
        return dispatch_get_global_queue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_queue_global_t  _Nonnull dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
     * }
     */
    public static MethodHandle dispatch_get_global_queue$handle() {
        return dispatch_get_global_queue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_queue_global_t  _Nonnull dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
     * }
     */
    public static MemorySegment dispatch_get_global_queue$address() {
        return dispatch_get_global_queue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_queue_global_t  _Nonnull dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
     * }
     */
    public static MemorySegment dispatch_get_global_queue(long identifier, long flags) {
        var mh$ = dispatch_get_global_queue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_get_global_queue", identifier, flags);
            }
            return (MemorySegment)mh$.invokeExact(identifier, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct dispatch_queue_attr_s *dispatch_queue_attr_t
     * }
     */
    public static final AddressLayout dispatch_queue_attr_t = opencl_h.C_POINTER;

    private static class dispatch_queue_attr_make_initially_inactive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_queue_attr_make_initially_inactive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t  _Nullable attr)
     * }
     */
    public static FunctionDescriptor dispatch_queue_attr_make_initially_inactive$descriptor() {
        return dispatch_queue_attr_make_initially_inactive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t  _Nullable attr)
     * }
     */
    public static MethodHandle dispatch_queue_attr_make_initially_inactive$handle() {
        return dispatch_queue_attr_make_initially_inactive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t  _Nullable attr)
     * }
     */
    public static MemorySegment dispatch_queue_attr_make_initially_inactive$address() {
        return dispatch_queue_attr_make_initially_inactive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t  _Nullable attr)
     * }
     */
    public static MemorySegment dispatch_queue_attr_make_initially_inactive(MemorySegment attr) {
        var mh$ = dispatch_queue_attr_make_initially_inactive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_queue_attr_make_initially_inactive", attr);
            }
            return (MemorySegment)mh$.invokeExact(attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long DISPATCH_AUTORELEASE_FREQUENCY_INHERIT = 0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPATCH_AUTORELEASE_FREQUENCY_INHERIT = 0
     * }
     */
    public static long DISPATCH_AUTORELEASE_FREQUENCY_INHERIT() {
        return DISPATCH_AUTORELEASE_FREQUENCY_INHERIT;
    }
    private static final long DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM = 1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM = 1
     * }
     */
    public static long DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM() {
        return DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM;
    }
    private static final long DISPATCH_AUTORELEASE_FREQUENCY_NEVER = 2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPATCH_AUTORELEASE_FREQUENCY_NEVER = 2
     * }
     */
    public static long DISPATCH_AUTORELEASE_FREQUENCY_NEVER() {
        return DISPATCH_AUTORELEASE_FREQUENCY_NEVER;
    }

    private static class dispatch_queue_attr_make_with_autorelease_frequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_queue_attr_make_with_autorelease_frequency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t  _Nullable attr, dispatch_autorelease_frequency_t frequency)
     * }
     */
    public static FunctionDescriptor dispatch_queue_attr_make_with_autorelease_frequency$descriptor() {
        return dispatch_queue_attr_make_with_autorelease_frequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t  _Nullable attr, dispatch_autorelease_frequency_t frequency)
     * }
     */
    public static MethodHandle dispatch_queue_attr_make_with_autorelease_frequency$handle() {
        return dispatch_queue_attr_make_with_autorelease_frequency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t  _Nullable attr, dispatch_autorelease_frequency_t frequency)
     * }
     */
    public static MemorySegment dispatch_queue_attr_make_with_autorelease_frequency$address() {
        return dispatch_queue_attr_make_with_autorelease_frequency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t  _Nullable attr, dispatch_autorelease_frequency_t frequency)
     * }
     */
    public static MemorySegment dispatch_queue_attr_make_with_autorelease_frequency(MemorySegment attr, long frequency) {
        var mh$ = dispatch_queue_attr_make_with_autorelease_frequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_queue_attr_make_with_autorelease_frequency", attr, frequency);
            }
            return (MemorySegment)mh$.invokeExact(attr, frequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_queue_attr_make_with_qos_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_queue_attr_make_with_qos_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t  _Nullable attr, dispatch_qos_class_t qos_class, int relative_priority)
     * }
     */
    public static FunctionDescriptor dispatch_queue_attr_make_with_qos_class$descriptor() {
        return dispatch_queue_attr_make_with_qos_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t  _Nullable attr, dispatch_qos_class_t qos_class, int relative_priority)
     * }
     */
    public static MethodHandle dispatch_queue_attr_make_with_qos_class$handle() {
        return dispatch_queue_attr_make_with_qos_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t  _Nullable attr, dispatch_qos_class_t qos_class, int relative_priority)
     * }
     */
    public static MemorySegment dispatch_queue_attr_make_with_qos_class$address() {
        return dispatch_queue_attr_make_with_qos_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_queue_attr_t  _Nonnull dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t  _Nullable attr, dispatch_qos_class_t qos_class, int relative_priority)
     * }
     */
    public static MemorySegment dispatch_queue_attr_make_with_qos_class(MemorySegment attr, int qos_class, int relative_priority) {
        var mh$ = dispatch_queue_attr_make_with_qos_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_queue_attr_make_with_qos_class", attr, qos_class, relative_priority);
            }
            return (MemorySegment)mh$.invokeExact(attr, qos_class, relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_queue_create_with_target {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_queue_create_with_target$V2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_queue_create_with_target(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr, dispatch_queue_t  _Nullable target)
     * }
     */
    public static FunctionDescriptor dispatch_queue_create_with_target$descriptor() {
        return dispatch_queue_create_with_target.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_queue_create_with_target(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr, dispatch_queue_t  _Nullable target)
     * }
     */
    public static MethodHandle dispatch_queue_create_with_target$handle() {
        return dispatch_queue_create_with_target.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_queue_create_with_target(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr, dispatch_queue_t  _Nullable target)
     * }
     */
    public static MemorySegment dispatch_queue_create_with_target$address() {
        return dispatch_queue_create_with_target.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_queue_create_with_target(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr, dispatch_queue_t  _Nullable target)
     * }
     */
    public static MemorySegment dispatch_queue_create_with_target(MemorySegment label, MemorySegment attr, MemorySegment target) {
        var mh$ = dispatch_queue_create_with_target.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_queue_create_with_target", label, attr, target);
            }
            return (MemorySegment)mh$.invokeExact(label, attr, target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_queue_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_queue_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_queue_create(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr)
     * }
     */
    public static FunctionDescriptor dispatch_queue_create$descriptor() {
        return dispatch_queue_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_queue_create(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr)
     * }
     */
    public static MethodHandle dispatch_queue_create$handle() {
        return dispatch_queue_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_queue_create(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr)
     * }
     */
    public static MemorySegment dispatch_queue_create$address() {
        return dispatch_queue_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nonnull dispatch_queue_create(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr)
     * }
     */
    public static MemorySegment dispatch_queue_create(MemorySegment label, MemorySegment attr) {
        var mh$ = dispatch_queue_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_queue_create", label, attr);
            }
            return (MemorySegment)mh$.invokeExact(label, attr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_queue_get_label {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_queue_get_label");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char * _Nonnull dispatch_queue_get_label(dispatch_queue_t  _Nullable queue)
     * }
     */
    public static FunctionDescriptor dispatch_queue_get_label$descriptor() {
        return dispatch_queue_get_label.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char * _Nonnull dispatch_queue_get_label(dispatch_queue_t  _Nullable queue)
     * }
     */
    public static MethodHandle dispatch_queue_get_label$handle() {
        return dispatch_queue_get_label.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char * _Nonnull dispatch_queue_get_label(dispatch_queue_t  _Nullable queue)
     * }
     */
    public static MemorySegment dispatch_queue_get_label$address() {
        return dispatch_queue_get_label.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char * _Nonnull dispatch_queue_get_label(dispatch_queue_t  _Nullable queue)
     * }
     */
    public static MemorySegment dispatch_queue_get_label(MemorySegment queue) {
        var mh$ = dispatch_queue_get_label.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_queue_get_label", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_queue_get_qos_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_queue_get_qos_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t  _Nonnull queue, int * _Nullable relative_priority_ptr)
     * }
     */
    public static FunctionDescriptor dispatch_queue_get_qos_class$descriptor() {
        return dispatch_queue_get_qos_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t  _Nonnull queue, int * _Nullable relative_priority_ptr)
     * }
     */
    public static MethodHandle dispatch_queue_get_qos_class$handle() {
        return dispatch_queue_get_qos_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t  _Nonnull queue, int * _Nullable relative_priority_ptr)
     * }
     */
    public static MemorySegment dispatch_queue_get_qos_class$address() {
        return dispatch_queue_get_qos_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t  _Nonnull queue, int * _Nullable relative_priority_ptr)
     * }
     */
    public static int dispatch_queue_get_qos_class(MemorySegment queue, MemorySegment relative_priority_ptr) {
        var mh$ = dispatch_queue_get_qos_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_queue_get_qos_class", queue, relative_priority_ptr);
            }
            return (int)mh$.invokeExact(queue, relative_priority_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_set_target_queue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            dispatch_object_t.layout(),
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_set_target_queue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t  _Nullable queue)
     * }
     */
    public static FunctionDescriptor dispatch_set_target_queue$descriptor() {
        return dispatch_set_target_queue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t  _Nullable queue)
     * }
     */
    public static MethodHandle dispatch_set_target_queue$handle() {
        return dispatch_set_target_queue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t  _Nullable queue)
     * }
     */
    public static MemorySegment dispatch_set_target_queue$address() {
        return dispatch_set_target_queue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t  _Nullable queue)
     * }
     */
    public static void dispatch_set_target_queue(MemorySegment object, MemorySegment queue) {
        var mh$ = dispatch_set_target_queue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_set_target_queue", object, queue);
            }
            mh$.invokeExact(object, queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_main {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_main");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_main()
     * }
     */
    public static FunctionDescriptor dispatch_main$descriptor() {
        return dispatch_main.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_main()
     * }
     */
    public static MethodHandle dispatch_main$handle() {
        return dispatch_main.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_main()
     * }
     */
    public static MemorySegment dispatch_main$address() {
        return dispatch_main.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_main()
     * }
     */
    public static void dispatch_main() {
        var mh$ = dispatch_main.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_main");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_after {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_after");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_after(dispatch_time_t when, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_after$descriptor() {
        return dispatch_after.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_after(dispatch_time_t when, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_after$handle() {
        return dispatch_after.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_after(dispatch_time_t when, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_after$address() {
        return dispatch_after.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_after(dispatch_time_t when, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_after(long when, MemorySegment queue, MemorySegment block) {
        var mh$ = dispatch_after.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_after", when, queue, block);
            }
            mh$.invokeExact(when, queue, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_after_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_after_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_after_f(dispatch_time_t when, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static FunctionDescriptor dispatch_after_f$descriptor() {
        return dispatch_after_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_after_f(dispatch_time_t when, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MethodHandle dispatch_after_f$handle() {
        return dispatch_after_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_after_f(dispatch_time_t when, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MemorySegment dispatch_after_f$address() {
        return dispatch_after_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_after_f(dispatch_time_t when, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static void dispatch_after_f(long when, MemorySegment queue, MemorySegment context, MemorySegment work) {
        var mh$ = dispatch_after_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_after_f", when, queue, context, work);
            }
            mh$.invokeExact(when, queue, context, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_barrier_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_barrier_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_barrier_async$descriptor() {
        return dispatch_barrier_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_barrier_async$handle() {
        return dispatch_barrier_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_barrier_async$address() {
        return dispatch_barrier_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_barrier_async(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_barrier_async(MemorySegment queue, MemorySegment block) {
        var mh$ = dispatch_barrier_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_barrier_async", queue, block);
            }
            mh$.invokeExact(queue, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_barrier_async_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_barrier_async_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static FunctionDescriptor dispatch_barrier_async_f$descriptor() {
        return dispatch_barrier_async_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MethodHandle dispatch_barrier_async_f$handle() {
        return dispatch_barrier_async_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MemorySegment dispatch_barrier_async_f$address() {
        return dispatch_barrier_async_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static void dispatch_barrier_async_f(MemorySegment queue, MemorySegment context, MemorySegment work) {
        var mh$ = dispatch_barrier_async_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_barrier_async_f", queue, context, work);
            }
            mh$.invokeExact(queue, context, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_barrier_sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_barrier_sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_sync(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_barrier_sync$descriptor() {
        return dispatch_barrier_sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_sync(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_barrier_sync$handle() {
        return dispatch_barrier_sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_sync(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_barrier_sync$address() {
        return dispatch_barrier_sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_barrier_sync(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_barrier_sync(MemorySegment queue, MemorySegment block) {
        var mh$ = dispatch_barrier_sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_barrier_sync", queue, block);
            }
            mh$.invokeExact(queue, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_barrier_sync_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_barrier_sync_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_sync_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static FunctionDescriptor dispatch_barrier_sync_f$descriptor() {
        return dispatch_barrier_sync_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_sync_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MethodHandle dispatch_barrier_sync_f$handle() {
        return dispatch_barrier_sync_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_sync_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MemorySegment dispatch_barrier_sync_f$address() {
        return dispatch_barrier_sync_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_barrier_sync_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static void dispatch_barrier_sync_f(MemorySegment queue, MemorySegment context, MemorySegment work) {
        var mh$ = dispatch_barrier_sync_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_barrier_sync_f", queue, context, work);
            }
            mh$.invokeExact(queue, context, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_barrier_async_and_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_barrier_async_and_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_and_wait(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_barrier_async_and_wait$descriptor() {
        return dispatch_barrier_async_and_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_and_wait(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_barrier_async_and_wait$handle() {
        return dispatch_barrier_async_and_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_and_wait(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_barrier_async_and_wait$address() {
        return dispatch_barrier_async_and_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_and_wait(dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_barrier_async_and_wait(MemorySegment queue, MemorySegment block) {
        var mh$ = dispatch_barrier_async_and_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_barrier_async_and_wait", queue, block);
            }
            mh$.invokeExact(queue, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_barrier_async_and_wait_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_barrier_async_and_wait_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_and_wait_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static FunctionDescriptor dispatch_barrier_async_and_wait_f$descriptor() {
        return dispatch_barrier_async_and_wait_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_and_wait_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MethodHandle dispatch_barrier_async_and_wait_f$handle() {
        return dispatch_barrier_async_and_wait_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_and_wait_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MemorySegment dispatch_barrier_async_and_wait_f$address() {
        return dispatch_barrier_async_and_wait_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_barrier_async_and_wait_f(dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static void dispatch_barrier_async_and_wait_f(MemorySegment queue, MemorySegment context, MemorySegment work) {
        var mh$ = dispatch_barrier_async_and_wait_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_barrier_async_and_wait_f", queue, context, work);
            }
            mh$.invokeExact(queue, context, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_queue_set_specific {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_queue_set_specific");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_queue_set_specific(dispatch_queue_t  _Nonnull queue, const void * _Nonnull key, void * _Nullable context, dispatch_function_t  _Nullable destructor)
     * }
     */
    public static FunctionDescriptor dispatch_queue_set_specific$descriptor() {
        return dispatch_queue_set_specific.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_queue_set_specific(dispatch_queue_t  _Nonnull queue, const void * _Nonnull key, void * _Nullable context, dispatch_function_t  _Nullable destructor)
     * }
     */
    public static MethodHandle dispatch_queue_set_specific$handle() {
        return dispatch_queue_set_specific.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_queue_set_specific(dispatch_queue_t  _Nonnull queue, const void * _Nonnull key, void * _Nullable context, dispatch_function_t  _Nullable destructor)
     * }
     */
    public static MemorySegment dispatch_queue_set_specific$address() {
        return dispatch_queue_set_specific.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_queue_set_specific(dispatch_queue_t  _Nonnull queue, const void * _Nonnull key, void * _Nullable context, dispatch_function_t  _Nullable destructor)
     * }
     */
    public static void dispatch_queue_set_specific(MemorySegment queue, MemorySegment key, MemorySegment context, MemorySegment destructor) {
        var mh$ = dispatch_queue_set_specific.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_queue_set_specific", queue, key, context, destructor);
            }
            mh$.invokeExact(queue, key, context, destructor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_queue_get_specific {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_queue_get_specific");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_queue_get_specific(dispatch_queue_t  _Nonnull queue, const void * _Nonnull key)
     * }
     */
    public static FunctionDescriptor dispatch_queue_get_specific$descriptor() {
        return dispatch_queue_get_specific.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_queue_get_specific(dispatch_queue_t  _Nonnull queue, const void * _Nonnull key)
     * }
     */
    public static MethodHandle dispatch_queue_get_specific$handle() {
        return dispatch_queue_get_specific.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_queue_get_specific(dispatch_queue_t  _Nonnull queue, const void * _Nonnull key)
     * }
     */
    public static MemorySegment dispatch_queue_get_specific$address() {
        return dispatch_queue_get_specific.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_queue_get_specific(dispatch_queue_t  _Nonnull queue, const void * _Nonnull key)
     * }
     */
    public static MemorySegment dispatch_queue_get_specific(MemorySegment queue, MemorySegment key) {
        var mh$ = dispatch_queue_get_specific.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_queue_get_specific", queue, key);
            }
            return (MemorySegment)mh$.invokeExact(queue, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_get_specific {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_get_specific");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_get_specific(const void * _Nonnull key)
     * }
     */
    public static FunctionDescriptor dispatch_get_specific$descriptor() {
        return dispatch_get_specific.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_get_specific(const void * _Nonnull key)
     * }
     */
    public static MethodHandle dispatch_get_specific$handle() {
        return dispatch_get_specific.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_get_specific(const void * _Nonnull key)
     * }
     */
    public static MemorySegment dispatch_get_specific$address() {
        return dispatch_get_specific.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable dispatch_get_specific(const void * _Nonnull key)
     * }
     */
    public static MemorySegment dispatch_get_specific(MemorySegment key) {
        var mh$ = dispatch_get_specific.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_get_specific", key);
            }
            return (MemorySegment)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_assert_queue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_assert_queue$V2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_assert_queue(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static FunctionDescriptor dispatch_assert_queue$descriptor() {
        return dispatch_assert_queue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_assert_queue(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static MethodHandle dispatch_assert_queue$handle() {
        return dispatch_assert_queue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_assert_queue(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static MemorySegment dispatch_assert_queue$address() {
        return dispatch_assert_queue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_assert_queue(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static void dispatch_assert_queue(MemorySegment queue) {
        var mh$ = dispatch_assert_queue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_assert_queue", queue);
            }
            mh$.invokeExact(queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_assert_queue_barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_assert_queue_barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_assert_queue_barrier(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static FunctionDescriptor dispatch_assert_queue_barrier$descriptor() {
        return dispatch_assert_queue_barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_assert_queue_barrier(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static MethodHandle dispatch_assert_queue_barrier$handle() {
        return dispatch_assert_queue_barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_assert_queue_barrier(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static MemorySegment dispatch_assert_queue_barrier$address() {
        return dispatch_assert_queue_barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_assert_queue_barrier(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static void dispatch_assert_queue_barrier(MemorySegment queue) {
        var mh$ = dispatch_assert_queue_barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_assert_queue_barrier", queue);
            }
            mh$.invokeExact(queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_assert_queue_not {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_assert_queue_not$V2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_assert_queue_not(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static FunctionDescriptor dispatch_assert_queue_not$descriptor() {
        return dispatch_assert_queue_not.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_assert_queue_not(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static MethodHandle dispatch_assert_queue_not$handle() {
        return dispatch_assert_queue_not.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_assert_queue_not(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static MemorySegment dispatch_assert_queue_not$address() {
        return dispatch_assert_queue_not.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_assert_queue_not(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static void dispatch_assert_queue_not(MemorySegment queue) {
        var mh$ = dispatch_assert_queue_not.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_assert_queue_not", queue);
            }
            mh$.invokeExact(queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long DISPATCH_BLOCK_BARRIER = 1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPATCH_BLOCK_BARRIER = 1
     * }
     */
    public static long DISPATCH_BLOCK_BARRIER() {
        return DISPATCH_BLOCK_BARRIER;
    }
    private static final long DISPATCH_BLOCK_DETACHED = 2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPATCH_BLOCK_DETACHED = 2
     * }
     */
    public static long DISPATCH_BLOCK_DETACHED() {
        return DISPATCH_BLOCK_DETACHED;
    }
    private static final long DISPATCH_BLOCK_ASSIGN_CURRENT = 4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPATCH_BLOCK_ASSIGN_CURRENT = 4
     * }
     */
    public static long DISPATCH_BLOCK_ASSIGN_CURRENT() {
        return DISPATCH_BLOCK_ASSIGN_CURRENT;
    }
    private static final long DISPATCH_BLOCK_NO_QOS_CLASS = 8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPATCH_BLOCK_NO_QOS_CLASS = 8
     * }
     */
    public static long DISPATCH_BLOCK_NO_QOS_CLASS() {
        return DISPATCH_BLOCK_NO_QOS_CLASS;
    }
    private static final long DISPATCH_BLOCK_INHERIT_QOS_CLASS = 16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPATCH_BLOCK_INHERIT_QOS_CLASS = 16
     * }
     */
    public static long DISPATCH_BLOCK_INHERIT_QOS_CLASS() {
        return DISPATCH_BLOCK_INHERIT_QOS_CLASS;
    }
    private static final long DISPATCH_BLOCK_ENFORCE_QOS_CLASS = 32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPATCH_BLOCK_ENFORCE_QOS_CLASS = 32
     * }
     */
    public static long DISPATCH_BLOCK_ENFORCE_QOS_CLASS() {
        return DISPATCH_BLOCK_ENFORCE_QOS_CLASS;
    }

    private static class dispatch_block_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_block_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_block_t  _Nonnull dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_block_create$descriptor() {
        return dispatch_block_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_block_t  _Nonnull dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_block_create$handle() {
        return dispatch_block_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_block_t  _Nonnull dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_block_create$address() {
        return dispatch_block_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_block_t  _Nonnull dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_block_create(long flags, MemorySegment block) {
        var mh$ = dispatch_block_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_block_create", flags, block);
            }
            return (MemorySegment)mh$.invokeExact(flags, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_block_create_with_qos_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_block_create_with_qos_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_block_t  _Nonnull dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_block_create_with_qos_class$descriptor() {
        return dispatch_block_create_with_qos_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_block_t  _Nonnull dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_block_create_with_qos_class$handle() {
        return dispatch_block_create_with_qos_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_block_t  _Nonnull dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_block_create_with_qos_class$address() {
        return dispatch_block_create_with_qos_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_block_t  _Nonnull dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_block_create_with_qos_class(long flags, int qos_class, int relative_priority, MemorySegment block) {
        var mh$ = dispatch_block_create_with_qos_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_block_create_with_qos_class", flags, qos_class, relative_priority, block);
            }
            return (MemorySegment)mh$.invokeExact(flags, qos_class, relative_priority, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_block_perform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_block_perform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_block_perform(dispatch_block_flags_t flags, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_block_perform$descriptor() {
        return dispatch_block_perform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_block_perform(dispatch_block_flags_t flags, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_block_perform$handle() {
        return dispatch_block_perform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_block_perform(dispatch_block_flags_t flags, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_block_perform$address() {
        return dispatch_block_perform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_block_perform(dispatch_block_flags_t flags, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_block_perform(long flags, MemorySegment block) {
        var mh$ = dispatch_block_perform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_block_perform", flags, block);
            }
            mh$.invokeExact(flags, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_block_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_block_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_block_wait(dispatch_block_t  _Nonnull block, dispatch_time_t timeout)
     * }
     */
    public static FunctionDescriptor dispatch_block_wait$descriptor() {
        return dispatch_block_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_block_wait(dispatch_block_t  _Nonnull block, dispatch_time_t timeout)
     * }
     */
    public static MethodHandle dispatch_block_wait$handle() {
        return dispatch_block_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_block_wait(dispatch_block_t  _Nonnull block, dispatch_time_t timeout)
     * }
     */
    public static MemorySegment dispatch_block_wait$address() {
        return dispatch_block_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intptr_t dispatch_block_wait(dispatch_block_t  _Nonnull block, dispatch_time_t timeout)
     * }
     */
    public static long dispatch_block_wait(MemorySegment block, long timeout) {
        var mh$ = dispatch_block_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_block_wait", block, timeout);
            }
            return (long)mh$.invokeExact(block, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_block_notify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_block_notify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_block_notify(dispatch_block_t  _Nonnull block, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull notification_block)
     * }
     */
    public static FunctionDescriptor dispatch_block_notify$descriptor() {
        return dispatch_block_notify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_block_notify(dispatch_block_t  _Nonnull block, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull notification_block)
     * }
     */
    public static MethodHandle dispatch_block_notify$handle() {
        return dispatch_block_notify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_block_notify(dispatch_block_t  _Nonnull block, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull notification_block)
     * }
     */
    public static MemorySegment dispatch_block_notify$address() {
        return dispatch_block_notify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_block_notify(dispatch_block_t  _Nonnull block, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull notification_block)
     * }
     */
    public static void dispatch_block_notify(MemorySegment block, MemorySegment queue, MemorySegment notification_block) {
        var mh$ = dispatch_block_notify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_block_notify", block, queue, notification_block);
            }
            mh$.invokeExact(block, queue, notification_block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_block_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_block_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_block_cancel(dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_block_cancel$descriptor() {
        return dispatch_block_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_block_cancel(dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_block_cancel$handle() {
        return dispatch_block_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_block_cancel(dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_block_cancel$address() {
        return dispatch_block_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_block_cancel(dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_block_cancel(MemorySegment block) {
        var mh$ = dispatch_block_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_block_cancel", block);
            }
            mh$.invokeExact(block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_block_testcancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_block_testcancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_block_testcancel(dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_block_testcancel$descriptor() {
        return dispatch_block_testcancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_block_testcancel(dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_block_testcancel$handle() {
        return dispatch_block_testcancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_block_testcancel(dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_block_testcancel$address() {
        return dispatch_block_testcancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intptr_t dispatch_block_testcancel(dispatch_block_t  _Nonnull block)
     * }
     */
    public static long dispatch_block_testcancel(MemorySegment block) {
        var mh$ = dispatch_block_testcancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_block_testcancel", block);
            }
            return (long)mh$.invokeExact(block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int kern_return_t
     * }
     */
    public static final OfInt kern_return_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_timeout_t
     * }
     */
    public static final OfInt mach_msg_timeout_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_bits_t
     * }
     */
    public static final OfInt mach_msg_bits_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_size_t
     * }
     */
    public static final OfInt mach_msg_size_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_id_t
     * }
     */
    public static final OfInt mach_msg_id_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_priority_t
     * }
     */
    public static final OfInt mach_msg_priority_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_type_name_t
     * }
     */
    public static final OfInt mach_msg_type_name_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_copy_options_t
     * }
     */
    public static final OfInt mach_msg_copy_options_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_guard_flags_t
     * }
     */
    public static final OfInt mach_msg_guard_flags_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_descriptor_type_t
     * }
     */
    public static final OfInt mach_msg_descriptor_type_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_trailer_type_t
     * }
     */
    public static final OfInt mach_msg_trailer_type_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int mach_msg_trailer_size_t
     * }
     */
    public static final OfInt mach_msg_trailer_size_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char *mach_msg_trailer_info_t
     * }
     */
    public static final AddressLayout mach_msg_trailer_info_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int mach_msg_filter_id
     * }
     */
    public static final OfInt mach_msg_filter_id = opencl_h.C_INT;

    private static class KERNEL_SECURITY_TOKEN$constants {
        public static final GroupLayout LAYOUT = security_token_t.layout();
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("KERNEL_SECURITY_TOKEN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static GroupLayout KERNEL_SECURITY_TOKEN$layout() {
        return KERNEL_SECURITY_TOKEN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static MemorySegment KERNEL_SECURITY_TOKEN() {
        return KERNEL_SECURITY_TOKEN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const security_token_t KERNEL_SECURITY_TOKEN
     * }
     */
    public static void KERNEL_SECURITY_TOKEN(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, KERNEL_SECURITY_TOKEN$constants.SEGMENT, 0L, KERNEL_SECURITY_TOKEN$constants.LAYOUT.byteSize());
    }

    private static class KERNEL_AUDIT_TOKEN$constants {
        public static final GroupLayout LAYOUT = audit_token_t.layout();
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("KERNEL_AUDIT_TOKEN").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static GroupLayout KERNEL_AUDIT_TOKEN$layout() {
        return KERNEL_AUDIT_TOKEN$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static MemorySegment KERNEL_AUDIT_TOKEN() {
        return KERNEL_AUDIT_TOKEN$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const audit_token_t KERNEL_AUDIT_TOKEN
     * }
     */
    public static void KERNEL_AUDIT_TOKEN(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, KERNEL_AUDIT_TOKEN$constants.SEGMENT, 0L, KERNEL_AUDIT_TOKEN$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_options_t
     * }
     */
    public static final OfInt mach_msg_options_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_type_size_t
     * }
     */
    public static final OfInt mach_msg_type_size_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef natural_t mach_msg_type_number_t
     * }
     */
    public static final OfInt mach_msg_type_number_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef integer_t mach_msg_option_t
     * }
     */
    public static final OfInt mach_msg_option_t = opencl_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef kern_return_t mach_msg_return_t
     * }
     */
    public static final OfInt mach_msg_return_t = opencl_h.C_INT;

    private static class mach_msg_overwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mach_msg_overwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static FunctionDescriptor mach_msg_overwrite$descriptor() {
        return mach_msg_overwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static MethodHandle mach_msg_overwrite$handle() {
        return mach_msg_overwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static MemorySegment mach_msg_overwrite$address() {
        return mach_msg_overwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg_overwrite(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit)
     * }
     */
    public static int mach_msg_overwrite(MemorySegment msg, int option, int send_size, int rcv_size, int rcv_name, int timeout, int notify, MemorySegment rcv_msg, int rcv_limit) {
        var mh$ = mach_msg_overwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_msg_overwrite", msg, option, send_size, rcv_size, rcv_name, timeout, notify, rcv_msg, rcv_limit);
            }
            return (int)mh$.invokeExact(msg, option, send_size, rcv_size, rcv_name, timeout, notify, rcv_msg, rcv_limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mach_msg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mach_msg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static FunctionDescriptor mach_msg$descriptor() {
        return mach_msg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static MethodHandle mach_msg$handle() {
        return mach_msg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static MemorySegment mach_msg$address() {
        return mach_msg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
     * }
     */
    public static int mach_msg(MemorySegment msg, int option, int send_size, int rcv_size, int rcv_name, int timeout, int notify) {
        var mh$ = mach_msg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_msg", msg, option, send_size, rcv_size, rcv_name, timeout, notify);
            }
            return (int)mh$.invokeExact(msg, option, send_size, rcv_size, rcv_name, timeout, notify);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mach_voucher_deallocate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("mach_voucher_deallocate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static FunctionDescriptor mach_voucher_deallocate$descriptor() {
        return mach_voucher_deallocate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static MethodHandle mach_voucher_deallocate$handle() {
        return mach_voucher_deallocate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static MemorySegment mach_voucher_deallocate$address() {
        return mach_voucher_deallocate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
     * }
     */
    public static int mach_voucher_deallocate(int voucher) {
        var mh$ = mach_voucher_deallocate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mach_voucher_deallocate", voucher);
            }
            return (int)mh$.invokeExact(voucher);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct dispatch_source_s *dispatch_source_t
     * }
     */
    public static final AddressLayout dispatch_source_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct dispatch_source_type_s *dispatch_source_type_t
     * }
     */
    public static final AddressLayout dispatch_source_type_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long dispatch_source_mach_send_flags_t
     * }
     */
    public static final OfLong dispatch_source_mach_send_flags_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long dispatch_source_mach_recv_flags_t
     * }
     */
    public static final OfLong dispatch_source_mach_recv_flags_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long dispatch_source_memorypressure_flags_t
     * }
     */
    public static final OfLong dispatch_source_memorypressure_flags_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long dispatch_source_proc_flags_t
     * }
     */
    public static final OfLong dispatch_source_proc_flags_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long dispatch_source_vnode_flags_t
     * }
     */
    public static final OfLong dispatch_source_vnode_flags_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long dispatch_source_timer_flags_t
     * }
     */
    public static final OfLong dispatch_source_timer_flags_t = opencl_h.C_LONG;

    private static class dispatch_source_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_source_t  _Nonnull dispatch_source_create(dispatch_source_type_t  _Nonnull type, uintptr_t handle, uintptr_t mask, dispatch_queue_t  _Nullable queue)
     * }
     */
    public static FunctionDescriptor dispatch_source_create$descriptor() {
        return dispatch_source_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_source_t  _Nonnull dispatch_source_create(dispatch_source_type_t  _Nonnull type, uintptr_t handle, uintptr_t mask, dispatch_queue_t  _Nullable queue)
     * }
     */
    public static MethodHandle dispatch_source_create$handle() {
        return dispatch_source_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_source_t  _Nonnull dispatch_source_create(dispatch_source_type_t  _Nonnull type, uintptr_t handle, uintptr_t mask, dispatch_queue_t  _Nullable queue)
     * }
     */
    public static MemorySegment dispatch_source_create$address() {
        return dispatch_source_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_source_t  _Nonnull dispatch_source_create(dispatch_source_type_t  _Nonnull type, uintptr_t handle, uintptr_t mask, dispatch_queue_t  _Nullable queue)
     * }
     */
    public static MemorySegment dispatch_source_create(MemorySegment type, long handle, long mask, MemorySegment queue) {
        var mh$ = dispatch_source_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_create", type, handle, mask, queue);
            }
            return (MemorySegment)mh$.invokeExact(type, handle, mask, queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_set_event_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_set_event_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_event_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static FunctionDescriptor dispatch_source_set_event_handler$descriptor() {
        return dispatch_source_set_event_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_event_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static MethodHandle dispatch_source_set_event_handler$handle() {
        return dispatch_source_set_event_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_event_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static MemorySegment dispatch_source_set_event_handler$address() {
        return dispatch_source_set_event_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_source_set_event_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static void dispatch_source_set_event_handler(MemorySegment source, MemorySegment handler) {
        var mh$ = dispatch_source_set_event_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_set_event_handler", source, handler);
            }
            mh$.invokeExact(source, handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_set_event_handler_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_set_event_handler_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_event_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static FunctionDescriptor dispatch_source_set_event_handler_f$descriptor() {
        return dispatch_source_set_event_handler_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_event_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static MethodHandle dispatch_source_set_event_handler_f$handle() {
        return dispatch_source_set_event_handler_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_event_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static MemorySegment dispatch_source_set_event_handler_f$address() {
        return dispatch_source_set_event_handler_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_source_set_event_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static void dispatch_source_set_event_handler_f(MemorySegment source, MemorySegment handler) {
        var mh$ = dispatch_source_set_event_handler_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_set_event_handler_f", source, handler);
            }
            mh$.invokeExact(source, handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_set_cancel_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_set_cancel_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_cancel_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static FunctionDescriptor dispatch_source_set_cancel_handler$descriptor() {
        return dispatch_source_set_cancel_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_cancel_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static MethodHandle dispatch_source_set_cancel_handler$handle() {
        return dispatch_source_set_cancel_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_cancel_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static MemorySegment dispatch_source_set_cancel_handler$address() {
        return dispatch_source_set_cancel_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_source_set_cancel_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static void dispatch_source_set_cancel_handler(MemorySegment source, MemorySegment handler) {
        var mh$ = dispatch_source_set_cancel_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_set_cancel_handler", source, handler);
            }
            mh$.invokeExact(source, handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_set_cancel_handler_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_set_cancel_handler_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_cancel_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static FunctionDescriptor dispatch_source_set_cancel_handler_f$descriptor() {
        return dispatch_source_set_cancel_handler_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_cancel_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static MethodHandle dispatch_source_set_cancel_handler_f$handle() {
        return dispatch_source_set_cancel_handler_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_cancel_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static MemorySegment dispatch_source_set_cancel_handler_f$address() {
        return dispatch_source_set_cancel_handler_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_source_set_cancel_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static void dispatch_source_set_cancel_handler_f(MemorySegment source, MemorySegment handler) {
        var mh$ = dispatch_source_set_cancel_handler_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_set_cancel_handler_f", source, handler);
            }
            mh$.invokeExact(source, handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_source_cancel(dispatch_source_t  _Nonnull source)
     * }
     */
    public static FunctionDescriptor dispatch_source_cancel$descriptor() {
        return dispatch_source_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_source_cancel(dispatch_source_t  _Nonnull source)
     * }
     */
    public static MethodHandle dispatch_source_cancel$handle() {
        return dispatch_source_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_source_cancel(dispatch_source_t  _Nonnull source)
     * }
     */
    public static MemorySegment dispatch_source_cancel$address() {
        return dispatch_source_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_source_cancel(dispatch_source_t  _Nonnull source)
     * }
     */
    public static void dispatch_source_cancel(MemorySegment source) {
        var mh$ = dispatch_source_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_cancel", source);
            }
            mh$.invokeExact(source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_testcancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_testcancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_source_testcancel(dispatch_source_t  _Nonnull source)
     * }
     */
    public static FunctionDescriptor dispatch_source_testcancel$descriptor() {
        return dispatch_source_testcancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_source_testcancel(dispatch_source_t  _Nonnull source)
     * }
     */
    public static MethodHandle dispatch_source_testcancel$handle() {
        return dispatch_source_testcancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_source_testcancel(dispatch_source_t  _Nonnull source)
     * }
     */
    public static MemorySegment dispatch_source_testcancel$address() {
        return dispatch_source_testcancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intptr_t dispatch_source_testcancel(dispatch_source_t  _Nonnull source)
     * }
     */
    public static long dispatch_source_testcancel(MemorySegment source) {
        var mh$ = dispatch_source_testcancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_testcancel", source);
            }
            return (long)mh$.invokeExact(source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_get_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_get_handle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_handle(dispatch_source_t  _Nonnull source)
     * }
     */
    public static FunctionDescriptor dispatch_source_get_handle$descriptor() {
        return dispatch_source_get_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_handle(dispatch_source_t  _Nonnull source)
     * }
     */
    public static MethodHandle dispatch_source_get_handle$handle() {
        return dispatch_source_get_handle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_handle(dispatch_source_t  _Nonnull source)
     * }
     */
    public static MemorySegment dispatch_source_get_handle$address() {
        return dispatch_source_get_handle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_handle(dispatch_source_t  _Nonnull source)
     * }
     */
    public static long dispatch_source_get_handle(MemorySegment source) {
        var mh$ = dispatch_source_get_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_get_handle", source);
            }
            return (long)mh$.invokeExact(source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_get_mask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_get_mask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_mask(dispatch_source_t  _Nonnull source)
     * }
     */
    public static FunctionDescriptor dispatch_source_get_mask$descriptor() {
        return dispatch_source_get_mask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_mask(dispatch_source_t  _Nonnull source)
     * }
     */
    public static MethodHandle dispatch_source_get_mask$handle() {
        return dispatch_source_get_mask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_mask(dispatch_source_t  _Nonnull source)
     * }
     */
    public static MemorySegment dispatch_source_get_mask$address() {
        return dispatch_source_get_mask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_mask(dispatch_source_t  _Nonnull source)
     * }
     */
    public static long dispatch_source_get_mask(MemorySegment source) {
        var mh$ = dispatch_source_get_mask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_get_mask", source);
            }
            return (long)mh$.invokeExact(source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_data(dispatch_source_t  _Nonnull source)
     * }
     */
    public static FunctionDescriptor dispatch_source_get_data$descriptor() {
        return dispatch_source_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_data(dispatch_source_t  _Nonnull source)
     * }
     */
    public static MethodHandle dispatch_source_get_data$handle() {
        return dispatch_source_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_data(dispatch_source_t  _Nonnull source)
     * }
     */
    public static MemorySegment dispatch_source_get_data$address() {
        return dispatch_source_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintptr_t dispatch_source_get_data(dispatch_source_t  _Nonnull source)
     * }
     */
    public static long dispatch_source_get_data(MemorySegment source) {
        var mh$ = dispatch_source_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_get_data", source);
            }
            return (long)mh$.invokeExact(source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_merge_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_merge_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_source_merge_data(dispatch_source_t  _Nonnull source, uintptr_t value)
     * }
     */
    public static FunctionDescriptor dispatch_source_merge_data$descriptor() {
        return dispatch_source_merge_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_source_merge_data(dispatch_source_t  _Nonnull source, uintptr_t value)
     * }
     */
    public static MethodHandle dispatch_source_merge_data$handle() {
        return dispatch_source_merge_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_source_merge_data(dispatch_source_t  _Nonnull source, uintptr_t value)
     * }
     */
    public static MemorySegment dispatch_source_merge_data$address() {
        return dispatch_source_merge_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_source_merge_data(dispatch_source_t  _Nonnull source, uintptr_t value)
     * }
     */
    public static void dispatch_source_merge_data(MemorySegment source, long value) {
        var mh$ = dispatch_source_merge_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_merge_data", source, value);
            }
            mh$.invokeExact(source, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_set_timer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_set_timer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_timer(dispatch_source_t  _Nonnull source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
     * }
     */
    public static FunctionDescriptor dispatch_source_set_timer$descriptor() {
        return dispatch_source_set_timer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_timer(dispatch_source_t  _Nonnull source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
     * }
     */
    public static MethodHandle dispatch_source_set_timer$handle() {
        return dispatch_source_set_timer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_timer(dispatch_source_t  _Nonnull source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
     * }
     */
    public static MemorySegment dispatch_source_set_timer$address() {
        return dispatch_source_set_timer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_source_set_timer(dispatch_source_t  _Nonnull source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
     * }
     */
    public static void dispatch_source_set_timer(MemorySegment source, long start, long interval, long leeway) {
        var mh$ = dispatch_source_set_timer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_set_timer", source, start, interval, leeway);
            }
            mh$.invokeExact(source, start, interval, leeway);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_set_registration_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_set_registration_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_registration_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static FunctionDescriptor dispatch_source_set_registration_handler$descriptor() {
        return dispatch_source_set_registration_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_registration_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static MethodHandle dispatch_source_set_registration_handler$handle() {
        return dispatch_source_set_registration_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_registration_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static MemorySegment dispatch_source_set_registration_handler$address() {
        return dispatch_source_set_registration_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_source_set_registration_handler(dispatch_source_t  _Nonnull source, dispatch_block_t  _Nullable handler)
     * }
     */
    public static void dispatch_source_set_registration_handler(MemorySegment source, MemorySegment handler) {
        var mh$ = dispatch_source_set_registration_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_set_registration_handler", source, handler);
            }
            mh$.invokeExact(source, handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_source_set_registration_handler_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_source_set_registration_handler_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_registration_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static FunctionDescriptor dispatch_source_set_registration_handler_f$descriptor() {
        return dispatch_source_set_registration_handler_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_registration_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static MethodHandle dispatch_source_set_registration_handler_f$handle() {
        return dispatch_source_set_registration_handler_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_source_set_registration_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static MemorySegment dispatch_source_set_registration_handler_f$address() {
        return dispatch_source_set_registration_handler_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_source_set_registration_handler_f(dispatch_source_t  _Nonnull source, dispatch_function_t  _Nullable handler)
     * }
     */
    public static void dispatch_source_set_registration_handler_f(MemorySegment source, MemorySegment handler) {
        var mh$ = dispatch_source_set_registration_handler_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_source_set_registration_handler_f", source, handler);
            }
            mh$.invokeExact(source, handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct dispatch_group_s *dispatch_group_t
     * }
     */
    public static final AddressLayout dispatch_group_t = opencl_h.C_POINTER;

    private static class dispatch_group_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_group_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_group_t  _Nonnull dispatch_group_create()
     * }
     */
    public static FunctionDescriptor dispatch_group_create$descriptor() {
        return dispatch_group_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_group_t  _Nonnull dispatch_group_create()
     * }
     */
    public static MethodHandle dispatch_group_create$handle() {
        return dispatch_group_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_group_t  _Nonnull dispatch_group_create()
     * }
     */
    public static MemorySegment dispatch_group_create$address() {
        return dispatch_group_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_group_t  _Nonnull dispatch_group_create()
     * }
     */
    public static MemorySegment dispatch_group_create() {
        var mh$ = dispatch_group_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_group_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_group_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_group_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_group_async(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_group_async$descriptor() {
        return dispatch_group_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_group_async(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_group_async$handle() {
        return dispatch_group_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_group_async(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_group_async$address() {
        return dispatch_group_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_group_async(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_group_async(MemorySegment group, MemorySegment queue, MemorySegment block) {
        var mh$ = dispatch_group_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_group_async", group, queue, block);
            }
            mh$.invokeExact(group, queue, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_group_async_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_group_async_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_group_async_f(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static FunctionDescriptor dispatch_group_async_f$descriptor() {
        return dispatch_group_async_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_group_async_f(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MethodHandle dispatch_group_async_f$handle() {
        return dispatch_group_async_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_group_async_f(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MemorySegment dispatch_group_async_f$address() {
        return dispatch_group_async_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_group_async_f(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static void dispatch_group_async_f(MemorySegment group, MemorySegment queue, MemorySegment context, MemorySegment work) {
        var mh$ = dispatch_group_async_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_group_async_f", group, queue, context, work);
            }
            mh$.invokeExact(group, queue, context, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_group_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_group_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_group_wait(dispatch_group_t  _Nonnull group, dispatch_time_t timeout)
     * }
     */
    public static FunctionDescriptor dispatch_group_wait$descriptor() {
        return dispatch_group_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_group_wait(dispatch_group_t  _Nonnull group, dispatch_time_t timeout)
     * }
     */
    public static MethodHandle dispatch_group_wait$handle() {
        return dispatch_group_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_group_wait(dispatch_group_t  _Nonnull group, dispatch_time_t timeout)
     * }
     */
    public static MemorySegment dispatch_group_wait$address() {
        return dispatch_group_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intptr_t dispatch_group_wait(dispatch_group_t  _Nonnull group, dispatch_time_t timeout)
     * }
     */
    public static long dispatch_group_wait(MemorySegment group, long timeout) {
        var mh$ = dispatch_group_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_group_wait", group, timeout);
            }
            return (long)mh$.invokeExact(group, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_group_notify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_group_notify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_group_notify(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_group_notify$descriptor() {
        return dispatch_group_notify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_group_notify(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_group_notify$handle() {
        return dispatch_group_notify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_group_notify(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_group_notify$address() {
        return dispatch_group_notify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_group_notify(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_group_notify(MemorySegment group, MemorySegment queue, MemorySegment block) {
        var mh$ = dispatch_group_notify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_group_notify", group, queue, block);
            }
            mh$.invokeExact(group, queue, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_group_notify_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_group_notify_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_group_notify_f(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static FunctionDescriptor dispatch_group_notify_f$descriptor() {
        return dispatch_group_notify_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_group_notify_f(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MethodHandle dispatch_group_notify_f$handle() {
        return dispatch_group_notify_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_group_notify_f(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static MemorySegment dispatch_group_notify_f$address() {
        return dispatch_group_notify_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_group_notify_f(dispatch_group_t  _Nonnull group, dispatch_queue_t  _Nonnull queue, void * _Nullable context, dispatch_function_t  _Nonnull work)
     * }
     */
    public static void dispatch_group_notify_f(MemorySegment group, MemorySegment queue, MemorySegment context, MemorySegment work) {
        var mh$ = dispatch_group_notify_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_group_notify_f", group, queue, context, work);
            }
            mh$.invokeExact(group, queue, context, work);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_group_enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_group_enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_group_enter(dispatch_group_t  _Nonnull group)
     * }
     */
    public static FunctionDescriptor dispatch_group_enter$descriptor() {
        return dispatch_group_enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_group_enter(dispatch_group_t  _Nonnull group)
     * }
     */
    public static MethodHandle dispatch_group_enter$handle() {
        return dispatch_group_enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_group_enter(dispatch_group_t  _Nonnull group)
     * }
     */
    public static MemorySegment dispatch_group_enter$address() {
        return dispatch_group_enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_group_enter(dispatch_group_t  _Nonnull group)
     * }
     */
    public static void dispatch_group_enter(MemorySegment group) {
        var mh$ = dispatch_group_enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_group_enter", group);
            }
            mh$.invokeExact(group);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_group_leave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_group_leave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_group_leave(dispatch_group_t  _Nonnull group)
     * }
     */
    public static FunctionDescriptor dispatch_group_leave$descriptor() {
        return dispatch_group_leave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_group_leave(dispatch_group_t  _Nonnull group)
     * }
     */
    public static MethodHandle dispatch_group_leave$handle() {
        return dispatch_group_leave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_group_leave(dispatch_group_t  _Nonnull group)
     * }
     */
    public static MemorySegment dispatch_group_leave$address() {
        return dispatch_group_leave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_group_leave(dispatch_group_t  _Nonnull group)
     * }
     */
    public static void dispatch_group_leave(MemorySegment group) {
        var mh$ = dispatch_group_leave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_group_leave", group);
            }
            mh$.invokeExact(group);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct dispatch_semaphore_s *dispatch_semaphore_t
     * }
     */
    public static final AddressLayout dispatch_semaphore_t = opencl_h.C_POINTER;

    private static class dispatch_semaphore_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_semaphore_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_semaphore_t  _Nonnull dispatch_semaphore_create(intptr_t value)
     * }
     */
    public static FunctionDescriptor dispatch_semaphore_create$descriptor() {
        return dispatch_semaphore_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_semaphore_t  _Nonnull dispatch_semaphore_create(intptr_t value)
     * }
     */
    public static MethodHandle dispatch_semaphore_create$handle() {
        return dispatch_semaphore_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_semaphore_t  _Nonnull dispatch_semaphore_create(intptr_t value)
     * }
     */
    public static MemorySegment dispatch_semaphore_create$address() {
        return dispatch_semaphore_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_semaphore_t  _Nonnull dispatch_semaphore_create(intptr_t value)
     * }
     */
    public static MemorySegment dispatch_semaphore_create(long value) {
        var mh$ = dispatch_semaphore_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_semaphore_create", value);
            }
            return (MemorySegment)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_semaphore_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_semaphore_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_semaphore_wait(dispatch_semaphore_t  _Nonnull dsema, dispatch_time_t timeout)
     * }
     */
    public static FunctionDescriptor dispatch_semaphore_wait$descriptor() {
        return dispatch_semaphore_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_semaphore_wait(dispatch_semaphore_t  _Nonnull dsema, dispatch_time_t timeout)
     * }
     */
    public static MethodHandle dispatch_semaphore_wait$handle() {
        return dispatch_semaphore_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_semaphore_wait(dispatch_semaphore_t  _Nonnull dsema, dispatch_time_t timeout)
     * }
     */
    public static MemorySegment dispatch_semaphore_wait$address() {
        return dispatch_semaphore_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intptr_t dispatch_semaphore_wait(dispatch_semaphore_t  _Nonnull dsema, dispatch_time_t timeout)
     * }
     */
    public static long dispatch_semaphore_wait(MemorySegment dsema, long timeout) {
        var mh$ = dispatch_semaphore_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_semaphore_wait", dsema, timeout);
            }
            return (long)mh$.invokeExact(dsema, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_semaphore_signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_semaphore_signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_semaphore_signal(dispatch_semaphore_t  _Nonnull dsema)
     * }
     */
    public static FunctionDescriptor dispatch_semaphore_signal$descriptor() {
        return dispatch_semaphore_signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_semaphore_signal(dispatch_semaphore_t  _Nonnull dsema)
     * }
     */
    public static MethodHandle dispatch_semaphore_signal$handle() {
        return dispatch_semaphore_signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intptr_t dispatch_semaphore_signal(dispatch_semaphore_t  _Nonnull dsema)
     * }
     */
    public static MemorySegment dispatch_semaphore_signal$address() {
        return dispatch_semaphore_signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intptr_t dispatch_semaphore_signal(dispatch_semaphore_t  _Nonnull dsema)
     * }
     */
    public static long dispatch_semaphore_signal(MemorySegment dsema) {
        var mh$ = dispatch_semaphore_signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_semaphore_signal", dsema);
            }
            return (long)mh$.invokeExact(dsema);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef intptr_t dispatch_once_t
     * }
     */
    public static final OfLong dispatch_once_t = opencl_h.C_LONG;

    private static class dispatch_once {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_once");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_once(dispatch_once_t * _Nonnull predicate, dispatch_block_t  _Nonnull block)
     * }
     */
    public static FunctionDescriptor dispatch_once$descriptor() {
        return dispatch_once.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_once(dispatch_once_t * _Nonnull predicate, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MethodHandle dispatch_once$handle() {
        return dispatch_once.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_once(dispatch_once_t * _Nonnull predicate, dispatch_block_t  _Nonnull block)
     * }
     */
    public static MemorySegment dispatch_once$address() {
        return dispatch_once.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_once(dispatch_once_t * _Nonnull predicate, dispatch_block_t  _Nonnull block)
     * }
     */
    public static void dispatch_once(MemorySegment predicate, MemorySegment block) {
        var mh$ = dispatch_once.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_once", predicate, block);
            }
            mh$.invokeExact(predicate, block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_once_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_once_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_once_f(dispatch_once_t * _Nonnull predicate, void * _Nullable context, dispatch_function_t  _Nonnull function)
     * }
     */
    public static FunctionDescriptor dispatch_once_f$descriptor() {
        return dispatch_once_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_once_f(dispatch_once_t * _Nonnull predicate, void * _Nullable context, dispatch_function_t  _Nonnull function)
     * }
     */
    public static MethodHandle dispatch_once_f$handle() {
        return dispatch_once_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_once_f(dispatch_once_t * _Nonnull predicate, void * _Nullable context, dispatch_function_t  _Nonnull function)
     * }
     */
    public static MemorySegment dispatch_once_f$address() {
        return dispatch_once_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_once_f(dispatch_once_t * _Nonnull predicate, void * _Nullable context, dispatch_function_t  _Nonnull function)
     * }
     */
    public static void dispatch_once_f(MemorySegment predicate, MemorySegment context, MemorySegment function) {
        var mh$ = dispatch_once_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_once_f", predicate, context, function);
            }
            mh$.invokeExact(predicate, context, function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct dispatch_data_s *dispatch_data_t
     * }
     */
    public static final AddressLayout dispatch_data_t = opencl_h.C_POINTER;

    private static class _dispatch_data_destructor_free$constants {
        public static final AddressLayout LAYOUT = opencl_h.C_POINTER;
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("_dispatch_data_destructor_free").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const dispatch_block_t  _Nonnull _dispatch_data_destructor_free
     * }
     */
    public static AddressLayout _dispatch_data_destructor_free$layout() {
        return _dispatch_data_destructor_free$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const dispatch_block_t  _Nonnull _dispatch_data_destructor_free
     * }
     */
    public static MemorySegment _dispatch_data_destructor_free$segment() {
        return _dispatch_data_destructor_free$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const dispatch_block_t  _Nonnull _dispatch_data_destructor_free
     * }
     */
    public static MemorySegment _dispatch_data_destructor_free() {
        return _dispatch_data_destructor_free$constants.SEGMENT.get(_dispatch_data_destructor_free$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const dispatch_block_t  _Nonnull _dispatch_data_destructor_free
     * }
     */
    public static void _dispatch_data_destructor_free(MemorySegment varValue) {
        _dispatch_data_destructor_free$constants.SEGMENT.set(_dispatch_data_destructor_free$constants.LAYOUT, 0L, varValue);
    }

    private static class _dispatch_data_destructor_munmap$constants {
        public static final AddressLayout LAYOUT = opencl_h.C_POINTER;
        public static final MemorySegment SEGMENT = opencl_h.findOrThrow("_dispatch_data_destructor_munmap").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const dispatch_block_t  _Nonnull _dispatch_data_destructor_munmap
     * }
     */
    public static AddressLayout _dispatch_data_destructor_munmap$layout() {
        return _dispatch_data_destructor_munmap$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const dispatch_block_t  _Nonnull _dispatch_data_destructor_munmap
     * }
     */
    public static MemorySegment _dispatch_data_destructor_munmap$segment() {
        return _dispatch_data_destructor_munmap$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const dispatch_block_t  _Nonnull _dispatch_data_destructor_munmap
     * }
     */
    public static MemorySegment _dispatch_data_destructor_munmap() {
        return _dispatch_data_destructor_munmap$constants.SEGMENT.get(_dispatch_data_destructor_munmap$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const dispatch_block_t  _Nonnull _dispatch_data_destructor_munmap
     * }
     */
    public static void _dispatch_data_destructor_munmap(MemorySegment varValue) {
        _dispatch_data_destructor_munmap$constants.SEGMENT.set(_dispatch_data_destructor_munmap$constants.LAYOUT, 0L, varValue);
    }

    private static class dispatch_data_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_data_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create(const void * _Nonnull buffer, size_t size, dispatch_queue_t  _Nullable queue, dispatch_block_t  _Nullable destructor)
     * }
     */
    public static FunctionDescriptor dispatch_data_create$descriptor() {
        return dispatch_data_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create(const void * _Nonnull buffer, size_t size, dispatch_queue_t  _Nullable queue, dispatch_block_t  _Nullable destructor)
     * }
     */
    public static MethodHandle dispatch_data_create$handle() {
        return dispatch_data_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create(const void * _Nonnull buffer, size_t size, dispatch_queue_t  _Nullable queue, dispatch_block_t  _Nullable destructor)
     * }
     */
    public static MemorySegment dispatch_data_create$address() {
        return dispatch_data_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create(const void * _Nonnull buffer, size_t size, dispatch_queue_t  _Nullable queue, dispatch_block_t  _Nullable destructor)
     * }
     */
    public static MemorySegment dispatch_data_create(MemorySegment buffer, long size, MemorySegment queue, MemorySegment destructor) {
        var mh$ = dispatch_data_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_data_create", buffer, size, queue, destructor);
            }
            return (MemorySegment)mh$.invokeExact(buffer, size, queue, destructor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_data_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_data_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t dispatch_data_get_size(dispatch_data_t  _Nonnull data)
     * }
     */
    public static FunctionDescriptor dispatch_data_get_size$descriptor() {
        return dispatch_data_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t dispatch_data_get_size(dispatch_data_t  _Nonnull data)
     * }
     */
    public static MethodHandle dispatch_data_get_size$handle() {
        return dispatch_data_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t dispatch_data_get_size(dispatch_data_t  _Nonnull data)
     * }
     */
    public static MemorySegment dispatch_data_get_size$address() {
        return dispatch_data_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t dispatch_data_get_size(dispatch_data_t  _Nonnull data)
     * }
     */
    public static long dispatch_data_get_size(MemorySegment data) {
        var mh$ = dispatch_data_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_data_get_size", data);
            }
            return (long)mh$.invokeExact(data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_data_create_map {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_data_create_map");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_map(dispatch_data_t  _Nonnull data, const void * _Nullable * _Nullable buffer_ptr, size_t * _Nullable size_ptr)
     * }
     */
    public static FunctionDescriptor dispatch_data_create_map$descriptor() {
        return dispatch_data_create_map.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_map(dispatch_data_t  _Nonnull data, const void * _Nullable * _Nullable buffer_ptr, size_t * _Nullable size_ptr)
     * }
     */
    public static MethodHandle dispatch_data_create_map$handle() {
        return dispatch_data_create_map.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_map(dispatch_data_t  _Nonnull data, const void * _Nullable * _Nullable buffer_ptr, size_t * _Nullable size_ptr)
     * }
     */
    public static MemorySegment dispatch_data_create_map$address() {
        return dispatch_data_create_map.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_map(dispatch_data_t  _Nonnull data, const void * _Nullable * _Nullable buffer_ptr, size_t * _Nullable size_ptr)
     * }
     */
    public static MemorySegment dispatch_data_create_map(MemorySegment data, MemorySegment buffer_ptr, MemorySegment size_ptr) {
        var mh$ = dispatch_data_create_map.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_data_create_map", data, buffer_ptr, size_ptr);
            }
            return (MemorySegment)mh$.invokeExact(data, buffer_ptr, size_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_data_create_concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_data_create_concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_concat(dispatch_data_t  _Nonnull data1, dispatch_data_t  _Nonnull data2)
     * }
     */
    public static FunctionDescriptor dispatch_data_create_concat$descriptor() {
        return dispatch_data_create_concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_concat(dispatch_data_t  _Nonnull data1, dispatch_data_t  _Nonnull data2)
     * }
     */
    public static MethodHandle dispatch_data_create_concat$handle() {
        return dispatch_data_create_concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_concat(dispatch_data_t  _Nonnull data1, dispatch_data_t  _Nonnull data2)
     * }
     */
    public static MemorySegment dispatch_data_create_concat$address() {
        return dispatch_data_create_concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_concat(dispatch_data_t  _Nonnull data1, dispatch_data_t  _Nonnull data2)
     * }
     */
    public static MemorySegment dispatch_data_create_concat(MemorySegment data1, MemorySegment data2) {
        var mh$ = dispatch_data_create_concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_data_create_concat", data1, data2);
            }
            return (MemorySegment)mh$.invokeExact(data1, data2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_data_create_subrange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_data_create_subrange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_subrange(dispatch_data_t  _Nonnull data, size_t offset, size_t length)
     * }
     */
    public static FunctionDescriptor dispatch_data_create_subrange$descriptor() {
        return dispatch_data_create_subrange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_subrange(dispatch_data_t  _Nonnull data, size_t offset, size_t length)
     * }
     */
    public static MethodHandle dispatch_data_create_subrange$handle() {
        return dispatch_data_create_subrange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_subrange(dispatch_data_t  _Nonnull data, size_t offset, size_t length)
     * }
     */
    public static MemorySegment dispatch_data_create_subrange$address() {
        return dispatch_data_create_subrange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_create_subrange(dispatch_data_t  _Nonnull data, size_t offset, size_t length)
     * }
     */
    public static MemorySegment dispatch_data_create_subrange(MemorySegment data, long offset, long length) {
        var mh$ = dispatch_data_create_subrange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_data_create_subrange", data, offset, length);
            }
            return (MemorySegment)mh$.invokeExact(data, offset, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_data_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_BOOL,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_data_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool dispatch_data_apply(dispatch_data_t  _Nonnull data, dispatch_data_applier_t  _Nonnull applier)
     * }
     */
    public static FunctionDescriptor dispatch_data_apply$descriptor() {
        return dispatch_data_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool dispatch_data_apply(dispatch_data_t  _Nonnull data, dispatch_data_applier_t  _Nonnull applier)
     * }
     */
    public static MethodHandle dispatch_data_apply$handle() {
        return dispatch_data_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool dispatch_data_apply(dispatch_data_t  _Nonnull data, dispatch_data_applier_t  _Nonnull applier)
     * }
     */
    public static MemorySegment dispatch_data_apply$address() {
        return dispatch_data_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool dispatch_data_apply(dispatch_data_t  _Nonnull data, dispatch_data_applier_t  _Nonnull applier)
     * }
     */
    public static boolean dispatch_data_apply(MemorySegment data, MemorySegment applier) {
        var mh$ = dispatch_data_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_data_apply", data, applier);
            }
            return (boolean)mh$.invokeExact(data, applier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_data_copy_region {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_data_copy_region");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_copy_region(dispatch_data_t  _Nonnull data, size_t location, size_t * _Nonnull offset_ptr)
     * }
     */
    public static FunctionDescriptor dispatch_data_copy_region$descriptor() {
        return dispatch_data_copy_region.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_copy_region(dispatch_data_t  _Nonnull data, size_t location, size_t * _Nonnull offset_ptr)
     * }
     */
    public static MethodHandle dispatch_data_copy_region$handle() {
        return dispatch_data_copy_region.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_copy_region(dispatch_data_t  _Nonnull data, size_t location, size_t * _Nonnull offset_ptr)
     * }
     */
    public static MemorySegment dispatch_data_copy_region$address() {
        return dispatch_data_copy_region.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_data_t  _Nonnull dispatch_data_copy_region(dispatch_data_t  _Nonnull data, size_t location, size_t * _Nonnull offset_ptr)
     * }
     */
    public static MemorySegment dispatch_data_copy_region(MemorySegment data, long location, MemorySegment offset_ptr) {
        var mh$ = dispatch_data_copy_region.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_data_copy_region", data, location, offset_ptr);
            }
            return (MemorySegment)mh$.invokeExact(data, location, offset_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int dispatch_fd_t
     * }
     */
    public static final OfInt dispatch_fd_t = opencl_h.C_INT;

    private static class dispatch_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_read(dispatch_fd_t fd, size_t length, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull handler)(dispatch_data_t _Nonnull, int))
     * }
     */
    public static FunctionDescriptor dispatch_read$descriptor() {
        return dispatch_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_read(dispatch_fd_t fd, size_t length, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull handler)(dispatch_data_t _Nonnull, int))
     * }
     */
    public static MethodHandle dispatch_read$handle() {
        return dispatch_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_read(dispatch_fd_t fd, size_t length, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull handler)(dispatch_data_t _Nonnull, int))
     * }
     */
    public static MemorySegment dispatch_read$address() {
        return dispatch_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_read(dispatch_fd_t fd, size_t length, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull handler)(dispatch_data_t _Nonnull, int))
     * }
     */
    public static void dispatch_read(int fd, long length, MemorySegment queue, MemorySegment handler) {
        var mh$ = dispatch_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_read", fd, length, queue, handler);
            }
            mh$.invokeExact(fd, length, queue, handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_write(dispatch_fd_t fd, dispatch_data_t  _Nonnull data, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull handler)(dispatch_data_t _Nullable, int))
     * }
     */
    public static FunctionDescriptor dispatch_write$descriptor() {
        return dispatch_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_write(dispatch_fd_t fd, dispatch_data_t  _Nonnull data, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull handler)(dispatch_data_t _Nullable, int))
     * }
     */
    public static MethodHandle dispatch_write$handle() {
        return dispatch_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_write(dispatch_fd_t fd, dispatch_data_t  _Nonnull data, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull handler)(dispatch_data_t _Nullable, int))
     * }
     */
    public static MemorySegment dispatch_write$address() {
        return dispatch_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_write(dispatch_fd_t fd, dispatch_data_t  _Nonnull data, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull handler)(dispatch_data_t _Nullable, int))
     * }
     */
    public static void dispatch_write(int fd, MemorySegment data, MemorySegment queue, MemorySegment handler) {
        var mh$ = dispatch_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_write", fd, data, queue, handler);
            }
            mh$.invokeExact(fd, data, queue, handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct dispatch_io_s *dispatch_io_t
     * }
     */
    public static final AddressLayout dispatch_io_t = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long dispatch_io_type_t
     * }
     */
    public static final OfLong dispatch_io_type_t = opencl_h.C_LONG;

    private static class dispatch_io_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static FunctionDescriptor dispatch_io_create$descriptor() {
        return dispatch_io_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static MethodHandle dispatch_io_create$handle() {
        return dispatch_io_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static MemorySegment dispatch_io_create$address() {
        return dispatch_io_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static MemorySegment dispatch_io_create(long type, int fd, MemorySegment queue, MemorySegment cleanup_handler) {
        var mh$ = dispatch_io_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_create", type, fd, queue, cleanup_handler);
            }
            return (MemorySegment)mh$.invokeExact(type, fd, queue, cleanup_handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_io_create_with_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_SHORT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_create_with_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create_with_path(dispatch_io_type_t type, const char * _Nonnull path, int oflag, mode_t mode, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static FunctionDescriptor dispatch_io_create_with_path$descriptor() {
        return dispatch_io_create_with_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create_with_path(dispatch_io_type_t type, const char * _Nonnull path, int oflag, mode_t mode, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static MethodHandle dispatch_io_create_with_path$handle() {
        return dispatch_io_create_with_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create_with_path(dispatch_io_type_t type, const char * _Nonnull path, int oflag, mode_t mode, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static MemorySegment dispatch_io_create_with_path$address() {
        return dispatch_io_create_with_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create_with_path(dispatch_io_type_t type, const char * _Nonnull path, int oflag, mode_t mode, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static MemorySegment dispatch_io_create_with_path(long type, MemorySegment path, int oflag, short mode, MemorySegment queue, MemorySegment cleanup_handler) {
        var mh$ = dispatch_io_create_with_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_create_with_path", type, path, oflag, mode, queue, cleanup_handler);
            }
            return (MemorySegment)mh$.invokeExact(type, path, oflag, mode, queue, cleanup_handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_io_create_with_io {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_create_with_io");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create_with_io(dispatch_io_type_t type, dispatch_io_t  _Nonnull io, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static FunctionDescriptor dispatch_io_create_with_io$descriptor() {
        return dispatch_io_create_with_io.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create_with_io(dispatch_io_type_t type, dispatch_io_t  _Nonnull io, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static MethodHandle dispatch_io_create_with_io$handle() {
        return dispatch_io_create_with_io.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create_with_io(dispatch_io_type_t type, dispatch_io_t  _Nonnull io, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static MemorySegment dispatch_io_create_with_io$address() {
        return dispatch_io_create_with_io.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_io_t  _Nonnull dispatch_io_create_with_io(dispatch_io_type_t type, dispatch_io_t  _Nonnull io, dispatch_queue_t  _Nonnull queue, void (^ _Nonnull cleanup_handler)(int))
     * }
     */
    public static MemorySegment dispatch_io_create_with_io(long type, MemorySegment io, MemorySegment queue, MemorySegment cleanup_handler) {
        var mh$ = dispatch_io_create_with_io.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_create_with_io", type, io, queue, cleanup_handler);
            }
            return (MemorySegment)mh$.invokeExact(type, io, queue, cleanup_handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_io_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_io_read(dispatch_io_t  _Nonnull channel, off_t offset, size_t length, dispatch_queue_t  _Nonnull queue, dispatch_io_handler_t  _Nonnull io_handler)
     * }
     */
    public static FunctionDescriptor dispatch_io_read$descriptor() {
        return dispatch_io_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_io_read(dispatch_io_t  _Nonnull channel, off_t offset, size_t length, dispatch_queue_t  _Nonnull queue, dispatch_io_handler_t  _Nonnull io_handler)
     * }
     */
    public static MethodHandle dispatch_io_read$handle() {
        return dispatch_io_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_io_read(dispatch_io_t  _Nonnull channel, off_t offset, size_t length, dispatch_queue_t  _Nonnull queue, dispatch_io_handler_t  _Nonnull io_handler)
     * }
     */
    public static MemorySegment dispatch_io_read$address() {
        return dispatch_io_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_io_read(dispatch_io_t  _Nonnull channel, off_t offset, size_t length, dispatch_queue_t  _Nonnull queue, dispatch_io_handler_t  _Nonnull io_handler)
     * }
     */
    public static void dispatch_io_read(MemorySegment channel, long offset, long length, MemorySegment queue, MemorySegment io_handler) {
        var mh$ = dispatch_io_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_read", channel, offset, length, queue, io_handler);
            }
            mh$.invokeExact(channel, offset, length, queue, io_handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_io_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_io_write(dispatch_io_t  _Nonnull channel, off_t offset, dispatch_data_t  _Nonnull data, dispatch_queue_t  _Nonnull queue, dispatch_io_handler_t  _Nonnull io_handler)
     * }
     */
    public static FunctionDescriptor dispatch_io_write$descriptor() {
        return dispatch_io_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_io_write(dispatch_io_t  _Nonnull channel, off_t offset, dispatch_data_t  _Nonnull data, dispatch_queue_t  _Nonnull queue, dispatch_io_handler_t  _Nonnull io_handler)
     * }
     */
    public static MethodHandle dispatch_io_write$handle() {
        return dispatch_io_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_io_write(dispatch_io_t  _Nonnull channel, off_t offset, dispatch_data_t  _Nonnull data, dispatch_queue_t  _Nonnull queue, dispatch_io_handler_t  _Nonnull io_handler)
     * }
     */
    public static MemorySegment dispatch_io_write$address() {
        return dispatch_io_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_io_write(dispatch_io_t  _Nonnull channel, off_t offset, dispatch_data_t  _Nonnull data, dispatch_queue_t  _Nonnull queue, dispatch_io_handler_t  _Nonnull io_handler)
     * }
     */
    public static void dispatch_io_write(MemorySegment channel, long offset, MemorySegment data, MemorySegment queue, MemorySegment io_handler) {
        var mh$ = dispatch_io_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_write", channel, offset, data, queue, io_handler);
            }
            mh$.invokeExact(channel, offset, data, queue, io_handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long dispatch_io_close_flags_t
     * }
     */
    public static final OfLong dispatch_io_close_flags_t = opencl_h.C_LONG;

    private static class dispatch_io_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_io_close(dispatch_io_t  _Nonnull channel, dispatch_io_close_flags_t flags)
     * }
     */
    public static FunctionDescriptor dispatch_io_close$descriptor() {
        return dispatch_io_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_io_close(dispatch_io_t  _Nonnull channel, dispatch_io_close_flags_t flags)
     * }
     */
    public static MethodHandle dispatch_io_close$handle() {
        return dispatch_io_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_io_close(dispatch_io_t  _Nonnull channel, dispatch_io_close_flags_t flags)
     * }
     */
    public static MemorySegment dispatch_io_close$address() {
        return dispatch_io_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_io_close(dispatch_io_t  _Nonnull channel, dispatch_io_close_flags_t flags)
     * }
     */
    public static void dispatch_io_close(MemorySegment channel, long flags) {
        var mh$ = dispatch_io_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_close", channel, flags);
            }
            mh$.invokeExact(channel, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_io_barrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_barrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_io_barrier(dispatch_io_t  _Nonnull channel, dispatch_block_t  _Nonnull barrier)
     * }
     */
    public static FunctionDescriptor dispatch_io_barrier$descriptor() {
        return dispatch_io_barrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_io_barrier(dispatch_io_t  _Nonnull channel, dispatch_block_t  _Nonnull barrier)
     * }
     */
    public static MethodHandle dispatch_io_barrier$handle() {
        return dispatch_io_barrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_io_barrier(dispatch_io_t  _Nonnull channel, dispatch_block_t  _Nonnull barrier)
     * }
     */
    public static MemorySegment dispatch_io_barrier$address() {
        return dispatch_io_barrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_io_barrier(dispatch_io_t  _Nonnull channel, dispatch_block_t  _Nonnull barrier)
     * }
     */
    public static void dispatch_io_barrier(MemorySegment channel, MemorySegment barrier) {
        var mh$ = dispatch_io_barrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_barrier", channel, barrier);
            }
            mh$.invokeExact(channel, barrier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_io_get_descriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_INT,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_get_descriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_fd_t dispatch_io_get_descriptor(dispatch_io_t  _Nonnull channel)
     * }
     */
    public static FunctionDescriptor dispatch_io_get_descriptor$descriptor() {
        return dispatch_io_get_descriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_fd_t dispatch_io_get_descriptor(dispatch_io_t  _Nonnull channel)
     * }
     */
    public static MethodHandle dispatch_io_get_descriptor$handle() {
        return dispatch_io_get_descriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_fd_t dispatch_io_get_descriptor(dispatch_io_t  _Nonnull channel)
     * }
     */
    public static MemorySegment dispatch_io_get_descriptor$address() {
        return dispatch_io_get_descriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_fd_t dispatch_io_get_descriptor(dispatch_io_t  _Nonnull channel)
     * }
     */
    public static int dispatch_io_get_descriptor(MemorySegment channel) {
        var mh$ = dispatch_io_get_descriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_get_descriptor", channel);
            }
            return (int)mh$.invokeExact(channel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_io_set_high_water {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_set_high_water");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_io_set_high_water(dispatch_io_t  _Nonnull channel, size_t high_water)
     * }
     */
    public static FunctionDescriptor dispatch_io_set_high_water$descriptor() {
        return dispatch_io_set_high_water.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_io_set_high_water(dispatch_io_t  _Nonnull channel, size_t high_water)
     * }
     */
    public static MethodHandle dispatch_io_set_high_water$handle() {
        return dispatch_io_set_high_water.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_io_set_high_water(dispatch_io_t  _Nonnull channel, size_t high_water)
     * }
     */
    public static MemorySegment dispatch_io_set_high_water$address() {
        return dispatch_io_set_high_water.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_io_set_high_water(dispatch_io_t  _Nonnull channel, size_t high_water)
     * }
     */
    public static void dispatch_io_set_high_water(MemorySegment channel, long high_water) {
        var mh$ = dispatch_io_set_high_water.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_set_high_water", channel, high_water);
            }
            mh$.invokeExact(channel, high_water);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_io_set_low_water {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_set_low_water");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_io_set_low_water(dispatch_io_t  _Nonnull channel, size_t low_water)
     * }
     */
    public static FunctionDescriptor dispatch_io_set_low_water$descriptor() {
        return dispatch_io_set_low_water.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_io_set_low_water(dispatch_io_t  _Nonnull channel, size_t low_water)
     * }
     */
    public static MethodHandle dispatch_io_set_low_water$handle() {
        return dispatch_io_set_low_water.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_io_set_low_water(dispatch_io_t  _Nonnull channel, size_t low_water)
     * }
     */
    public static MemorySegment dispatch_io_set_low_water$address() {
        return dispatch_io_set_low_water.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_io_set_low_water(dispatch_io_t  _Nonnull channel, size_t low_water)
     * }
     */
    public static void dispatch_io_set_low_water(MemorySegment channel, long low_water) {
        var mh$ = dispatch_io_set_low_water.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_set_low_water", channel, low_water);
            }
            mh$.invokeExact(channel, low_water);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long dispatch_io_interval_flags_t
     * }
     */
    public static final OfLong dispatch_io_interval_flags_t = opencl_h.C_LONG;

    private static class dispatch_io_set_interval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_io_set_interval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_io_set_interval(dispatch_io_t  _Nonnull channel, uint64_t interval, dispatch_io_interval_flags_t flags)
     * }
     */
    public static FunctionDescriptor dispatch_io_set_interval$descriptor() {
        return dispatch_io_set_interval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_io_set_interval(dispatch_io_t  _Nonnull channel, uint64_t interval, dispatch_io_interval_flags_t flags)
     * }
     */
    public static MethodHandle dispatch_io_set_interval$handle() {
        return dispatch_io_set_interval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_io_set_interval(dispatch_io_t  _Nonnull channel, uint64_t interval, dispatch_io_interval_flags_t flags)
     * }
     */
    public static MemorySegment dispatch_io_set_interval$address() {
        return dispatch_io_set_interval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_io_set_interval(dispatch_io_t  _Nonnull channel, uint64_t interval, dispatch_io_interval_flags_t flags)
     * }
     */
    public static void dispatch_io_set_interval(MemorySegment channel, long interval, long flags) {
        var mh$ = dispatch_io_set_interval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_io_set_interval", channel, interval, flags);
            }
            mh$.invokeExact(channel, interval, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef dispatch_queue_t dispatch_workloop_t
     * }
     */
    public static final AddressLayout dispatch_workloop_t = opencl_h.C_POINTER;

    private static class dispatch_workloop_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_workloop_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_workloop_t  _Nonnull dispatch_workloop_create(const char * _Nullable label)
     * }
     */
    public static FunctionDescriptor dispatch_workloop_create$descriptor() {
        return dispatch_workloop_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_workloop_t  _Nonnull dispatch_workloop_create(const char * _Nullable label)
     * }
     */
    public static MethodHandle dispatch_workloop_create$handle() {
        return dispatch_workloop_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_workloop_t  _Nonnull dispatch_workloop_create(const char * _Nullable label)
     * }
     */
    public static MemorySegment dispatch_workloop_create$address() {
        return dispatch_workloop_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_workloop_t  _Nonnull dispatch_workloop_create(const char * _Nullable label)
     * }
     */
    public static MemorySegment dispatch_workloop_create(MemorySegment label) {
        var mh$ = dispatch_workloop_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_workloop_create", label);
            }
            return (MemorySegment)mh$.invokeExact(label);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_workloop_create_inactive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_workloop_create_inactive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_workloop_t  _Nonnull dispatch_workloop_create_inactive(const char * _Nullable label)
     * }
     */
    public static FunctionDescriptor dispatch_workloop_create_inactive$descriptor() {
        return dispatch_workloop_create_inactive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_workloop_t  _Nonnull dispatch_workloop_create_inactive(const char * _Nullable label)
     * }
     */
    public static MethodHandle dispatch_workloop_create_inactive$handle() {
        return dispatch_workloop_create_inactive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_workloop_t  _Nonnull dispatch_workloop_create_inactive(const char * _Nullable label)
     * }
     */
    public static MemorySegment dispatch_workloop_create_inactive$address() {
        return dispatch_workloop_create_inactive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_workloop_t  _Nonnull dispatch_workloop_create_inactive(const char * _Nullable label)
     * }
     */
    public static MemorySegment dispatch_workloop_create_inactive(MemorySegment label) {
        var mh$ = dispatch_workloop_create_inactive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_workloop_create_inactive", label);
            }
            return (MemorySegment)mh$.invokeExact(label);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_workloop_set_autorelease_frequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_workloop_set_autorelease_frequency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_workloop_set_autorelease_frequency(dispatch_workloop_t  _Nonnull workloop, dispatch_autorelease_frequency_t frequency)
     * }
     */
    public static FunctionDescriptor dispatch_workloop_set_autorelease_frequency$descriptor() {
        return dispatch_workloop_set_autorelease_frequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_workloop_set_autorelease_frequency(dispatch_workloop_t  _Nonnull workloop, dispatch_autorelease_frequency_t frequency)
     * }
     */
    public static MethodHandle dispatch_workloop_set_autorelease_frequency$handle() {
        return dispatch_workloop_set_autorelease_frequency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_workloop_set_autorelease_frequency(dispatch_workloop_t  _Nonnull workloop, dispatch_autorelease_frequency_t frequency)
     * }
     */
    public static MemorySegment dispatch_workloop_set_autorelease_frequency$address() {
        return dispatch_workloop_set_autorelease_frequency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_workloop_set_autorelease_frequency(dispatch_workloop_t  _Nonnull workloop, dispatch_autorelease_frequency_t frequency)
     * }
     */
    public static void dispatch_workloop_set_autorelease_frequency(MemorySegment workloop, long frequency) {
        var mh$ = dispatch_workloop_set_autorelease_frequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_workloop_set_autorelease_frequency", workloop, frequency);
            }
            mh$.invokeExact(workloop, frequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dispatch_workloop_set_os_workgroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("dispatch_workloop_set_os_workgroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void dispatch_workloop_set_os_workgroup(dispatch_workloop_t  _Nonnull workloop, os_workgroup_t  _Nonnull workgroup)
     * }
     */
    public static FunctionDescriptor dispatch_workloop_set_os_workgroup$descriptor() {
        return dispatch_workloop_set_os_workgroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void dispatch_workloop_set_os_workgroup(dispatch_workloop_t  _Nonnull workloop, os_workgroup_t  _Nonnull workgroup)
     * }
     */
    public static MethodHandle dispatch_workloop_set_os_workgroup$handle() {
        return dispatch_workloop_set_os_workgroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void dispatch_workloop_set_os_workgroup(dispatch_workloop_t  _Nonnull workloop, os_workgroup_t  _Nonnull workgroup)
     * }
     */
    public static MemorySegment dispatch_workloop_set_os_workgroup$address() {
        return dispatch_workloop_set_os_workgroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void dispatch_workloop_set_os_workgroup(dispatch_workloop_t  _Nonnull workloop, os_workgroup_t  _Nonnull workgroup)
     * }
     */
    public static void dispatch_workloop_set_os_workgroup(MemorySegment workloop, MemorySegment workgroup) {
        var mh$ = dispatch_workloop_set_os_workgroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dispatch_workloop_set_os_workgroup", workloop, workgroup);
            }
            mh$.invokeExact(workloop, workgroup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_mem cl_image
     * }
     */
    public static final AddressLayout cl_image = opencl_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef uint64_t cl_timer
     * }
     */
    public static final OfLong cl_timer = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uintptr_t sampler_t
     * }
     */
    public static final OfLong sampler_t = opencl_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_queue_flags
     * }
     */
    public static final OfLong cl_queue_flags = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_malloc_flags
     * }
     */
    public static final OfLong cl_malloc_flags = opencl_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_mem_object_type cl_image_type
     * }
     */
    public static final OfInt cl_image_type = opencl_h.C_INT;
    private static final int __CLK_ADDRESS_BASE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.__CLK_ADDRESS_BASE = 0
     * }
     */
    public static int __CLK_ADDRESS_BASE() {
        return __CLK_ADDRESS_BASE;
    }
    private static final int CLK_ADDRESS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.CLK_ADDRESS_NONE = 0
     * }
     */
    public static int CLK_ADDRESS_NONE() {
        return CLK_ADDRESS_NONE;
    }
    private static final int CLK_ADDRESS_CLAMP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.CLK_ADDRESS_CLAMP = 1
     * }
     */
    public static int CLK_ADDRESS_CLAMP() {
        return CLK_ADDRESS_CLAMP;
    }
    private static final int CLK_ADDRESS_CLAMP_TO_EDGE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.CLK_ADDRESS_CLAMP_TO_EDGE = 2
     * }
     */
    public static int CLK_ADDRESS_CLAMP_TO_EDGE() {
        return CLK_ADDRESS_CLAMP_TO_EDGE;
    }
    private static final int CLK_ADDRESS_REPEAT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.CLK_ADDRESS_REPEAT = 3
     * }
     */
    public static int CLK_ADDRESS_REPEAT() {
        return CLK_ADDRESS_REPEAT;
    }
    private static final int CLK_ADDRESS_MIRRORED_REPEAT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.CLK_ADDRESS_MIRRORED_REPEAT = 4
     * }
     */
    public static int CLK_ADDRESS_MIRRORED_REPEAT() {
        return CLK_ADDRESS_MIRRORED_REPEAT;
    }
    private static final int __CLK_ADDRESS_MASK = (int)7L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.__CLK_ADDRESS_MASK = 7
     * }
     */
    public static int __CLK_ADDRESS_MASK() {
        return __CLK_ADDRESS_MASK;
    }
    private static final int __CLK_ADDRESS_BITS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.__CLK_ADDRESS_BITS = 3
     * }
     */
    public static int __CLK_ADDRESS_BITS() {
        return __CLK_ADDRESS_BITS;
    }
    private static final int __CLK_NORMALIZED_BASE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.__CLK_NORMALIZED_BASE = 3
     * }
     */
    public static int __CLK_NORMALIZED_BASE() {
        return __CLK_NORMALIZED_BASE;
    }
    private static final int CLK_NORMALIZED_COORDS_FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.CLK_NORMALIZED_COORDS_FALSE = 0
     * }
     */
    public static int CLK_NORMALIZED_COORDS_FALSE() {
        return CLK_NORMALIZED_COORDS_FALSE;
    }
    private static final int CLK_NORMALIZED_COORDS_TRUE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.CLK_NORMALIZED_COORDS_TRUE = 8
     * }
     */
    public static int CLK_NORMALIZED_COORDS_TRUE() {
        return CLK_NORMALIZED_COORDS_TRUE;
    }
    private static final int __CLK_NORMALIZED_MASK = (int)8L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.__CLK_NORMALIZED_MASK = 8
     * }
     */
    public static int __CLK_NORMALIZED_MASK() {
        return __CLK_NORMALIZED_MASK;
    }
    private static final int __CLK_NORMALIZED_BITS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.__CLK_NORMALIZED_BITS = 1
     * }
     */
    public static int __CLK_NORMALIZED_BITS() {
        return __CLK_NORMALIZED_BITS;
    }
    private static final int __CLK_FILTER_BASE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.__CLK_FILTER_BASE = 4
     * }
     */
    public static int __CLK_FILTER_BASE() {
        return __CLK_FILTER_BASE;
    }
    private static final int CLK_FILTER_NEAREST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.CLK_FILTER_NEAREST = 0
     * }
     */
    public static int CLK_FILTER_NEAREST() {
        return CLK_FILTER_NEAREST;
    }
    private static final int CLK_FILTER_LINEAR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.CLK_FILTER_LINEAR = 16
     * }
     */
    public static int CLK_FILTER_LINEAR() {
        return CLK_FILTER_LINEAR;
    }
    private static final int __CLK_FILTER_MASK = (int)16L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.__CLK_FILTER_MASK = 16
     * }
     */
    public static int __CLK_FILTER_MASK() {
        return __CLK_FILTER_MASK;
    }
    private static final int __CLK_FILTER_BITS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum clk_sampler_type.__CLK_FILTER_BITS = 2
     * }
     */
    public static int __CLK_FILTER_BITS() {
        return __CLK_FILTER_BITS;
    }

    private static class gcl_create_dispatch_queue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_create_dispatch_queue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nullable gcl_create_dispatch_queue(cl_queue_flags flags, cl_device_id  _Nullable device_id)
     * }
     */
    public static FunctionDescriptor gcl_create_dispatch_queue$descriptor() {
        return gcl_create_dispatch_queue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nullable gcl_create_dispatch_queue(cl_queue_flags flags, cl_device_id  _Nullable device_id)
     * }
     */
    public static MethodHandle gcl_create_dispatch_queue$handle() {
        return gcl_create_dispatch_queue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nullable gcl_create_dispatch_queue(cl_queue_flags flags, cl_device_id  _Nullable device_id)
     * }
     */
    public static MemorySegment gcl_create_dispatch_queue$address() {
        return gcl_create_dispatch_queue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern dispatch_queue_t  _Nullable gcl_create_dispatch_queue(cl_queue_flags flags, cl_device_id  _Nullable device_id)
     * }
     */
    public static MemorySegment gcl_create_dispatch_queue(long flags, MemorySegment device_id) {
        var mh$ = gcl_create_dispatch_queue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_create_dispatch_queue", flags, device_id);
            }
            return (MemorySegment)mh$.invokeExact(flags, device_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_malloc(size_t bytes, void * _Nullable host_ptr, cl_malloc_flags flags)
     * }
     */
    public static FunctionDescriptor gcl_malloc$descriptor() {
        return gcl_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_malloc(size_t bytes, void * _Nullable host_ptr, cl_malloc_flags flags)
     * }
     */
    public static MethodHandle gcl_malloc$handle() {
        return gcl_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_malloc(size_t bytes, void * _Nullable host_ptr, cl_malloc_flags flags)
     * }
     */
    public static MemorySegment gcl_malloc$address() {
        return gcl_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable gcl_malloc(size_t bytes, void * _Nullable host_ptr, cl_malloc_flags flags)
     * }
     */
    public static MemorySegment gcl_malloc(long bytes, MemorySegment host_ptr, long flags) {
        var mh$ = gcl_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_malloc", bytes, host_ptr, flags);
            }
            return (MemorySegment)mh$.invokeExact(bytes, host_ptr, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_free(void * _Nonnull ptr)
     * }
     */
    public static FunctionDescriptor gcl_free$descriptor() {
        return gcl_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_free(void * _Nonnull ptr)
     * }
     */
    public static MethodHandle gcl_free$handle() {
        return gcl_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_free(void * _Nonnull ptr)
     * }
     */
    public static MemorySegment gcl_free$address() {
        return gcl_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_free(void * _Nonnull ptr)
     * }
     */
    public static void gcl_free(MemorySegment ptr) {
        var mh$ = gcl_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_create_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_create_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_create_image(const cl_image_format * _Nonnull image_format, size_t image_width, size_t image_height, size_t image_depth, IOSurfaceRef  _Nullable io_surface)
     * }
     */
    public static FunctionDescriptor gcl_create_image$descriptor() {
        return gcl_create_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_create_image(const cl_image_format * _Nonnull image_format, size_t image_width, size_t image_height, size_t image_depth, IOSurfaceRef  _Nullable io_surface)
     * }
     */
    public static MethodHandle gcl_create_image$handle() {
        return gcl_create_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_create_image(const cl_image_format * _Nonnull image_format, size_t image_width, size_t image_height, size_t image_depth, IOSurfaceRef  _Nullable io_surface)
     * }
     */
    public static MemorySegment gcl_create_image$address() {
        return gcl_create_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_create_image(const cl_image_format * _Nonnull image_format, size_t image_width, size_t image_height, size_t image_depth, IOSurfaceRef  _Nullable io_surface)
     * }
     */
    public static MemorySegment gcl_create_image(MemorySegment image_format, long image_width, long image_height, long image_depth, MemorySegment io_surface) {
        var mh$ = gcl_create_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_create_image", image_format, image_width, image_height, image_depth, io_surface);
            }
            return (MemorySegment)mh$.invokeExact(image_format, image_width, image_height, image_depth, io_surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_retain_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_retain_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_retain_image(cl_image  _Nonnull image)
     * }
     */
    public static FunctionDescriptor gcl_retain_image$descriptor() {
        return gcl_retain_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_retain_image(cl_image  _Nonnull image)
     * }
     */
    public static MethodHandle gcl_retain_image$handle() {
        return gcl_retain_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_retain_image(cl_image  _Nonnull image)
     * }
     */
    public static MemorySegment gcl_retain_image$address() {
        return gcl_retain_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_retain_image(cl_image  _Nonnull image)
     * }
     */
    public static void gcl_retain_image(MemorySegment image) {
        var mh$ = gcl_retain_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_retain_image", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_release_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_release_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_release_image(cl_image  _Nonnull image)
     * }
     */
    public static FunctionDescriptor gcl_release_image$descriptor() {
        return gcl_release_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_release_image(cl_image  _Nonnull image)
     * }
     */
    public static MethodHandle gcl_release_image$handle() {
        return gcl_release_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_release_image(cl_image  _Nonnull image)
     * }
     */
    public static MemorySegment gcl_release_image$address() {
        return gcl_release_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_release_image(cl_image  _Nonnull image)
     * }
     */
    public static void gcl_release_image(MemorySegment image) {
        var mh$ = gcl_release_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_release_image", image);
            }
            mh$.invokeExact(image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_get_supported_image_formats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_get_supported_image_formats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_get_supported_image_formats(cl_device_id  _Nonnull device_id, cl_image_type image_type, unsigned int num_entries, cl_image_format * _Nonnull image_formats, unsigned int * _Nullable num_image_formats)
     * }
     */
    public static FunctionDescriptor gcl_get_supported_image_formats$descriptor() {
        return gcl_get_supported_image_formats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_get_supported_image_formats(cl_device_id  _Nonnull device_id, cl_image_type image_type, unsigned int num_entries, cl_image_format * _Nonnull image_formats, unsigned int * _Nullable num_image_formats)
     * }
     */
    public static MethodHandle gcl_get_supported_image_formats$handle() {
        return gcl_get_supported_image_formats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_get_supported_image_formats(cl_device_id  _Nonnull device_id, cl_image_type image_type, unsigned int num_entries, cl_image_format * _Nonnull image_formats, unsigned int * _Nullable num_image_formats)
     * }
     */
    public static MemorySegment gcl_get_supported_image_formats$address() {
        return gcl_get_supported_image_formats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_get_supported_image_formats(cl_device_id  _Nonnull device_id, cl_image_type image_type, unsigned int num_entries, cl_image_format * _Nonnull image_formats, unsigned int * _Nullable num_image_formats)
     * }
     */
    public static void gcl_get_supported_image_formats(MemorySegment device_id, int image_type, int num_entries, MemorySegment image_formats, MemorySegment num_image_formats) {
        var mh$ = gcl_get_supported_image_formats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_get_supported_image_formats", device_id, image_type, num_entries, image_formats, num_image_formats);
            }
            mh$.invokeExact(device_id, image_type, num_entries, image_formats, num_image_formats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_memcpy(void * _Nonnull dst, const void * _Nonnull src, size_t size)
     * }
     */
    public static FunctionDescriptor gcl_memcpy$descriptor() {
        return gcl_memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_memcpy(void * _Nonnull dst, const void * _Nonnull src, size_t size)
     * }
     */
    public static MethodHandle gcl_memcpy$handle() {
        return gcl_memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_memcpy(void * _Nonnull dst, const void * _Nonnull src, size_t size)
     * }
     */
    public static MemorySegment gcl_memcpy$address() {
        return gcl_memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_memcpy(void * _Nonnull dst, const void * _Nonnull src, size_t size)
     * }
     */
    public static void gcl_memcpy(MemorySegment dst, MemorySegment src, long size) {
        var mh$ = gcl_memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_memcpy", dst, src, size);
            }
            mh$.invokeExact(dst, src, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_memcpy_rect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_memcpy_rect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_memcpy_rect(void * _Nonnull dst, const void * _Nonnull src, const size_t dst_origin[3], const size_t src_origin[3], const size_t region[3], size_t dst_row_pitch, size_t dst_slice_pitch, size_t src_row_pitch, size_t src_slice_pitch)
     * }
     */
    public static FunctionDescriptor gcl_memcpy_rect$descriptor() {
        return gcl_memcpy_rect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_memcpy_rect(void * _Nonnull dst, const void * _Nonnull src, const size_t dst_origin[3], const size_t src_origin[3], const size_t region[3], size_t dst_row_pitch, size_t dst_slice_pitch, size_t src_row_pitch, size_t src_slice_pitch)
     * }
     */
    public static MethodHandle gcl_memcpy_rect$handle() {
        return gcl_memcpy_rect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_memcpy_rect(void * _Nonnull dst, const void * _Nonnull src, const size_t dst_origin[3], const size_t src_origin[3], const size_t region[3], size_t dst_row_pitch, size_t dst_slice_pitch, size_t src_row_pitch, size_t src_slice_pitch)
     * }
     */
    public static MemorySegment gcl_memcpy_rect$address() {
        return gcl_memcpy_rect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_memcpy_rect(void * _Nonnull dst, const void * _Nonnull src, const size_t dst_origin[3], const size_t src_origin[3], const size_t region[3], size_t dst_row_pitch, size_t dst_slice_pitch, size_t src_row_pitch, size_t src_slice_pitch)
     * }
     */
    public static void gcl_memcpy_rect(MemorySegment dst, MemorySegment src, MemorySegment dst_origin, MemorySegment src_origin, MemorySegment region, long dst_row_pitch, long dst_slice_pitch, long src_row_pitch, long src_slice_pitch) {
        var mh$ = gcl_memcpy_rect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_memcpy_rect", dst, src, dst_origin, src_origin, region, dst_row_pitch, dst_slice_pitch, src_row_pitch, src_slice_pitch);
            }
            mh$.invokeExact(dst, src, dst_origin, src_origin, region, dst_row_pitch, dst_slice_pitch, src_row_pitch, src_slice_pitch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_copy_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_copy_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_copy_image(cl_image  _Nonnull dst_image, cl_image  _Nonnull src_image, const size_t dst_origin[3], const size_t src_origin[3], const size_t region[3])
     * }
     */
    public static FunctionDescriptor gcl_copy_image$descriptor() {
        return gcl_copy_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_copy_image(cl_image  _Nonnull dst_image, cl_image  _Nonnull src_image, const size_t dst_origin[3], const size_t src_origin[3], const size_t region[3])
     * }
     */
    public static MethodHandle gcl_copy_image$handle() {
        return gcl_copy_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_copy_image(cl_image  _Nonnull dst_image, cl_image  _Nonnull src_image, const size_t dst_origin[3], const size_t src_origin[3], const size_t region[3])
     * }
     */
    public static MemorySegment gcl_copy_image$address() {
        return gcl_copy_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_copy_image(cl_image  _Nonnull dst_image, cl_image  _Nonnull src_image, const size_t dst_origin[3], const size_t src_origin[3], const size_t region[3])
     * }
     */
    public static void gcl_copy_image(MemorySegment dst_image, MemorySegment src_image, MemorySegment dst_origin, MemorySegment src_origin, MemorySegment region) {
        var mh$ = gcl_copy_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_copy_image", dst_image, src_image, dst_origin, src_origin, region);
            }
            mh$.invokeExact(dst_image, src_image, dst_origin, src_origin, region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_copy_ptr_to_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_copy_ptr_to_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_copy_ptr_to_image(cl_mem  _Nonnull dst_image, void * _Nonnull src_ptr, const size_t dst_origin[3], const size_t region[3])
     * }
     */
    public static FunctionDescriptor gcl_copy_ptr_to_image$descriptor() {
        return gcl_copy_ptr_to_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_copy_ptr_to_image(cl_mem  _Nonnull dst_image, void * _Nonnull src_ptr, const size_t dst_origin[3], const size_t region[3])
     * }
     */
    public static MethodHandle gcl_copy_ptr_to_image$handle() {
        return gcl_copy_ptr_to_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_copy_ptr_to_image(cl_mem  _Nonnull dst_image, void * _Nonnull src_ptr, const size_t dst_origin[3], const size_t region[3])
     * }
     */
    public static MemorySegment gcl_copy_ptr_to_image$address() {
        return gcl_copy_ptr_to_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_copy_ptr_to_image(cl_mem  _Nonnull dst_image, void * _Nonnull src_ptr, const size_t dst_origin[3], const size_t region[3])
     * }
     */
    public static void gcl_copy_ptr_to_image(MemorySegment dst_image, MemorySegment src_ptr, MemorySegment dst_origin, MemorySegment region) {
        var mh$ = gcl_copy_ptr_to_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_copy_ptr_to_image", dst_image, src_ptr, dst_origin, region);
            }
            mh$.invokeExact(dst_image, src_ptr, dst_origin, region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_copy_image_to_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_copy_image_to_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_copy_image_to_ptr(void * _Nonnull dst_ptr, cl_image  _Nonnull src_image, const size_t src_origin[3], const size_t region[3])
     * }
     */
    public static FunctionDescriptor gcl_copy_image_to_ptr$descriptor() {
        return gcl_copy_image_to_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_copy_image_to_ptr(void * _Nonnull dst_ptr, cl_image  _Nonnull src_image, const size_t src_origin[3], const size_t region[3])
     * }
     */
    public static MethodHandle gcl_copy_image_to_ptr$handle() {
        return gcl_copy_image_to_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_copy_image_to_ptr(void * _Nonnull dst_ptr, cl_image  _Nonnull src_image, const size_t src_origin[3], const size_t region[3])
     * }
     */
    public static MemorySegment gcl_copy_image_to_ptr$address() {
        return gcl_copy_image_to_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_copy_image_to_ptr(void * _Nonnull dst_ptr, cl_image  _Nonnull src_image, const size_t src_origin[3], const size_t region[3])
     * }
     */
    public static void gcl_copy_image_to_ptr(MemorySegment dst_ptr, MemorySegment src_image, MemorySegment src_origin, MemorySegment region) {
        var mh$ = gcl_copy_image_to_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_copy_image_to_ptr", dst_ptr, src_image, src_origin, region);
            }
            mh$.invokeExact(dst_ptr, src_image, src_origin, region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_map_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_map_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_map_ptr(void * _Nonnull ptr, cl_map_flags map_flags, size_t cb)
     * }
     */
    public static FunctionDescriptor gcl_map_ptr$descriptor() {
        return gcl_map_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_map_ptr(void * _Nonnull ptr, cl_map_flags map_flags, size_t cb)
     * }
     */
    public static MethodHandle gcl_map_ptr$handle() {
        return gcl_map_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_map_ptr(void * _Nonnull ptr, cl_map_flags map_flags, size_t cb)
     * }
     */
    public static MemorySegment gcl_map_ptr$address() {
        return gcl_map_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable gcl_map_ptr(void * _Nonnull ptr, cl_map_flags map_flags, size_t cb)
     * }
     */
    public static MemorySegment gcl_map_ptr(MemorySegment ptr, long map_flags, long cb) {
        var mh$ = gcl_map_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_map_ptr", ptr, map_flags, cb);
            }
            return (MemorySegment)mh$.invokeExact(ptr, map_flags, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_map_image {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_LONG_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_map_image");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_map_image(cl_image  _Nonnull image, cl_map_flags map_flags, const size_t origin[3], const size_t region[3])
     * }
     */
    public static FunctionDescriptor gcl_map_image$descriptor() {
        return gcl_map_image.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_map_image(cl_image  _Nonnull image, cl_map_flags map_flags, const size_t origin[3], const size_t region[3])
     * }
     */
    public static MethodHandle gcl_map_image$handle() {
        return gcl_map_image.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_map_image(cl_image  _Nonnull image, cl_map_flags map_flags, const size_t origin[3], const size_t region[3])
     * }
     */
    public static MemorySegment gcl_map_image$address() {
        return gcl_map_image.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable gcl_map_image(cl_image  _Nonnull image, cl_map_flags map_flags, const size_t origin[3], const size_t region[3])
     * }
     */
    public static MemorySegment gcl_map_image(MemorySegment image, long map_flags, MemorySegment origin, MemorySegment region) {
        var mh$ = gcl_map_image.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_map_image", image, map_flags, origin, region);
            }
            return (MemorySegment)mh$.invokeExact(image, map_flags, origin, region);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_unmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_unmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_unmap(void * _Nonnull)
     * }
     */
    public static FunctionDescriptor gcl_unmap$descriptor() {
        return gcl_unmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_unmap(void * _Nonnull)
     * }
     */
    public static MethodHandle gcl_unmap$handle() {
        return gcl_unmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_unmap(void * _Nonnull)
     * }
     */
    public static MemorySegment gcl_unmap$address() {
        return gcl_unmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_unmap(void * _Nonnull)
     * }
     */
    public static void gcl_unmap(MemorySegment x0) {
        var mh$ = gcl_unmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_unmap", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_create_kernel_from_block {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_create_kernel_from_block");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_kernel  _Nullable gcl_create_kernel_from_block(void * _Nonnull kernel_block_ptr)
     * }
     */
    public static FunctionDescriptor gcl_create_kernel_from_block$descriptor() {
        return gcl_create_kernel_from_block.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_kernel  _Nullable gcl_create_kernel_from_block(void * _Nonnull kernel_block_ptr)
     * }
     */
    public static MethodHandle gcl_create_kernel_from_block$handle() {
        return gcl_create_kernel_from_block.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_kernel  _Nullable gcl_create_kernel_from_block(void * _Nonnull kernel_block_ptr)
     * }
     */
    public static MemorySegment gcl_create_kernel_from_block$address() {
        return gcl_create_kernel_from_block.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_kernel  _Nullable gcl_create_kernel_from_block(void * _Nonnull kernel_block_ptr)
     * }
     */
    public static MemorySegment gcl_create_kernel_from_block(MemorySegment kernel_block_ptr) {
        var mh$ = gcl_create_kernel_from_block.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_create_kernel_from_block", kernel_block_ptr);
            }
            return (MemorySegment)mh$.invokeExact(kernel_block_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_get_kernel_block_workgroup_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_LONG,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_get_kernel_block_workgroup_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_get_kernel_block_workgroup_info(void * _Nonnull kernel_block_ptr, cl_kernel_work_group_info param_name, size_t param_value_size, void * _Nonnull param_value, size_t * _Nullable param_value_size_ret)
     * }
     */
    public static FunctionDescriptor gcl_get_kernel_block_workgroup_info$descriptor() {
        return gcl_get_kernel_block_workgroup_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_get_kernel_block_workgroup_info(void * _Nonnull kernel_block_ptr, cl_kernel_work_group_info param_name, size_t param_value_size, void * _Nonnull param_value, size_t * _Nullable param_value_size_ret)
     * }
     */
    public static MethodHandle gcl_get_kernel_block_workgroup_info$handle() {
        return gcl_get_kernel_block_workgroup_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_get_kernel_block_workgroup_info(void * _Nonnull kernel_block_ptr, cl_kernel_work_group_info param_name, size_t param_value_size, void * _Nonnull param_value, size_t * _Nullable param_value_size_ret)
     * }
     */
    public static MemorySegment gcl_get_kernel_block_workgroup_info$address() {
        return gcl_get_kernel_block_workgroup_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_get_kernel_block_workgroup_info(void * _Nonnull kernel_block_ptr, cl_kernel_work_group_info param_name, size_t param_value_size, void * _Nonnull param_value, size_t * _Nullable param_value_size_ret)
     * }
     */
    public static void gcl_get_kernel_block_workgroup_info(MemorySegment kernel_block_ptr, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = gcl_get_kernel_block_workgroup_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_get_kernel_block_workgroup_info", kernel_block_ptr, param_name, param_value_size, param_value, param_value_size_ret);
            }
            mh$.invokeExact(kernel_block_ptr, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_get_device_id_with_dispatch_queue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_get_device_id_with_dispatch_queue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_device_id  _Nullable gcl_get_device_id_with_dispatch_queue(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static FunctionDescriptor gcl_get_device_id_with_dispatch_queue$descriptor() {
        return gcl_get_device_id_with_dispatch_queue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_device_id  _Nullable gcl_get_device_id_with_dispatch_queue(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static MethodHandle gcl_get_device_id_with_dispatch_queue$handle() {
        return gcl_get_device_id_with_dispatch_queue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_device_id  _Nullable gcl_get_device_id_with_dispatch_queue(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static MemorySegment gcl_get_device_id_with_dispatch_queue$address() {
        return gcl_get_device_id_with_dispatch_queue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_device_id  _Nullable gcl_get_device_id_with_dispatch_queue(dispatch_queue_t  _Nonnull queue)
     * }
     */
    public static MemorySegment gcl_get_device_id_with_dispatch_queue(MemorySegment queue) {
        var mh$ = gcl_get_device_id_with_dispatch_queue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_get_device_id_with_dispatch_queue", queue);
            }
            return (MemorySegment)mh$.invokeExact(queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_set_finalizer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_set_finalizer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_set_finalizer(void * _Nonnull object, void (* _Nonnull cl_pfn_finalizer)(void * _Nonnull, void * _Nullable), void * _Nullable user_data)
     * }
     */
    public static FunctionDescriptor gcl_set_finalizer$descriptor() {
        return gcl_set_finalizer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_set_finalizer(void * _Nonnull object, void (* _Nonnull cl_pfn_finalizer)(void * _Nonnull, void * _Nullable), void * _Nullable user_data)
     * }
     */
    public static MethodHandle gcl_set_finalizer$handle() {
        return gcl_set_finalizer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_set_finalizer(void * _Nonnull object, void (* _Nonnull cl_pfn_finalizer)(void * _Nonnull, void * _Nullable), void * _Nullable user_data)
     * }
     */
    public static MemorySegment gcl_set_finalizer$address() {
        return gcl_set_finalizer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_set_finalizer(void * _Nonnull object, void (* _Nonnull cl_pfn_finalizer)(void * _Nonnull, void * _Nullable), void * _Nullable user_data)
     * }
     */
    public static void gcl_set_finalizer(MemorySegment object, MemorySegment cl_pfn_finalizer, MemorySegment user_data) {
        var mh$ = gcl_set_finalizer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_set_finalizer", object, cl_pfn_finalizer, user_data);
            }
            mh$.invokeExact(object, cl_pfn_finalizer, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_start_timer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_start_timer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_timer gcl_start_timer()
     * }
     */
    public static FunctionDescriptor gcl_start_timer$descriptor() {
        return gcl_start_timer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_timer gcl_start_timer()
     * }
     */
    public static MethodHandle gcl_start_timer$handle() {
        return gcl_start_timer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_timer gcl_start_timer()
     * }
     */
    public static MemorySegment gcl_start_timer$address() {
        return gcl_start_timer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_timer gcl_start_timer()
     * }
     */
    public static long gcl_start_timer() {
        var mh$ = gcl_start_timer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_start_timer");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_stop_timer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_DOUBLE,
            opencl_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_stop_timer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double gcl_stop_timer(cl_timer t)
     * }
     */
    public static FunctionDescriptor gcl_stop_timer$descriptor() {
        return gcl_stop_timer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double gcl_stop_timer(cl_timer t)
     * }
     */
    public static MethodHandle gcl_stop_timer$handle() {
        return gcl_stop_timer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double gcl_stop_timer(cl_timer t)
     * }
     */
    public static MemorySegment gcl_stop_timer$address() {
        return gcl_stop_timer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double gcl_stop_timer(cl_timer t)
     * }
     */
    public static double gcl_stop_timer(long t) {
        var mh$ = gcl_stop_timer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_stop_timer", t);
            }
            return (double)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_create_buffer_from_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_create_buffer_from_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem  _Nullable gcl_create_buffer_from_ptr(void * _Nonnull ptr)
     * }
     */
    public static FunctionDescriptor gcl_create_buffer_from_ptr$descriptor() {
        return gcl_create_buffer_from_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem  _Nullable gcl_create_buffer_from_ptr(void * _Nonnull ptr)
     * }
     */
    public static MethodHandle gcl_create_buffer_from_ptr$handle() {
        return gcl_create_buffer_from_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_mem  _Nullable gcl_create_buffer_from_ptr(void * _Nonnull ptr)
     * }
     */
    public static MemorySegment gcl_create_buffer_from_ptr$address() {
        return gcl_create_buffer_from_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_mem  _Nullable gcl_create_buffer_from_ptr(void * _Nonnull ptr)
     * }
     */
    public static MemorySegment gcl_create_buffer_from_ptr(MemorySegment ptr) {
        var mh$ = gcl_create_buffer_from_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_create_buffer_from_ptr", ptr);
            }
            return (MemorySegment)mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_gl_create_ptr_from_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_gl_create_ptr_from_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_gl_create_ptr_from_buffer(GLuint bufobj)
     * }
     */
    public static FunctionDescriptor gcl_gl_create_ptr_from_buffer$descriptor() {
        return gcl_gl_create_ptr_from_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_gl_create_ptr_from_buffer(GLuint bufobj)
     * }
     */
    public static MethodHandle gcl_gl_create_ptr_from_buffer$handle() {
        return gcl_gl_create_ptr_from_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void * _Nullable gcl_gl_create_ptr_from_buffer(GLuint bufobj)
     * }
     */
    public static MemorySegment gcl_gl_create_ptr_from_buffer$address() {
        return gcl_gl_create_ptr_from_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void * _Nullable gcl_gl_create_ptr_from_buffer(GLuint bufobj)
     * }
     */
    public static MemorySegment gcl_gl_create_ptr_from_buffer(int bufobj) {
        var mh$ = gcl_gl_create_ptr_from_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_gl_create_ptr_from_buffer", bufobj);
            }
            return (MemorySegment)mh$.invokeExact(bufobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_gl_create_image_from_texture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT,
            opencl_h.C_INT,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_gl_create_image_from_texture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_gl_create_image_from_texture(GLenum texture_target, GLint mip_level, GLuint texture)
     * }
     */
    public static FunctionDescriptor gcl_gl_create_image_from_texture$descriptor() {
        return gcl_gl_create_image_from_texture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_gl_create_image_from_texture(GLenum texture_target, GLint mip_level, GLuint texture)
     * }
     */
    public static MethodHandle gcl_gl_create_image_from_texture$handle() {
        return gcl_gl_create_image_from_texture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_gl_create_image_from_texture(GLenum texture_target, GLint mip_level, GLuint texture)
     * }
     */
    public static MemorySegment gcl_gl_create_image_from_texture$address() {
        return gcl_gl_create_image_from_texture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_gl_create_image_from_texture(GLenum texture_target, GLint mip_level, GLuint texture)
     * }
     */
    public static MemorySegment gcl_gl_create_image_from_texture(int texture_target, int mip_level, int texture) {
        var mh$ = gcl_gl_create_image_from_texture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_gl_create_image_from_texture", texture_target, mip_level, texture);
            }
            return (MemorySegment)mh$.invokeExact(texture_target, mip_level, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_gl_create_image_from_renderbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER,
            opencl_h.C_INT
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_gl_create_image_from_renderbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_gl_create_image_from_renderbuffer(GLuint render_buffer)
     * }
     */
    public static FunctionDescriptor gcl_gl_create_image_from_renderbuffer$descriptor() {
        return gcl_gl_create_image_from_renderbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_gl_create_image_from_renderbuffer(GLuint render_buffer)
     * }
     */
    public static MethodHandle gcl_gl_create_image_from_renderbuffer$handle() {
        return gcl_gl_create_image_from_renderbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_gl_create_image_from_renderbuffer(GLuint render_buffer)
     * }
     */
    public static MemorySegment gcl_gl_create_image_from_renderbuffer$address() {
        return gcl_gl_create_image_from_renderbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_image  _Nullable gcl_gl_create_image_from_renderbuffer(GLuint render_buffer)
     * }
     */
    public static MemorySegment gcl_gl_create_image_from_renderbuffer(int render_buffer) {
        var mh$ = gcl_gl_create_image_from_renderbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_gl_create_image_from_renderbuffer", render_buffer);
            }
            return (MemorySegment)mh$.invokeExact(render_buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_gl_set_sharegroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            opencl_h.C_POINTER
        );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_gl_set_sharegroup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gcl_gl_set_sharegroup(void * _Nonnull share)
     * }
     */
    public static FunctionDescriptor gcl_gl_set_sharegroup$descriptor() {
        return gcl_gl_set_sharegroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gcl_gl_set_sharegroup(void * _Nonnull share)
     * }
     */
    public static MethodHandle gcl_gl_set_sharegroup$handle() {
        return gcl_gl_set_sharegroup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gcl_gl_set_sharegroup(void * _Nonnull share)
     * }
     */
    public static MemorySegment gcl_gl_set_sharegroup$address() {
        return gcl_gl_set_sharegroup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gcl_gl_set_sharegroup(void * _Nonnull share)
     * }
     */
    public static void gcl_gl_set_sharegroup(MemorySegment share) {
        var mh$ = gcl_gl_set_sharegroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_gl_set_sharegroup", share);
            }
            mh$.invokeExact(share);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcl_get_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            opencl_h.C_POINTER    );

        public static final MemorySegment ADDR = opencl_h.findOrThrow("gcl_get_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_context  _Nullable gcl_get_context()
     * }
     */
    public static FunctionDescriptor gcl_get_context$descriptor() {
        return gcl_get_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_context  _Nullable gcl_get_context()
     * }
     */
    public static MethodHandle gcl_get_context$handle() {
        return gcl_get_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern cl_context  _Nullable gcl_get_context()
     * }
     */
    public static MemorySegment gcl_get_context$address() {
        return gcl_get_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern cl_context  _Nullable gcl_get_context()
     * }
     */
    public static MemorySegment gcl_get_context() {
        var mh$ = gcl_get_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcl_get_context");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 140000
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }
    private static final int MAC_OS_X_VERSION_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }
    private static final int MAC_OS_X_VERSION_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }
    private static final int MAC_OS_X_VERSION_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }
    private static final int MAC_OS_X_VERSION_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }
    private static final int MAC_OS_X_VERSION_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }
    private static final int MAC_OS_X_VERSION_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }
    private static final int MAC_OS_X_VERSION_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }
    private static final int MAC_OS_X_VERSION_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }
    private static final int MAC_OS_X_VERSION_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }
    private static final int MAC_OS_X_VERSION_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }
    private static final int MAC_OS_X_VERSION_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }
    private static final int MAC_OS_X_VERSION_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }
    private static final int MAC_OS_X_VERSION_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }
    private static final int MAC_OS_X_VERSION_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }
    private static final int MAC_OS_X_VERSION_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }
    private static final int MAC_OS_X_VERSION_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }
    private static final int MAC_OS_X_VERSION_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }
    private static final int MAC_OS_X_VERSION_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }
    private static final int MAC_OS_X_VERSION_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }
    private static final int MAC_OS_X_VERSION_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }
    private static final int MAC_OS_X_VERSION_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }
    private static final int MAC_OS_X_VERSION_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }
    private static final int MAC_OS_X_VERSION_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }
    private static final int MAC_OS_X_VERSION_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }
    private static final int MAC_OS_X_VERSION_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }
    private static final int MAC_OS_X_VERSION_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }
    private static final int MAC_OS_X_VERSION_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }
    private static final int MAC_OS_X_VERSION_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }
    private static final int MAC_OS_X_VERSION_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }
    private static final int MAC_OS_X_VERSION_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }
    private static final int MAC_OS_VERSION_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }
    private static final int MAC_OS_VERSION_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }
    private static final int MAC_OS_VERSION_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }
    private static final int MAC_OS_VERSION_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }
    private static final int MAC_OS_VERSION_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }
    private static final int MAC_OS_VERSION_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }
    private static final int MAC_OS_VERSION_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }
    private static final int MAC_OS_VERSION_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }
    private static final int MAC_OS_VERSION_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }
    private static final int MAC_OS_VERSION_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }
    private static final int MAC_OS_VERSION_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }
    private static final int MAC_OS_VERSION_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }
    private static final int MAC_OS_VERSION_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }
    private static final int MAC_OS_VERSION_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }
    private static final int MAC_OS_VERSION_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }
    private static final int MAC_OS_VERSION_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }
    private static final int MAC_OS_VERSION_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }
    private static final int MAC_OS_VERSION_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }
    private static final int MAC_OS_X_VERSION_MIN_REQUIRED = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_MIN_REQUIRED 140000
     * }
     */
    public static int MAC_OS_X_VERSION_MIN_REQUIRED() {
        return MAC_OS_X_VERSION_MIN_REQUIRED;
    }
    private static final int MAC_OS_X_VERSION_MAX_ALLOWED = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_MAX_ALLOWED 140000
     * }
     */
    public static int MAC_OS_X_VERSION_MAX_ALLOWED() {
        return MAC_OS_X_VERSION_MAX_ALLOWED;
    }
    private static final int __IPHONE_COMPAT_VERSION = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_COMPAT_VERSION 40000
     * }
     */
    public static int __IPHONE_COMPAT_VERSION() {
        return __IPHONE_COMPAT_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = opencl_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final int CL_SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CL_SCHAR_MIN -128
     * }
     */
    public static int CL_SCHAR_MIN() {
        return CL_SCHAR_MIN;
    }
    private static final int CL_CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CL_CHAR_MAX 127
     * }
     */
    public static int CL_CHAR_MAX() {
        return CL_CHAR_MAX;
    }
    private static final int CL_CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CL_CHAR_MIN -128
     * }
     */
    public static int CL_CHAR_MIN() {
        return CL_CHAR_MIN;
    }
    private static final int CL_SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define CL_SHRT_MIN -32768
     * }
     */
    public static int CL_SHRT_MIN() {
        return CL_SHRT_MIN;
    }
    private static final int CL_INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define CL_INT_MIN -2147483648
     * }
     */
    public static int CL_INT_MIN() {
        return CL_INT_MIN;
    }
    private static final int CL_UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define CL_UINT_MAX 4294967295
     * }
     */
    public static int CL_UINT_MAX() {
        return CL_UINT_MAX;
    }
    private static final long CL_LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define CL_LONG_MAX 9223372036854775807
     * }
     */
    public static long CL_LONG_MAX() {
        return CL_LONG_MAX;
    }
    private static final long CL_LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define CL_LONG_MIN -9223372036854775808
     * }
     */
    public static long CL_LONG_MIN() {
        return CL_LONG_MIN;
    }
    private static final long CL_ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define CL_ULONG_MAX -1
     * }
     */
    public static long CL_ULONG_MAX() {
        return CL_ULONG_MAX;
    }
    private static final int CL_FLT_MAX_10_EXP = (int)38L;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MAX_10_EXP 38
     * }
     */
    public static int CL_FLT_MAX_10_EXP() {
        return CL_FLT_MAX_10_EXP;
    }
    private static final int CL_FLT_MAX_EXP = (int)128L;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MAX_EXP 128
     * }
     */
    public static int CL_FLT_MAX_EXP() {
        return CL_FLT_MAX_EXP;
    }
    private static final int CL_FLT_MIN_10_EXP = (int)-37L;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MIN_10_EXP -37
     * }
     */
    public static int CL_FLT_MIN_10_EXP() {
        return CL_FLT_MIN_10_EXP;
    }
    private static final int CL_FLT_MIN_EXP = (int)-125L;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MIN_EXP -125
     * }
     */
    public static int CL_FLT_MIN_EXP() {
        return CL_FLT_MIN_EXP;
    }
    private static final float CL_FLT_MAX = 3.4028234663852886E38f;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MAX 3.4028234663852886E38
     * }
     */
    public static float CL_FLT_MAX() {
        return CL_FLT_MAX;
    }
    private static final float CL_FLT_MIN = 1.1754943508222875E-38f;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MIN 1.1754943508222875E-38
     * }
     */
    public static float CL_FLT_MIN() {
        return CL_FLT_MIN;
    }
    private static final float CL_FLT_EPSILON = 1.1920928955078125E-7f;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_EPSILON 1.1920928955078125E-7
     * }
     */
    public static float CL_FLT_EPSILON() {
        return CL_FLT_EPSILON;
    }
    private static final int CL_DBL_MAX_10_EXP = (int)308L;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MAX_10_EXP 308
     * }
     */
    public static int CL_DBL_MAX_10_EXP() {
        return CL_DBL_MAX_10_EXP;
    }
    private static final int CL_DBL_MAX_EXP = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MAX_EXP 1024
     * }
     */
    public static int CL_DBL_MAX_EXP() {
        return CL_DBL_MAX_EXP;
    }
    private static final int CL_DBL_MIN_10_EXP = (int)-307L;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MIN_10_EXP -307
     * }
     */
    public static int CL_DBL_MIN_10_EXP() {
        return CL_DBL_MIN_10_EXP;
    }
    private static final int CL_DBL_MIN_EXP = (int)-1021L;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MIN_EXP -1021
     * }
     */
    public static int CL_DBL_MIN_EXP() {
        return CL_DBL_MIN_EXP;
    }
    private static final double CL_DBL_MAX = 1.7976931348623157E308d;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MAX 1.7976931348623157E308
     * }
     */
    public static double CL_DBL_MAX() {
        return CL_DBL_MAX;
    }
    private static final double CL_DBL_MIN = 2.2250738585072014E-308d;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MIN 2.2250738585072014E-308
     * }
     */
    public static double CL_DBL_MIN() {
        return CL_DBL_MIN;
    }
    private static final double CL_DBL_EPSILON = 2.220446049250313E-16d;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_EPSILON 2.220446049250313E-16
     * }
     */
    public static double CL_DBL_EPSILON() {
        return CL_DBL_EPSILON;
    }
    private static final double CL_M_E = 2.718281828459045d;
    /**
     * {@snippet lang=c :
     * #define CL_M_E 2.718281828459045
     * }
     */
    public static double CL_M_E() {
        return CL_M_E;
    }
    private static final double CL_M_LOG2E = 1.4426950408889634d;
    /**
     * {@snippet lang=c :
     * #define CL_M_LOG2E 1.4426950408889634
     * }
     */
    public static double CL_M_LOG2E() {
        return CL_M_LOG2E;
    }
    private static final double CL_M_LOG10E = 0.4342944819032518d;
    /**
     * {@snippet lang=c :
     * #define CL_M_LOG10E 0.4342944819032518
     * }
     */
    public static double CL_M_LOG10E() {
        return CL_M_LOG10E;
    }
    private static final double CL_M_LN2 = 0.6931471805599453d;
    /**
     * {@snippet lang=c :
     * #define CL_M_LN2 0.6931471805599453
     * }
     */
    public static double CL_M_LN2() {
        return CL_M_LN2;
    }
    private static final double CL_M_LN10 = 2.302585092994046d;
    /**
     * {@snippet lang=c :
     * #define CL_M_LN10 2.302585092994046
     * }
     */
    public static double CL_M_LN10() {
        return CL_M_LN10;
    }
    private static final double CL_M_PI = 3.141592653589793d;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI 3.141592653589793
     * }
     */
    public static double CL_M_PI() {
        return CL_M_PI;
    }
    private static final double CL_M_PI_2 = 1.5707963267948966d;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI_2 1.5707963267948966
     * }
     */
    public static double CL_M_PI_2() {
        return CL_M_PI_2;
    }
    private static final double CL_M_PI_4 = 0.7853981633974483d;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI_4 0.7853981633974483
     * }
     */
    public static double CL_M_PI_4() {
        return CL_M_PI_4;
    }
    private static final double CL_M_1_PI = 0.3183098861837907d;
    /**
     * {@snippet lang=c :
     * #define CL_M_1_PI 0.3183098861837907
     * }
     */
    public static double CL_M_1_PI() {
        return CL_M_1_PI;
    }
    private static final double CL_M_2_PI = 0.6366197723675814d;
    /**
     * {@snippet lang=c :
     * #define CL_M_2_PI 0.6366197723675814
     * }
     */
    public static double CL_M_2_PI() {
        return CL_M_2_PI;
    }
    private static final double CL_M_2_SQRTPI = 1.1283791670955126d;
    /**
     * {@snippet lang=c :
     * #define CL_M_2_SQRTPI 1.1283791670955126
     * }
     */
    public static double CL_M_2_SQRTPI() {
        return CL_M_2_SQRTPI;
    }
    private static final double CL_M_SQRT2 = 1.4142135623730951d;
    /**
     * {@snippet lang=c :
     * #define CL_M_SQRT2 1.4142135623730951
     * }
     */
    public static double CL_M_SQRT2() {
        return CL_M_SQRT2;
    }
    private static final double CL_M_SQRT1_2 = 0.7071067811865476d;
    /**
     * {@snippet lang=c :
     * #define CL_M_SQRT1_2 0.7071067811865476
     * }
     */
    public static double CL_M_SQRT1_2() {
        return CL_M_SQRT1_2;
    }
    private static final float CL_M_E_F = 2.7182817459106445f;
    /**
     * {@snippet lang=c :
     * #define CL_M_E_F 2.7182817459106445
     * }
     */
    public static float CL_M_E_F() {
        return CL_M_E_F;
    }
    private static final float CL_M_LOG2E_F = 1.4426950216293335f;
    /**
     * {@snippet lang=c :
     * #define CL_M_LOG2E_F 1.4426950216293335
     * }
     */
    public static float CL_M_LOG2E_F() {
        return CL_M_LOG2E_F;
    }
    private static final float CL_M_LOG10E_F = 0.4342944920063019f;
    /**
     * {@snippet lang=c :
     * #define CL_M_LOG10E_F 0.4342944920063019
     * }
     */
    public static float CL_M_LOG10E_F() {
        return CL_M_LOG10E_F;
    }
    private static final float CL_M_LN2_F = 0.6931471824645996f;
    /**
     * {@snippet lang=c :
     * #define CL_M_LN2_F 0.6931471824645996
     * }
     */
    public static float CL_M_LN2_F() {
        return CL_M_LN2_F;
    }
    private static final float CL_M_LN10_F = 2.3025851249694824f;
    /**
     * {@snippet lang=c :
     * #define CL_M_LN10_F 2.3025851249694824
     * }
     */
    public static float CL_M_LN10_F() {
        return CL_M_LN10_F;
    }
    private static final float CL_M_PI_F = 3.1415927410125732f;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI_F 3.1415927410125732
     * }
     */
    public static float CL_M_PI_F() {
        return CL_M_PI_F;
    }
    private static final float CL_M_PI_2_F = 1.5707963705062866f;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI_2_F 1.5707963705062866
     * }
     */
    public static float CL_M_PI_2_F() {
        return CL_M_PI_2_F;
    }
    private static final float CL_M_PI_4_F = 0.7853981852531433f;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI_4_F 0.7853981852531433
     * }
     */
    public static float CL_M_PI_4_F() {
        return CL_M_PI_4_F;
    }
    private static final float CL_M_1_PI_F = 0.31830987334251404f;
    /**
     * {@snippet lang=c :
     * #define CL_M_1_PI_F 0.31830987334251404
     * }
     */
    public static float CL_M_1_PI_F() {
        return CL_M_1_PI_F;
    }
    private static final float CL_M_2_PI_F = 0.6366197466850281f;
    /**
     * {@snippet lang=c :
     * #define CL_M_2_PI_F 0.6366197466850281
     * }
     */
    public static float CL_M_2_PI_F() {
        return CL_M_2_PI_F;
    }
    private static final float CL_M_2_SQRTPI_F = 1.128379225730896f;
    /**
     * {@snippet lang=c :
     * #define CL_M_2_SQRTPI_F 1.128379225730896
     * }
     */
    public static float CL_M_2_SQRTPI_F() {
        return CL_M_2_SQRTPI_F;
    }
    private static final float CL_M_SQRT2_F = 1.4142135381698608f;
    /**
     * {@snippet lang=c :
     * #define CL_M_SQRT2_F 1.4142135381698608
     * }
     */
    public static float CL_M_SQRT2_F() {
        return CL_M_SQRT2_F;
    }
    private static final float CL_M_SQRT1_2_F = 0.7071067690849304f;
    /**
     * {@snippet lang=c :
     * #define CL_M_SQRT1_2_F 0.7071067690849304
     * }
     */
    public static float CL_M_SQRT1_2_F() {
        return CL_M_SQRT1_2_F;
    }
    private static final float CL_HUGE_VALF = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define CL_HUGE_VALF Infinity
     * }
     */
    public static float CL_HUGE_VALF() {
        return CL_HUGE_VALF;
    }
    private static final double CL_HUGE_VAL = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define CL_HUGE_VAL Infinity
     * }
     */
    public static double CL_HUGE_VAL() {
        return CL_HUGE_VAL;
    }
    private static final float CL_NAN = Float.valueOf("NaN");
    /**
     * {@snippet lang=c :
     * #define CL_NAN NaN
     * }
     */
    public static float CL_NAN() {
        return CL_NAN;
    }
    private static final float CL_MAXFLOAT = 3.4028234663852886E38f;
    /**
     * {@snippet lang=c :
     * #define CL_MAXFLOAT 3.4028234663852886E38
     * }
     */
    public static float CL_MAXFLOAT() {
        return CL_MAXFLOAT;
    }
    private static final float CL_INFINITY = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define CL_INFINITY Infinity
     * }
     */
    public static float CL_INFINITY() {
        return CL_INFINITY;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    /**
     * {@snippet lang=c :
     * #define CL_PROGRAM_STRING_DEBUG_INFO "#line 899 "/var/folders/1n/rvbnsx0d0xj86t1s28j02x9c0000gn/T/jextract$5751839980841457817.h" 
     * 
     * "
     * }
     */
    public static MemorySegment CL_PROGRAM_STRING_DEBUG_INFO() {
        class Holder {
            static final MemorySegment CL_PROGRAM_STRING_DEBUG_INFO
                = opencl_h.LIBRARY_ARENA.allocateFrom("#line 899 \"/var/folders/1n/rvbnsx0d0xj86t1s28j02x9c0000gn/T/jextract$5751839980841457817.h\" \n\n");
        }
        return Holder.CL_PROGRAM_STRING_DEBUG_INFO;
    }
    private static final int CL_DEVICE_NOT_FOUND = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_NOT_FOUND -1
     * }
     */
    public static int CL_DEVICE_NOT_FOUND() {
        return CL_DEVICE_NOT_FOUND;
    }
    private static final int CL_DEVICE_NOT_AVAILABLE = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_NOT_AVAILABLE -2
     * }
     */
    public static int CL_DEVICE_NOT_AVAILABLE() {
        return CL_DEVICE_NOT_AVAILABLE;
    }
    private static final int CL_COMPILER_NOT_AVAILABLE = (int)-3L;
    /**
     * {@snippet lang=c :
     * #define CL_COMPILER_NOT_AVAILABLE -3
     * }
     */
    public static int CL_COMPILER_NOT_AVAILABLE() {
        return CL_COMPILER_NOT_AVAILABLE;
    }
    private static final int CL_MEM_OBJECT_ALLOCATION_FAILURE = (int)-4L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_OBJECT_ALLOCATION_FAILURE -4
     * }
     */
    public static int CL_MEM_OBJECT_ALLOCATION_FAILURE() {
        return CL_MEM_OBJECT_ALLOCATION_FAILURE;
    }
    private static final int CL_OUT_OF_RESOURCES = (int)-5L;
    /**
     * {@snippet lang=c :
     * #define CL_OUT_OF_RESOURCES -5
     * }
     */
    public static int CL_OUT_OF_RESOURCES() {
        return CL_OUT_OF_RESOURCES;
    }
    private static final int CL_OUT_OF_HOST_MEMORY = (int)-6L;
    /**
     * {@snippet lang=c :
     * #define CL_OUT_OF_HOST_MEMORY -6
     * }
     */
    public static int CL_OUT_OF_HOST_MEMORY() {
        return CL_OUT_OF_HOST_MEMORY;
    }
    private static final int CL_PROFILING_INFO_NOT_AVAILABLE = (int)-7L;
    /**
     * {@snippet lang=c :
     * #define CL_PROFILING_INFO_NOT_AVAILABLE -7
     * }
     */
    public static int CL_PROFILING_INFO_NOT_AVAILABLE() {
        return CL_PROFILING_INFO_NOT_AVAILABLE;
    }
    private static final int CL_MEM_COPY_OVERLAP = (int)-8L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_COPY_OVERLAP -8
     * }
     */
    public static int CL_MEM_COPY_OVERLAP() {
        return CL_MEM_COPY_OVERLAP;
    }
    private static final int CL_IMAGE_FORMAT_MISMATCH = (int)-9L;
    /**
     * {@snippet lang=c :
     * #define CL_IMAGE_FORMAT_MISMATCH -9
     * }
     */
    public static int CL_IMAGE_FORMAT_MISMATCH() {
        return CL_IMAGE_FORMAT_MISMATCH;
    }
    private static final int CL_IMAGE_FORMAT_NOT_SUPPORTED = (int)-10L;
    /**
     * {@snippet lang=c :
     * #define CL_IMAGE_FORMAT_NOT_SUPPORTED -10
     * }
     */
    public static int CL_IMAGE_FORMAT_NOT_SUPPORTED() {
        return CL_IMAGE_FORMAT_NOT_SUPPORTED;
    }
    private static final int CL_BUILD_PROGRAM_FAILURE = (int)-11L;
    /**
     * {@snippet lang=c :
     * #define CL_BUILD_PROGRAM_FAILURE -11
     * }
     */
    public static int CL_BUILD_PROGRAM_FAILURE() {
        return CL_BUILD_PROGRAM_FAILURE;
    }
    private static final int CL_MAP_FAILURE = (int)-12L;
    /**
     * {@snippet lang=c :
     * #define CL_MAP_FAILURE -12
     * }
     */
    public static int CL_MAP_FAILURE() {
        return CL_MAP_FAILURE;
    }
    private static final int CL_MISALIGNED_SUB_BUFFER_OFFSET = (int)-13L;
    /**
     * {@snippet lang=c :
     * #define CL_MISALIGNED_SUB_BUFFER_OFFSET -13
     * }
     */
    public static int CL_MISALIGNED_SUB_BUFFER_OFFSET() {
        return CL_MISALIGNED_SUB_BUFFER_OFFSET;
    }
    private static final int CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = (int)-14L;
    /**
     * {@snippet lang=c :
     * #define CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST -14
     * }
     */
    public static int CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST() {
        return CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST;
    }
    private static final int CL_COMPILE_PROGRAM_FAILURE = (int)-15L;
    /**
     * {@snippet lang=c :
     * #define CL_COMPILE_PROGRAM_FAILURE -15
     * }
     */
    public static int CL_COMPILE_PROGRAM_FAILURE() {
        return CL_COMPILE_PROGRAM_FAILURE;
    }
    private static final int CL_LINKER_NOT_AVAILABLE = (int)-16L;
    /**
     * {@snippet lang=c :
     * #define CL_LINKER_NOT_AVAILABLE -16
     * }
     */
    public static int CL_LINKER_NOT_AVAILABLE() {
        return CL_LINKER_NOT_AVAILABLE;
    }
    private static final int CL_LINK_PROGRAM_FAILURE = (int)-17L;
    /**
     * {@snippet lang=c :
     * #define CL_LINK_PROGRAM_FAILURE -17
     * }
     */
    public static int CL_LINK_PROGRAM_FAILURE() {
        return CL_LINK_PROGRAM_FAILURE;
    }
    private static final int CL_DEVICE_PARTITION_FAILED = (int)-18L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_PARTITION_FAILED -18
     * }
     */
    public static int CL_DEVICE_PARTITION_FAILED() {
        return CL_DEVICE_PARTITION_FAILED;
    }
    private static final int CL_KERNEL_ARG_INFO_NOT_AVAILABLE = (int)-19L;
    /**
     * {@snippet lang=c :
     * #define CL_KERNEL_ARG_INFO_NOT_AVAILABLE -19
     * }
     */
    public static int CL_KERNEL_ARG_INFO_NOT_AVAILABLE() {
        return CL_KERNEL_ARG_INFO_NOT_AVAILABLE;
    }
    private static final int CL_INVALID_VALUE = (int)-30L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_VALUE -30
     * }
     */
    public static int CL_INVALID_VALUE() {
        return CL_INVALID_VALUE;
    }
    private static final int CL_INVALID_DEVICE_TYPE = (int)-31L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_DEVICE_TYPE -31
     * }
     */
    public static int CL_INVALID_DEVICE_TYPE() {
        return CL_INVALID_DEVICE_TYPE;
    }
    private static final int CL_INVALID_PLATFORM = (int)-32L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PLATFORM -32
     * }
     */
    public static int CL_INVALID_PLATFORM() {
        return CL_INVALID_PLATFORM;
    }
    private static final int CL_INVALID_DEVICE = (int)-33L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_DEVICE -33
     * }
     */
    public static int CL_INVALID_DEVICE() {
        return CL_INVALID_DEVICE;
    }
    private static final int CL_INVALID_CONTEXT = (int)-34L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_CONTEXT -34
     * }
     */
    public static int CL_INVALID_CONTEXT() {
        return CL_INVALID_CONTEXT;
    }
    private static final int CL_INVALID_QUEUE_PROPERTIES = (int)-35L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_QUEUE_PROPERTIES -35
     * }
     */
    public static int CL_INVALID_QUEUE_PROPERTIES() {
        return CL_INVALID_QUEUE_PROPERTIES;
    }
    private static final int CL_INVALID_COMMAND_QUEUE = (int)-36L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_COMMAND_QUEUE -36
     * }
     */
    public static int CL_INVALID_COMMAND_QUEUE() {
        return CL_INVALID_COMMAND_QUEUE;
    }
    private static final int CL_INVALID_HOST_PTR = (int)-37L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_HOST_PTR -37
     * }
     */
    public static int CL_INVALID_HOST_PTR() {
        return CL_INVALID_HOST_PTR;
    }
    private static final int CL_INVALID_MEM_OBJECT = (int)-38L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_MEM_OBJECT -38
     * }
     */
    public static int CL_INVALID_MEM_OBJECT() {
        return CL_INVALID_MEM_OBJECT;
    }
    private static final int CL_INVALID_IMAGE_FORMAT_DESCRIPTOR = (int)-39L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_IMAGE_FORMAT_DESCRIPTOR -39
     * }
     */
    public static int CL_INVALID_IMAGE_FORMAT_DESCRIPTOR() {
        return CL_INVALID_IMAGE_FORMAT_DESCRIPTOR;
    }
    private static final int CL_INVALID_IMAGE_SIZE = (int)-40L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_IMAGE_SIZE -40
     * }
     */
    public static int CL_INVALID_IMAGE_SIZE() {
        return CL_INVALID_IMAGE_SIZE;
    }
    private static final int CL_INVALID_SAMPLER = (int)-41L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_SAMPLER -41
     * }
     */
    public static int CL_INVALID_SAMPLER() {
        return CL_INVALID_SAMPLER;
    }
    private static final int CL_INVALID_BINARY = (int)-42L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_BINARY -42
     * }
     */
    public static int CL_INVALID_BINARY() {
        return CL_INVALID_BINARY;
    }
    private static final int CL_INVALID_BUILD_OPTIONS = (int)-43L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_BUILD_OPTIONS -43
     * }
     */
    public static int CL_INVALID_BUILD_OPTIONS() {
        return CL_INVALID_BUILD_OPTIONS;
    }
    private static final int CL_INVALID_PROGRAM = (int)-44L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PROGRAM -44
     * }
     */
    public static int CL_INVALID_PROGRAM() {
        return CL_INVALID_PROGRAM;
    }
    private static final int CL_INVALID_PROGRAM_EXECUTABLE = (int)-45L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PROGRAM_EXECUTABLE -45
     * }
     */
    public static int CL_INVALID_PROGRAM_EXECUTABLE() {
        return CL_INVALID_PROGRAM_EXECUTABLE;
    }
    private static final int CL_INVALID_KERNEL_NAME = (int)-46L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_KERNEL_NAME -46
     * }
     */
    public static int CL_INVALID_KERNEL_NAME() {
        return CL_INVALID_KERNEL_NAME;
    }
    private static final int CL_INVALID_KERNEL_DEFINITION = (int)-47L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_KERNEL_DEFINITION -47
     * }
     */
    public static int CL_INVALID_KERNEL_DEFINITION() {
        return CL_INVALID_KERNEL_DEFINITION;
    }
    private static final int CL_INVALID_KERNEL = (int)-48L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_KERNEL -48
     * }
     */
    public static int CL_INVALID_KERNEL() {
        return CL_INVALID_KERNEL;
    }
    private static final int CL_INVALID_ARG_INDEX = (int)-49L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_ARG_INDEX -49
     * }
     */
    public static int CL_INVALID_ARG_INDEX() {
        return CL_INVALID_ARG_INDEX;
    }
    private static final int CL_INVALID_ARG_VALUE = (int)-50L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_ARG_VALUE -50
     * }
     */
    public static int CL_INVALID_ARG_VALUE() {
        return CL_INVALID_ARG_VALUE;
    }
    private static final int CL_INVALID_ARG_SIZE = (int)-51L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_ARG_SIZE -51
     * }
     */
    public static int CL_INVALID_ARG_SIZE() {
        return CL_INVALID_ARG_SIZE;
    }
    private static final int CL_INVALID_KERNEL_ARGS = (int)-52L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_KERNEL_ARGS -52
     * }
     */
    public static int CL_INVALID_KERNEL_ARGS() {
        return CL_INVALID_KERNEL_ARGS;
    }
    private static final int CL_INVALID_WORK_DIMENSION = (int)-53L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_WORK_DIMENSION -53
     * }
     */
    public static int CL_INVALID_WORK_DIMENSION() {
        return CL_INVALID_WORK_DIMENSION;
    }
    private static final int CL_INVALID_WORK_GROUP_SIZE = (int)-54L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_WORK_GROUP_SIZE -54
     * }
     */
    public static int CL_INVALID_WORK_GROUP_SIZE() {
        return CL_INVALID_WORK_GROUP_SIZE;
    }
    private static final int CL_INVALID_WORK_ITEM_SIZE = (int)-55L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_WORK_ITEM_SIZE -55
     * }
     */
    public static int CL_INVALID_WORK_ITEM_SIZE() {
        return CL_INVALID_WORK_ITEM_SIZE;
    }
    private static final int CL_INVALID_GLOBAL_OFFSET = (int)-56L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_GLOBAL_OFFSET -56
     * }
     */
    public static int CL_INVALID_GLOBAL_OFFSET() {
        return CL_INVALID_GLOBAL_OFFSET;
    }
    private static final int CL_INVALID_EVENT_WAIT_LIST = (int)-57L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_EVENT_WAIT_LIST -57
     * }
     */
    public static int CL_INVALID_EVENT_WAIT_LIST() {
        return CL_INVALID_EVENT_WAIT_LIST;
    }
    private static final int CL_INVALID_EVENT = (int)-58L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_EVENT -58
     * }
     */
    public static int CL_INVALID_EVENT() {
        return CL_INVALID_EVENT;
    }
    private static final int CL_INVALID_OPERATION = (int)-59L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_OPERATION -59
     * }
     */
    public static int CL_INVALID_OPERATION() {
        return CL_INVALID_OPERATION;
    }
    private static final int CL_INVALID_GL_OBJECT = (int)-60L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_GL_OBJECT -60
     * }
     */
    public static int CL_INVALID_GL_OBJECT() {
        return CL_INVALID_GL_OBJECT;
    }
    private static final int CL_INVALID_BUFFER_SIZE = (int)-61L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_BUFFER_SIZE -61
     * }
     */
    public static int CL_INVALID_BUFFER_SIZE() {
        return CL_INVALID_BUFFER_SIZE;
    }
    private static final int CL_INVALID_MIP_LEVEL = (int)-62L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_MIP_LEVEL -62
     * }
     */
    public static int CL_INVALID_MIP_LEVEL() {
        return CL_INVALID_MIP_LEVEL;
    }
    private static final int CL_INVALID_GLOBAL_WORK_SIZE = (int)-63L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_GLOBAL_WORK_SIZE -63
     * }
     */
    public static int CL_INVALID_GLOBAL_WORK_SIZE() {
        return CL_INVALID_GLOBAL_WORK_SIZE;
    }
    private static final int CL_INVALID_PROPERTY = (int)-64L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PROPERTY -64
     * }
     */
    public static int CL_INVALID_PROPERTY() {
        return CL_INVALID_PROPERTY;
    }
    private static final int CL_INVALID_IMAGE_DESCRIPTOR = (int)-65L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_IMAGE_DESCRIPTOR -65
     * }
     */
    public static int CL_INVALID_IMAGE_DESCRIPTOR() {
        return CL_INVALID_IMAGE_DESCRIPTOR;
    }
    private static final int CL_INVALID_COMPILER_OPTIONS = (int)-66L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_COMPILER_OPTIONS -66
     * }
     */
    public static int CL_INVALID_COMPILER_OPTIONS() {
        return CL_INVALID_COMPILER_OPTIONS;
    }
    private static final int CL_INVALID_LINKER_OPTIONS = (int)-67L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_LINKER_OPTIONS -67
     * }
     */
    public static int CL_INVALID_LINKER_OPTIONS() {
        return CL_INVALID_LINKER_OPTIONS;
    }
    private static final int CL_INVALID_DEVICE_PARTITION_COUNT = (int)-68L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_DEVICE_PARTITION_COUNT -68
     * }
     */
    public static int CL_INVALID_DEVICE_PARTITION_COUNT() {
        return CL_INVALID_DEVICE_PARTITION_COUNT;
    }
    private static final int CL_BLOCKING = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_BLOCKING 1
     * }
     */
    public static int CL_BLOCKING() {
        return CL_BLOCKING;
    }
    private static final int CL_NON_BLOCKING = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CL_NON_BLOCKING 0
     * }
     */
    public static int CL_NON_BLOCKING() {
        return CL_NON_BLOCKING;
    }
    private static final int CL_DEVICE_TYPE_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_DEFAULT 1
     * }
     */
    public static int CL_DEVICE_TYPE_DEFAULT() {
        return CL_DEVICE_TYPE_DEFAULT;
    }
    private static final int CL_DEVICE_TYPE_CPU = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_CPU 2
     * }
     */
    public static int CL_DEVICE_TYPE_CPU() {
        return CL_DEVICE_TYPE_CPU;
    }
    private static final int CL_DEVICE_TYPE_GPU = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_GPU 4
     * }
     */
    public static int CL_DEVICE_TYPE_GPU() {
        return CL_DEVICE_TYPE_GPU;
    }
    private static final int CL_DEVICE_TYPE_ACCELERATOR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_ACCELERATOR 8
     * }
     */
    public static int CL_DEVICE_TYPE_ACCELERATOR() {
        return CL_DEVICE_TYPE_ACCELERATOR;
    }
    private static final int CL_DEVICE_TYPE_CUSTOM = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_CUSTOM 16
     * }
     */
    public static int CL_DEVICE_TYPE_CUSTOM() {
        return CL_DEVICE_TYPE_CUSTOM;
    }
    private static final int CL_DEVICE_TYPE_ALL = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_ALL 4294967295
     * }
     */
    public static int CL_DEVICE_TYPE_ALL() {
        return CL_DEVICE_TYPE_ALL;
    }
    private static final int CL_FP_DENORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_DENORM 1
     * }
     */
    public static int CL_FP_DENORM() {
        return CL_FP_DENORM;
    }
    private static final int CL_FP_INF_NAN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_INF_NAN 2
     * }
     */
    public static int CL_FP_INF_NAN() {
        return CL_FP_INF_NAN;
    }
    private static final int CL_FP_ROUND_TO_NEAREST = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_ROUND_TO_NEAREST 4
     * }
     */
    public static int CL_FP_ROUND_TO_NEAREST() {
        return CL_FP_ROUND_TO_NEAREST;
    }
    private static final int CL_FP_ROUND_TO_ZERO = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_ROUND_TO_ZERO 8
     * }
     */
    public static int CL_FP_ROUND_TO_ZERO() {
        return CL_FP_ROUND_TO_ZERO;
    }
    private static final int CL_FP_ROUND_TO_INF = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_ROUND_TO_INF 16
     * }
     */
    public static int CL_FP_ROUND_TO_INF() {
        return CL_FP_ROUND_TO_INF;
    }
    private static final int CL_FP_FMA = (int)32L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_FMA 32
     * }
     */
    public static int CL_FP_FMA() {
        return CL_FP_FMA;
    }
    private static final int CL_FP_SOFT_FLOAT = (int)64L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_SOFT_FLOAT 64
     * }
     */
    public static int CL_FP_SOFT_FLOAT() {
        return CL_FP_SOFT_FLOAT;
    }
    private static final int CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT = (int)128L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT 128
     * }
     */
    public static int CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT() {
        return CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT;
    }
    private static final int CL_EXEC_KERNEL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_EXEC_KERNEL 1
     * }
     */
    public static int CL_EXEC_KERNEL() {
        return CL_EXEC_KERNEL;
    }
    private static final int CL_EXEC_NATIVE_KERNEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_EXEC_NATIVE_KERNEL 2
     * }
     */
    public static int CL_EXEC_NATIVE_KERNEL() {
        return CL_EXEC_NATIVE_KERNEL;
    }
    private static final int CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE 1
     * }
     */
    public static int CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE() {
        return CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE;
    }
    private static final int CL_QUEUE_PROFILING_ENABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_QUEUE_PROFILING_ENABLE 2
     * }
     */
    public static int CL_QUEUE_PROFILING_ENABLE() {
        return CL_QUEUE_PROFILING_ENABLE;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_NUMA = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_NUMA 1
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_NUMA() {
        return CL_DEVICE_AFFINITY_DOMAIN_NUMA;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE 2
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE() {
        return CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE 4
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE() {
        return CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE 8
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE() {
        return CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE 16
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE() {
        return CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE 32
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE() {
        return CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE;
    }
    private static final int CL_MEM_READ_WRITE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_READ_WRITE 1
     * }
     */
    public static int CL_MEM_READ_WRITE() {
        return CL_MEM_READ_WRITE;
    }
    private static final int CL_MEM_WRITE_ONLY = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_WRITE_ONLY 2
     * }
     */
    public static int CL_MEM_WRITE_ONLY() {
        return CL_MEM_WRITE_ONLY;
    }
    private static final int CL_MEM_READ_ONLY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_READ_ONLY 4
     * }
     */
    public static int CL_MEM_READ_ONLY() {
        return CL_MEM_READ_ONLY;
    }
    private static final int CL_MEM_USE_HOST_PTR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_USE_HOST_PTR 8
     * }
     */
    public static int CL_MEM_USE_HOST_PTR() {
        return CL_MEM_USE_HOST_PTR;
    }
    private static final int CL_MEM_ALLOC_HOST_PTR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_ALLOC_HOST_PTR 16
     * }
     */
    public static int CL_MEM_ALLOC_HOST_PTR() {
        return CL_MEM_ALLOC_HOST_PTR;
    }
    private static final int CL_MEM_COPY_HOST_PTR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_COPY_HOST_PTR 32
     * }
     */
    public static int CL_MEM_COPY_HOST_PTR() {
        return CL_MEM_COPY_HOST_PTR;
    }
    private static final int CL_MEM_HOST_WRITE_ONLY = (int)128L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_HOST_WRITE_ONLY 128
     * }
     */
    public static int CL_MEM_HOST_WRITE_ONLY() {
        return CL_MEM_HOST_WRITE_ONLY;
    }
    private static final int CL_MEM_HOST_READ_ONLY = (int)256L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_HOST_READ_ONLY 256
     * }
     */
    public static int CL_MEM_HOST_READ_ONLY() {
        return CL_MEM_HOST_READ_ONLY;
    }
    private static final int CL_MEM_HOST_NO_ACCESS = (int)512L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_HOST_NO_ACCESS 512
     * }
     */
    public static int CL_MEM_HOST_NO_ACCESS() {
        return CL_MEM_HOST_NO_ACCESS;
    }
    private static final int CL_MIGRATE_MEM_OBJECT_HOST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_MIGRATE_MEM_OBJECT_HOST 1
     * }
     */
    public static int CL_MIGRATE_MEM_OBJECT_HOST() {
        return CL_MIGRATE_MEM_OBJECT_HOST;
    }
    private static final int CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED 2
     * }
     */
    public static int CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED() {
        return CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED;
    }
    private static final int CL_MAP_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_MAP_READ 1
     * }
     */
    public static int CL_MAP_READ() {
        return CL_MAP_READ;
    }
    private static final int CL_MAP_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_MAP_WRITE 2
     * }
     */
    public static int CL_MAP_WRITE() {
        return CL_MAP_WRITE;
    }
    private static final int CL_MAP_WRITE_INVALIDATE_REGION = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_MAP_WRITE_INVALIDATE_REGION 4
     * }
     */
    public static int CL_MAP_WRITE_INVALIDATE_REGION() {
        return CL_MAP_WRITE_INVALIDATE_REGION;
    }
    private static final int CL_BUILD_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define CL_BUILD_NONE -1
     * }
     */
    public static int CL_BUILD_NONE() {
        return CL_BUILD_NONE;
    }
    private static final int CL_BUILD_ERROR = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define CL_BUILD_ERROR -2
     * }
     */
    public static int CL_BUILD_ERROR() {
        return CL_BUILD_ERROR;
    }
    private static final int CL_BUILD_IN_PROGRESS = (int)-3L;
    /**
     * {@snippet lang=c :
     * #define CL_BUILD_IN_PROGRESS -3
     * }
     */
    public static int CL_BUILD_IN_PROGRESS() {
        return CL_BUILD_IN_PROGRESS;
    }
    private static final int CL_KERNEL_ARG_TYPE_CONST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_KERNEL_ARG_TYPE_CONST 1
     * }
     */
    public static int CL_KERNEL_ARG_TYPE_CONST() {
        return CL_KERNEL_ARG_TYPE_CONST;
    }
    private static final int CL_KERNEL_ARG_TYPE_RESTRICT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_KERNEL_ARG_TYPE_RESTRICT 2
     * }
     */
    public static int CL_KERNEL_ARG_TYPE_RESTRICT() {
        return CL_KERNEL_ARG_TYPE_RESTRICT;
    }
    private static final int CL_KERNEL_ARG_TYPE_VOLATILE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_KERNEL_ARG_TYPE_VOLATILE 4
     * }
     */
    public static int CL_KERNEL_ARG_TYPE_VOLATILE() {
        return CL_KERNEL_ARG_TYPE_VOLATILE;
    }
    private static final int kCGLARGB16161616Bit = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define kCGLARGB16161616Bit 8388608
     * }
     */
    public static int kCGLARGB16161616Bit() {
        return kCGLARGB16161616Bit;
    }
    private static final int CL_INVALID_GL_CONTEXT_APPLE = (int)-1000L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_GL_CONTEXT_APPLE -1000
     * }
     */
    public static int CL_INVALID_GL_CONTEXT_APPLE() {
        return CL_INVALID_GL_CONTEXT_APPLE;
    }
    private static final int CL_INVALID_ARG_NAME_APPLE = (int)-1060L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_ARG_NAME_APPLE -1060
     * }
     */
    public static int CL_INVALID_ARG_NAME_APPLE() {
        return CL_INVALID_ARG_NAME_APPLE;
    }
    private static final int TARGET_IPHONE_SIMULATOR = (int)0L;
    /**
     * {@snippet lang=c :
     * #define TARGET_IPHONE_SIMULATOR 0
     * }
     */
    public static int TARGET_IPHONE_SIMULATOR() {
        return TARGET_IPHONE_SIMULATOR;
    }
    private static final int TARGET_OS_NANO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define TARGET_OS_NANO 0
     * }
     */
    public static int TARGET_OS_NANO() {
        return TARGET_OS_NANO;
    }
    private static final int TARGET_ABI_USES_IOS_VALUES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TARGET_ABI_USES_IOS_VALUES 1
     * }
     */
    public static int TARGET_ABI_USES_IOS_VALUES() {
        return TARGET_ABI_USES_IOS_VALUES;
    }
    private static final int __DARWIN_BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BYTE_ORDER 1234
     * }
     */
    public static int __DARWIN_BYTE_ORDER() {
        return __DARWIN_BYTE_ORDER;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final long __DARWIN_NFDBITS = 32L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NFDBITS 32
     * }
     */
    public static long __DARWIN_NFDBITS() {
        return __DARWIN_NFDBITS;
    }
}

